import {
  require_jsx_runtime
} from "./chunk-YG5AX2YU.js";
import {
  require_react
} from "./chunk-73THXJN7.js";
import {
  A,
  An,
  AxiosError,
  B,
  D,
  HDKey,
  HexString,
  Vn,
  W,
  a,
  aptosClient,
  aptos_types_exports,
  axios_default,
  bcs_exports,
  bytesToHex,
  c,
  c2,
  d,
  decode,
  e,
  ed25519,
  eventemitter3_default,
  f,
  f2,
  f3,
  getWallets,
  gn,
  h,
  hexToBytes,
  hmac,
  i,
  isAxiosError,
  j,
  jwtDecode,
  l,
  m,
  mnemonicToSeedSync,
  n,
  n2,
  n3,
  n4,
  o,
  o2,
  o3,
  p,
  r,
  r2,
  randomBytes,
  require_buffer,
  require_nacl_fast,
  require_poseidon_lite,
  secp256k1,
  sha3_256,
  sha512,
  t,
  t2,
  t3,
  t4,
  u,
  u2,
  x,
  y
} from "./chunk-WNR6NOEE.js";
import {
  __commonJS,
  __publicField,
  __toESM
} from "./chunk-2TUXWMP5.js";

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn4, context, once) {
      this.fn = fn4;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn4, context, once) {
      if (typeof fn4 !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn4, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter3() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter3.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter3.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i49 = 0, l20 = handlers.length, ee4 = new Array(l20); i49 < l20; i49++) {
        ee4[i49] = handlers[i49].fn;
      }
      return ee4;
    };
    EventEmitter3.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter3.prototype.emit = function emit(event, a1, a26, a32, a42, a52) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i49;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a26), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a26, a32), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a26, a32, a42), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a26, a32, a42, a52), true;
        }
        for (i49 = 1, args = new Array(len - 1); i49 < len; i49++) {
          args[i49 - 1] = arguments[i49];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j7;
        for (i49 = 0; i49 < length; i49++) {
          if (listeners[i49].once) this.removeListener(event, listeners[i49].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i49].fn.call(listeners[i49].context);
              break;
            case 2:
              listeners[i49].fn.call(listeners[i49].context, a1);
              break;
            case 3:
              listeners[i49].fn.call(listeners[i49].context, a1, a26);
              break;
            case 4:
              listeners[i49].fn.call(listeners[i49].context, a1, a26, a32);
              break;
            default:
              if (!args) for (j7 = 1, args = new Array(len - 1); j7 < len; j7++) {
                args[j7 - 1] = arguments[j7];
              }
              listeners[i49].fn.apply(listeners[i49].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter3.prototype.on = function on4(event, fn4, context) {
      return addListener(this, event, fn4, context, false);
    };
    EventEmitter3.prototype.once = function once(event, fn4, context) {
      return addListener(this, event, fn4, context, true);
    };
    EventEmitter3.prototype.removeListener = function removeListener(event, fn4, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn4) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn4 && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i49 = 0, events = [], length = listeners.length; i49 < length; i49++) {
          if (listeners[i49].fn !== fn4 || once && !listeners[i49].once || context && listeners[i49].context !== context) {
            events.push(listeners[i49]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter3.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
    EventEmitter3.prototype.addListener = EventEmitter3.prototype.on;
    EventEmitter3.prefixed = prefix;
    EventEmitter3.EventEmitter = EventEmitter3;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter3;
    }
  }
});

// node_modules/ed2curve/ed2curve.js
var require_ed2curve = __commonJS({
  "node_modules/ed2curve/ed2curve.js"(exports, module) {
    (function(root, f19) {
      "use strict";
      if (typeof module !== "undefined" && module.exports) module.exports = f19(require_nacl_fast());
      else root.ed2curve = f19(root.nacl);
    })(exports, function(nacl4) {
      "use strict";
      if (!nacl4) throw new Error("tweetnacl not loaded");
      var gf = function(init) {
        var i49, r30 = new Float64Array(16);
        if (init) for (i49 = 0; i49 < init.length; i49++) r30[i49] = init[i49];
        return r30;
      };
      var gf0 = gf(), gf1 = gf([1]), D11 = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), I7 = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function car25519(o34) {
        var c16;
        var i49;
        for (i49 = 0; i49 < 16; i49++) {
          o34[i49] += 65536;
          c16 = Math.floor(o34[i49] / 65536);
          o34[(i49 + 1) * (i49 < 15 ? 1 : 0)] += c16 - 1 + 37 * (c16 - 1) * (i49 === 15 ? 1 : 0);
          o34[i49] -= c16 * 65536;
        }
      }
      function sel25519(p16, q6, b12) {
        var t39, c16 = ~(b12 - 1);
        for (var i49 = 0; i49 < 16; i49++) {
          t39 = c16 & (p16[i49] ^ q6[i49]);
          p16[i49] ^= t39;
          q6[i49] ^= t39;
        }
      }
      function unpack25519(o34, n27) {
        var i49;
        for (i49 = 0; i49 < 16; i49++) o34[i49] = n27[2 * i49] + (n27[2 * i49 + 1] << 8);
        o34[15] &= 32767;
      }
      function A18(o34, a26, b12) {
        var i49;
        for (i49 = 0; i49 < 16; i49++) o34[i49] = a26[i49] + b12[i49] | 0;
      }
      function Z5(o34, a26, b12) {
        var i49;
        for (i49 = 0; i49 < 16; i49++) o34[i49] = a26[i49] - b12[i49] | 0;
      }
      function M5(o34, a26, b12) {
        var i49, j7, t39 = new Float64Array(31);
        for (i49 = 0; i49 < 31; i49++) t39[i49] = 0;
        for (i49 = 0; i49 < 16; i49++) {
          for (j7 = 0; j7 < 16; j7++) {
            t39[i49 + j7] += a26[i49] * b12[j7];
          }
        }
        for (i49 = 0; i49 < 15; i49++) {
          t39[i49] += 38 * t39[i49 + 16];
        }
        for (i49 = 0; i49 < 16; i49++) o34[i49] = t39[i49];
        car25519(o34);
        car25519(o34);
      }
      function S9(o34, a26) {
        M5(o34, a26, a26);
      }
      function inv25519(o34, i49) {
        var c16 = gf();
        var a26;
        for (a26 = 0; a26 < 16; a26++) c16[a26] = i49[a26];
        for (a26 = 253; a26 >= 0; a26--) {
          S9(c16, c16);
          if (a26 !== 2 && a26 !== 4) M5(c16, c16, i49);
        }
        for (a26 = 0; a26 < 16; a26++) o34[a26] = c16[a26];
      }
      function pack25519(o34, n27) {
        var i49, j7, b12;
        var m17 = gf(), t39 = gf();
        for (i49 = 0; i49 < 16; i49++) t39[i49] = n27[i49];
        car25519(t39);
        car25519(t39);
        car25519(t39);
        for (j7 = 0; j7 < 2; j7++) {
          m17[0] = t39[0] - 65517;
          for (i49 = 1; i49 < 15; i49++) {
            m17[i49] = t39[i49] - 65535 - (m17[i49 - 1] >> 16 & 1);
            m17[i49 - 1] &= 65535;
          }
          m17[15] = t39[15] - 32767 - (m17[14] >> 16 & 1);
          b12 = m17[15] >> 16 & 1;
          m17[14] &= 65535;
          sel25519(t39, m17, 1 - b12);
        }
        for (i49 = 0; i49 < 16; i49++) {
          o34[2 * i49] = t39[i49] & 255;
          o34[2 * i49 + 1] = t39[i49] >> 8;
        }
      }
      function par25519(a26) {
        var d24 = new Uint8Array(32);
        pack25519(d24, a26);
        return d24[0] & 1;
      }
      function vn3(x11, xi, y14, yi, n27) {
        var i49, d24 = 0;
        for (i49 = 0; i49 < n27; i49++) d24 |= x11[xi + i49] ^ y14[yi + i49];
        return (1 & d24 - 1 >>> 8) - 1;
      }
      function crypto_verify_32(x11, xi, y14, yi) {
        return vn3(x11, xi, y14, yi, 32);
      }
      function neq25519(a26, b12) {
        var c16 = new Uint8Array(32), d24 = new Uint8Array(32);
        pack25519(c16, a26);
        pack25519(d24, b12);
        return crypto_verify_32(c16, 0, d24, 0);
      }
      function pow2523(o34, i49) {
        var c16 = gf();
        var a26;
        for (a26 = 0; a26 < 16; a26++) c16[a26] = i49[a26];
        for (a26 = 250; a26 >= 0; a26--) {
          S9(c16, c16);
          if (a26 !== 1) M5(c16, c16, i49);
        }
        for (a26 = 0; a26 < 16; a26++) o34[a26] = c16[a26];
      }
      function set25519(r30, a26) {
        var i49;
        for (i49 = 0; i49 < 16; i49++) r30[i49] = a26[i49] | 0;
      }
      function unpackneg(r30, p16) {
        var t39 = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r30[2], gf1);
        unpack25519(r30[1], p16);
        S9(num, r30[1]);
        M5(den, num, D11);
        Z5(num, num, r30[2]);
        A18(den, r30[2], den);
        S9(den2, den);
        S9(den4, den2);
        M5(den6, den4, den2);
        M5(t39, den6, num);
        M5(t39, t39, den);
        pow2523(t39, t39);
        M5(t39, t39, num);
        M5(t39, t39, den);
        M5(t39, t39, den);
        M5(r30[0], t39, den);
        S9(chk, r30[0]);
        M5(chk, chk, den);
        if (neq25519(chk, num)) M5(r30[0], r30[0], I7);
        S9(chk, r30[0]);
        M5(chk, chk, den);
        if (neq25519(chk, num)) return -1;
        if (par25519(r30[0]) === p16[31] >> 7) Z5(r30[0], gf0, r30[0]);
        M5(r30[3], r30[0], r30[1]);
        return 0;
      }
      function convertPublicKey(pk) {
        var z9 = new Uint8Array(32), q6 = [gf(), gf(), gf(), gf()], a26 = gf(), b12 = gf();
        if (unpackneg(q6, pk)) return null;
        var y14 = q6[1];
        A18(a26, gf1, y14);
        Z5(b12, gf1, y14);
        inv25519(b12, b12);
        M5(a26, a26, b12);
        pack25519(z9, a26);
        return z9;
      }
      function convertSecretKey(sk) {
        var d24 = new Uint8Array(64), o34 = new Uint8Array(32), i49;
        nacl4.lowlevel.crypto_hash(d24, sk, 32);
        d24[0] &= 248;
        d24[31] &= 127;
        d24[31] |= 64;
        for (i49 = 0; i49 < 32; i49++) o34[i49] = d24[i49];
        for (i49 = 0; i49 < 64; i49++) d24[i49] = 0;
        return o34;
      }
      function convertKeyPair(edKeyPair) {
        var publicKey = convertPublicKey(edKeyPair.publicKey);
        if (!publicKey) return null;
        return {
          publicKey,
          secretKey: convertSecretKey(edKeyPair.secretKey)
        };
      }
      return {
        convertPublicKey,
        convertSecretKey,
        convertKeyPair
      };
    });
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/dist/index.mjs
var import_eventemitter34 = __toESM(require_eventemitter3(), 1);

// node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-PFWJQYHN.mjs
var n5 = "aptos:signAndSubmitTransaction";

// node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-BIF2XL2R.mjs
var e2 = "aptos:signMessage";

// node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-K5ZY2NHG.mjs
var n6 = "aptos:signTransaction";

// node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-OYMA2PWW.mjs
var o4 = "aptos:connect";

// node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-7KTK52MK.mjs
var o5 = "aptos:disconnect";

// node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-EKJ7Y4LP.mjs
var t5 = "aptos:account";

// node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-FTTDX4QF.mjs
var t6 = "aptos:network";

// node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-MNFE4AOY.mjs
var n7 = "aptos:onAccountChange";

// node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-MJDSOKP4.mjs
var e3 = "aptos:onNetworkChange";

// node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-FFGPGN2W.mjs
var d2 = class o6 extends B {
  constructor({ address: e10, publicKey: n27, ansName: t39 }) {
    super();
    this.address = c.from(e10), this.publicKey = n27, this.ansName = t39;
  }
  serialize(e10) {
    if (this.address.serialize(e10), this.publicKey instanceof m) e10.serializeU32AsUleb128(f3.Ed25519);
    else if (this.publicKey instanceof d) e10.serializeU32AsUleb128(f3.MultiEd25519);
    else if (this.publicKey instanceof f) e10.serializeU32AsUleb128(f3.SingleKey);
    else if (this.publicKey instanceof f2) e10.serializeU32AsUleb128(f3.MultiKey);
    else throw new Error("Unsupported public key");
    this.publicKey.serialize(e10), e10.serializeStr(this.ansName ?? "");
  }
  static deserialize(e10) {
    let n27 = c.deserialize(e10), t39 = e10.deserializeUleb128AsU32(), s14;
    switch (t39) {
      case f3.Ed25519:
        s14 = m.deserialize(e10);
        break;
      case f3.MultiEd25519:
        s14 = d.deserialize(e10);
        break;
      case f3.SingleKey:
        s14 = f.deserialize(e10);
        break;
      case f3.MultiKey:
        s14 = f2.deserialize(e10);
        break;
      default:
        throw new Error(`Unknown variant index for WrappedPublicKey: ${t39}`);
    }
    let b12 = e10.deserializeStr() || void 0;
    return new o6({ address: n27, publicKey: s14, ansName: b12 });
  }
};

// node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-3XZSACFC.mjs
var t7 = "aptos:devnet";
var o7 = "aptos:testnet";
var A2 = "aptos:localnet";
var T = "aptos:mainnet";
var e4 = [t7, o7, A2, T];

// node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-7OMCNXQ7.mjs
var n8 = ["aptos:account", "aptos:connect", "aptos:disconnect", "aptos:network", "aptos:onAccountChange", "aptos:onNetworkChange", "aptos:signMessage", "aptos:signTransaction"];
function i2(t39, e10 = []) {
  return [...n8, ...e10].every((s14) => s14 in t39.features);
}
function d3() {
  let { get: t39, on: e10 } = getWallets(), s14 = t39(), a26 = [];
  return s14.map((l20) => {
    i2(l20) && a26.push(l20);
  }), { aptosWallets: a26, on: e10 };
}

// node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-KFHNVTDM.mjs
var n9 = ((e10) => (e10[e10.Unauthorized = 4100] = "Unauthorized", e10[e10.InternalError = -30001] = "InternalError", e10))(n9 || {});
var t8 = Object.freeze({ 4100: { status: "Unauthorized", message: "The requested method and/or account has not been authorized by the user." }, [-30001]: { status: "Internal error", message: "Something went wrong within the wallet." } });
var r3 = class s extends Error {
  constructor(e10, o34) {
    var _a, _b;
    super(o34 ?? ((_a = t8[e10]) == null ? void 0 : _a.message) ?? "Unknown error occurred");
    this.code = e10, this.status = ((_b = t8[e10]) == null ? void 0 : _b.status) ?? "Unknown error", this.name = "AptosWalletError", Object.setPrototypeOf(this, s.prototype);
  }
};

// node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-QHCUHEWC.mjs
var r4 = ((e10) => (e10.APPROVED = "Approved", e10.REJECTED = "Rejected", e10))(r4 || {});

// node_modules/@identity-connect/crypto/dist/index.mjs
var import_tweetnacl = __toESM(require_nacl_fast(), 1);
var import_ed2curve = __toESM(require_ed2curve(), 1);
var import_tweetnacl2 = __toESM(require_nacl_fast(), 1);

// node_modules/@aptos-connect/wallet-api/dist/index.mjs
function base64ToBytes(base64) {
  const binaryString = atob(base64);
  return Uint8Array.from(binaryString, (m17) => m17.charCodeAt(0));
}
function bytesToBase64(bytes) {
  const binaryString = String.fromCharCode(...bytes);
  return btoa(binaryString);
}
function chainIdToNetwork(chainId) {
  switch (chainId) {
    case r2.mainnet:
      return e.MAINNET;
    case r2.testnet:
      return e.TESTNET;
    default:
      return e.DEVNET;
  }
}
function isSupportedNetwork(network) {
  return [e.MAINNET, e.TESTNET, e.DEVNET].includes(network);
}
function serializeAccountAuthenticatorInput(serializer, value) {
  serializer.serialize(value.address);
  serializer.serialize(value.authenticator);
}
function deserializeAccountAuthenticatorInput(deserializer) {
  const address = deserializer.deserialize(c);
  const authenticator = deserializer.deserialize(r);
  return { address, authenticator };
}
function serializePublicKey(serializer, value) {
  if (value instanceof m) {
    serializer.serializeU32AsUleb128(f3.Ed25519);
  } else if (value instanceof d) {
    serializer.serializeU32AsUleb128(f3.MultiEd25519);
  } else if (value instanceof f) {
    serializer.serializeU32AsUleb128(f3.SingleKey);
  } else if (value instanceof f2) {
    serializer.serializeU32AsUleb128(f3.MultiKey);
  } else {
    throw new Error("Unexpected public key type");
  }
  serializer.serialize(value);
}
function deserializePublicKey(deserializer) {
  const signingScheme = deserializer.deserializeUleb128AsU32();
  switch (signingScheme) {
    case f3.Ed25519:
      return deserializer.deserialize(m);
    case f3.MultiEd25519:
      return deserializer.deserialize(d);
    case f3.SingleKey:
      return deserializer.deserialize(f);
    case f3.MultiKey:
      return deserializer.deserialize(f2);
    default:
      throw new Error(`Unknown signing scheme: ${signingScheme}`);
  }
}
function serializeAccountInfo(serializer, value) {
  serializer.serialize(value.address);
  serializePublicKey(serializer, value.publicKey);
  serializer.serializeStr(value.name ?? "");
}
function deserializeAccountInfo(deserializer) {
  const address = deserializer.deserialize(c);
  const publicKey = deserializePublicKey(deserializer);
  const name = deserializer.deserializeStr();
  return {
    address,
    publicKey,
    ...name.length > 0 ? { name } : void 0
  };
}
function serializeAccountInput(serializer, value) {
  serializer.serialize(value.address);
  serializer.serializeBool(value.publicKey !== void 0);
  if (value.publicKey) {
    serializePublicKey(serializer, value.publicKey);
  }
}
function deserializeAccountInput(deserializer) {
  const address = deserializer.deserialize(c);
  const hasPublicKey = deserializer.deserializeBool();
  const publicKey = hasPublicKey ? deserializePublicKey(deserializer) : void 0;
  return { address, publicKey };
}
function serializeDappInfo(serializer, value) {
  serializer.serializeStr(value.domain);
  serializer.serializeStr(value.name);
  serializer.serializeBool(value.imageURI !== void 0);
  if (value.imageURI !== void 0) {
    serializer.serializeStr(value.imageURI);
  }
}
function deserializeDappInfo(deserializer) {
  const domain = deserializer.deserializeStr();
  const name = deserializer.deserializeStr();
  const hasImageUri = deserializer.deserializeBool();
  const imageURI = hasImageUri ? deserializer.deserializeStr() : void 0;
  return { domain, imageURI, name };
}
var EntryFunctionArgumentVariant = ((EntryFunctionArgumentVariant2) => {
  EntryFunctionArgumentVariant2[EntryFunctionArgumentVariant2["Undefined"] = 0] = "Undefined";
  EntryFunctionArgumentVariant2[EntryFunctionArgumentVariant2["Array"] = 1] = "Array";
  EntryFunctionArgumentVariant2[EntryFunctionArgumentVariant2["String"] = 2] = "String";
  EntryFunctionArgumentVariant2[EntryFunctionArgumentVariant2["Uint8Array"] = 3] = "Uint8Array";
  EntryFunctionArgumentVariant2[EntryFunctionArgumentVariant2["AccountAddress"] = 4] = "AccountAddress";
  EntryFunctionArgumentVariant2[EntryFunctionArgumentVariant2["FixedBytes"] = 5] = "FixedBytes";
  return EntryFunctionArgumentVariant2;
})(EntryFunctionArgumentVariant || {});
function serializeEntryFunctionArgument(serializer, argument) {
  if (argument === void 0 || argument === null) {
    serializer.serializeU32AsUleb128(
      0
      /* Undefined */
    );
    return;
  }
  if (Array.isArray(argument)) {
    serializer.serializeU32AsUleb128(
      1
      /* Array */
    );
    serializer.serializeU32AsUleb128(argument.length);
    for (const subArgument of argument) {
      serializeEntryFunctionArgument(serializer, subArgument);
    }
    return;
  }
  if (typeof argument === "string" || typeof argument === "number" || typeof argument === "boolean" || typeof argument === "bigint") {
    serializer.serializeU32AsUleb128(
      2
      /* String */
    );
    serializer.serializeStr(argument.toString());
    return;
  }
  if (argument instanceof Uint8Array) {
    serializer.serializeU32AsUleb128(
      3
      /* Uint8Array */
    );
    serializer.serializeBytes(argument);
    return;
  }
  if (argument instanceof ArrayBuffer) {
    serializer.serializeU32AsUleb128(
      3
      /* Uint8Array */
    );
    serializer.serializeBytes(new Uint8Array(argument));
    return;
  }
  if ("values" in argument) {
    serializer.serializeU32AsUleb128(
      1
      /* Array */
    );
    serializer.serializeU32AsUleb128(argument.values.length);
    for (const subArgument of argument.values) {
      serializeEntryFunctionArgument(serializer, subArgument);
    }
    return;
  }
  if ("data" in argument) {
    serializer.serializeU32AsUleb128(
      4
      /* AccountAddress */
    );
    serializer.serialize(argument);
    return;
  }
  if (argument.value === void 0) {
    serializer.serializeU32AsUleb128(
      0
      /* Undefined */
    );
    serializer.serialize(argument);
    return;
  }
  if (argument.value instanceof Uint8Array) {
    serializer.serializeU32AsUleb128(
      5
      /* FixedBytes */
    );
    serializer.serializeBytes(argument.value);
    return;
  }
  serializer.serializeU32AsUleb128(
    2
    /* String */
  );
  serializer.serializeStr(argument.value.toString());
}
function deserializeEntryFunctionArgument(deserializer) {
  const variant = deserializer.deserializeUleb128AsU32();
  switch (variant) {
    case 0: {
      return void 0;
    }
    case 1: {
      const length = deserializer.deserializeUleb128AsU32();
      const args = [];
      for (let i49 = 0; i49 < length; i49 += 1) {
        const argument = deserializeEntryFunctionArgument(deserializer);
        args.push(argument);
      }
      return args;
    }
    case 3: {
      return deserializer.deserializeBytes();
    }
    case 4: {
      return deserializer.deserialize(c);
    }
    case 2: {
      return deserializer.deserializeStr();
    }
    case 5: {
      const bytes = deserializer.deserializeBytes();
      return new t2(bytes);
    }
    default: {
      throw new Error("Unexpected variant");
    }
  }
}
function serializeSignature(serializer, value) {
  if (value instanceof c2) {
    serializer.serializeU32AsUleb128(f3.Ed25519);
  } else if (value instanceof y) {
    serializer.serializeU32AsUleb128(f3.MultiEd25519);
  } else if (value instanceof u) {
    serializer.serializeU32AsUleb128(f3.SingleKey);
  } else {
    throw new Error("Unexpected signature type");
  }
  serializer.serialize(value);
}
function deserializeSignature(deserializer) {
  const signingScheme = deserializer.deserializeUleb128AsU32();
  switch (signingScheme) {
    case f3.Ed25519:
      return deserializer.deserialize(c2);
    case f3.MultiEd25519:
      return deserializer.deserialize(y);
    case f3.SingleKey:
      return deserializer.deserialize(u);
    default:
      throw new Error(`Unknown signing scheme: ${signingScheme}`);
  }
}
var TransactionPayloadInputVariant = ((TransactionPayloadInputVariant2) => {
  TransactionPayloadInputVariant2[TransactionPayloadInputVariant2["EntryFunction"] = 0] = "EntryFunction";
  TransactionPayloadInputVariant2[TransactionPayloadInputVariant2["Script"] = 1] = "Script";
  TransactionPayloadInputVariant2[TransactionPayloadInputVariant2["Multisig"] = 2] = "Multisig";
  return TransactionPayloadInputVariant2;
})(TransactionPayloadInputVariant || {});
function serializeTypeArguments(serializer, typeArguments) {
  serializer.serializeU32AsUleb128(typeArguments.length);
  for (const typeArgument of typeArguments) {
    const typeTag = typeof typeArgument === "string" ? j(typeArgument, { allowGenerics: true }) : typeArgument;
    serializer.serialize(typeTag);
  }
}
function deserializeTypeArguments(deserializer) {
  const typeArguments = [];
  const typeArgumentsLength = deserializer.deserializeUleb128AsU32();
  for (let i49 = 0; i49 < typeArgumentsLength; i49 += 1) {
    const typeTag = deserializer.deserialize(t);
    typeArguments.push(typeTag);
  }
  return typeArguments;
}
function serializeEntryFunctionArguments(serializer, functionArguments) {
  serializer.serializeU32AsUleb128(functionArguments.length);
  for (const functionArgument of functionArguments) {
    serializeEntryFunctionArgument(serializer, functionArgument);
  }
}
function deserializeEntryFunctionArguments(deserializer) {
  const functionArgumentsLength = deserializer.deserializeUleb128AsU32();
  const functionArguments = [];
  for (let i49 = 0; i49 < functionArgumentsLength; i49 += 1) {
    const functionArgument = deserializeEntryFunctionArgument(deserializer);
    functionArguments.push(functionArgument);
  }
  return functionArguments;
}
function serializeTransactionPayloadInput(serializer, value) {
  if ("multisigAddress" in value) {
    serializer.serializeU32AsUleb128(
      2
      /* Multisig */
    );
    serializer.serializeStr(value.function);
    serializeEntryFunctionArguments(serializer, value.functionArguments);
    serializeTypeArguments(serializer, value.typeArguments ?? []);
    const multisigAddress = c.from(value.multisigAddress);
    serializer.serialize(multisigAddress);
  } else if ("function" in value) {
    serializer.serializeU32AsUleb128(
      0
      /* EntryFunction */
    );
    serializer.serializeStr(value.function);
    serializeEntryFunctionArguments(serializer, value.functionArguments);
    serializeTypeArguments(serializer, value.typeArguments ?? []);
  } else {
    serializer.serializeU32AsUleb128(
      1
      /* Script */
    );
    const bytecode = i.fromHexInput(value.bytecode);
    serializer.serializeBytes(bytecode.toUint8Array());
    serializer.serializeU32AsUleb128(value.functionArguments.length);
    for (const argument of value.functionArguments) {
      argument.serializeForScriptFunction(serializer);
    }
    serializeTypeArguments(serializer, value.typeArguments ?? []);
  }
}
function deserializeTransactionPayloadInput(deserializer) {
  const variant = deserializer.deserializeUleb128AsU32();
  switch (variant) {
    case 2: {
      const functionId = deserializer.deserializeStr();
      const functionArguments = deserializeEntryFunctionArguments(deserializer);
      const typeArguments = deserializeTypeArguments(deserializer);
      const multisigAddress = deserializer.deserialize(c);
      return {
        function: functionId,
        functionArguments,
        multisigAddress,
        typeArguments
      };
    }
    case 0: {
      const functionId = deserializer.deserializeStr();
      const functionArguments = deserializeEntryFunctionArguments(deserializer);
      const typeArguments = deserializeTypeArguments(deserializer);
      return {
        function: functionId,
        functionArguments,
        typeArguments
      };
    }
    case 1: {
      const bytecode = deserializer.deserializeBytes();
      const functionArgumentsLength = deserializer.deserializeUleb128AsU32();
      const functionArguments = [];
      for (let i49 = 0; i49 < functionArgumentsLength; i49 += 1) {
        const argument = D(deserializer);
        functionArguments.push(argument);
      }
      const typeArguments = deserializeTypeArguments(deserializer);
      return {
        bytecode,
        functionArguments,
        typeArguments
      };
    }
    default: {
      throw new Error("Unexpected variant");
    }
  }
}
function serializeWalletRequest({
  dappInfo,
  name,
  version: version2
}) {
  const serializer = new n();
  serializeDappInfo(serializer, dappInfo);
  const data = serializer.toUint8Array();
  return { data, name, version: version2 };
}
function deserializeWalletRequest({
  data,
  name,
  version: version2
}) {
  const deserializer = new n2(data);
  const dappInfo = deserializeDappInfo(deserializer);
  return { dappInfo, name, version: version2 };
}
function serializeWalletRequestWithArgs({ args, dappInfo, name, version: version2 }, serializeArgsFn) {
  const serializer = new n();
  serializeDappInfo(serializer, dappInfo);
  serializeArgsFn(serializer, args);
  const data = serializer.toUint8Array();
  return { data, name, version: version2 };
}
function deserializeWalletRequestWithArgs({ data, name, version: version2 }, deserializeArgsFn) {
  const deserializer = new n2(data);
  const dappInfo = deserializeDappInfo(deserializer);
  const args = deserializeArgsFn(deserializer);
  return { args, dappInfo, name, version: version2 };
}
var ConnectRequest;
((ConnectRequest2) => {
  ConnectRequest2.name = "connect";
  ConnectRequest2.supportedVersions = [1, 2];
  ConnectRequest2.currentVersion = 2;
  function serializeArgs(serializer, value) {
    serializer.serializeOptionStr(value.dappId);
    serializer.serializeOptionStr(value.dappEd25519PublicKeyB64);
  }
  ConnectRequest2.serializeArgs = serializeArgs;
  function deserializeArgs(deserializer, version2) {
    if (version2 === 1) {
      return {};
    }
    const dappId = deserializer.deserializeOptionStr();
    const dappEd25519PublicKeyB64 = deserializer.deserializeOptionStr();
    return { dappEd25519PublicKeyB64, dappId };
  }
  ConnectRequest2.deserializeArgs = deserializeArgs;
  function serialize(dappInfo, args = {}) {
    return serializeWalletRequestWithArgs({ args, dappInfo, name: ConnectRequest2.name, version: ConnectRequest2.currentVersion }, serializeArgs);
  }
  ConnectRequest2.serialize = serialize;
  function deserialize(request2) {
    return deserializeWalletRequestWithArgs(request2, (d24) => deserializeArgs(d24, request2.version));
  }
  ConnectRequest2.deserialize = deserialize;
  function isSerialized(request2) {
    return request2.name === ConnectRequest2.name && ConnectRequest2.supportedVersions.includes(request2.version);
  }
  ConnectRequest2.isSerialized = isSerialized;
})(ConnectRequest || (ConnectRequest = {}));
function makeUserApproval(args) {
  return { args, status: "approved" };
}
function makeUserResponseSerializeFn(serializeArgs) {
  return (serializer, value) => {
    serializer.serializeBool(value.status === "approved");
    if (value.status === "approved") {
      serializeArgs(serializer, value.args);
    }
  };
}
function makeUserResponseDeserializeFn(deserializeArgs) {
  return (deserializer) => {
    const isApproved = deserializer.deserializeBool();
    return isApproved ? { args: deserializeArgs(deserializer), status: "approved" } : { status: "dismissed" };
  };
}
function serializeWalletResponse(args, serializeFn) {
  const serializer = new n();
  serializeFn(serializer, args);
  const data = serializer.toUint8Array();
  return { data };
}
function deserializeWalletResponse({ data }, deserializeFn) {
  const deserializer = new n2(data);
  const args = deserializeFn(deserializer);
  return { args };
}
var ConnectResponse;
((ConnectResponse2) => {
  ConnectResponse2.supportedVersions = [1, 2];
  ConnectResponse2.currentVersion = 2;
  function serializeApprovalArgsV1(serializer, value) {
    serializeAccountInfo(serializer, value.account);
  }
  function serializeApprovalArgs(serializer, value) {
    serializeAccountInfo(serializer, value.account);
    serializer.serializeOptionStr(value.pairing !== void 0 ? JSON.stringify(value.pairing) : void 0);
  }
  function deserializeApprovalArgs(deserializer) {
    const account = deserializeAccountInfo(deserializer);
    const serializedPairing = deserializer.deserializeOptionStr();
    const pairing = serializedPairing !== void 0 ? JSON.parse(serializedPairing) : void 0;
    return { account, pairing };
  }
  const serializeArgsV1 = makeUserResponseSerializeFn(serializeApprovalArgsV1);
  const serializeArgs = makeUserResponseSerializeFn(serializeApprovalArgs);
  const deserializeArgs = makeUserResponseDeserializeFn(deserializeApprovalArgs);
  function serialize(args, version2 = ConnectResponse2.currentVersion) {
    return serializeWalletResponse(args, version2 === 1 ? serializeArgsV1 : serializeArgs);
  }
  ConnectResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, deserializeArgs);
  }
  ConnectResponse2.deserialize = deserialize;
})(ConnectResponse || (ConnectResponse = {}));
var DisconnectRequest;
((DisconnectRequest2) => {
  DisconnectRequest2.name = "disconnect";
  DisconnectRequest2.currentVersion = 1;
  function serialize(dappInfo) {
    return serializeWalletRequest({ dappInfo, name: DisconnectRequest2.name, version: DisconnectRequest2.currentVersion });
  }
  DisconnectRequest2.serialize = serialize;
  function deserialize(request2) {
    return deserializeWalletRequest(request2);
  }
  DisconnectRequest2.deserialize = deserialize;
  function isSerialized(request2) {
    return request2.name === DisconnectRequest2.name && request2.version === DisconnectRequest2.currentVersion;
  }
  DisconnectRequest2.isSerialized = isSerialized;
})(DisconnectRequest || (DisconnectRequest = {}));
var DisconnectResponse;
((DisconnectResponse2) => {
  function serialize(args) {
    return serializeWalletResponse(args, () => {
    });
  }
  DisconnectResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, () => ({}));
  }
  DisconnectResponse2.deserialize = deserialize;
})(DisconnectResponse || (DisconnectResponse = {}));
var GetConnectedAccountsRequest;
((GetConnectedAccountsRequest2) => {
  GetConnectedAccountsRequest2.name = "getConnectedAccounts";
  GetConnectedAccountsRequest2.currentVersion = 1;
  function serialize(dappInfo) {
    return serializeWalletRequest({ dappInfo, name: GetConnectedAccountsRequest2.name, version: GetConnectedAccountsRequest2.currentVersion });
  }
  GetConnectedAccountsRequest2.serialize = serialize;
  function deserialize(request2) {
    return deserializeWalletRequest(request2);
  }
  GetConnectedAccountsRequest2.deserialize = deserialize;
  function isSerialized(request2) {
    return request2.name === GetConnectedAccountsRequest2.name && request2.version === GetConnectedAccountsRequest2.currentVersion;
  }
  GetConnectedAccountsRequest2.isSerialized = isSerialized;
})(GetConnectedAccountsRequest || (GetConnectedAccountsRequest = {}));
var GetConnectedAccountsResponse;
((GetConnectedAccountsResponse2) => {
  function serializeArgs(serializer, args) {
    serializer.serializeU32AsUleb128(args.length);
    for (const account of args) {
      serializeAccountInfo(serializer, account);
    }
  }
  function deserializeArgs(deserializer) {
    const length = deserializer.deserializeUleb128AsU32();
    const accounts = [];
    for (let i49 = 0; i49 < length; i49 += 1) {
      accounts.push(deserializeAccountInfo(deserializer));
    }
    return accounts;
  }
  function serialize(args) {
    return serializeWalletResponse(args, serializeArgs);
  }
  GetConnectedAccountsResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, deserializeArgs);
  }
  GetConnectedAccountsResponse2.deserialize = deserialize;
})(GetConnectedAccountsResponse || (GetConnectedAccountsResponse = {}));
var IsConnectedRequest;
((IsConnectedRequest2) => {
  IsConnectedRequest2.name = "isConnected";
  IsConnectedRequest2.currentVersion = 1;
  function serialize(dappInfo) {
    return serializeWalletRequest({ dappInfo, name: IsConnectedRequest2.name, version: IsConnectedRequest2.currentVersion });
  }
  IsConnectedRequest2.serialize = serialize;
  function deserialize(request2) {
    return deserializeWalletRequest(request2);
  }
  IsConnectedRequest2.deserialize = deserialize;
  function isSerialized(request2) {
    return request2.name === IsConnectedRequest2.name && request2.version === IsConnectedRequest2.currentVersion;
  }
  IsConnectedRequest2.isSerialized = isSerialized;
})(IsConnectedRequest || (IsConnectedRequest = {}));
var IsConnectedResponse;
((IsConnectedResponse2) => {
  function serializeArgs(serializer, value) {
    serializer.serializeBool(value);
  }
  function deserializeArgs(deserializer) {
    return deserializer.deserializeBool();
  }
  function serialize(args) {
    return serializeWalletResponse(args, serializeArgs);
  }
  IsConnectedResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, deserializeArgs);
  }
  IsConnectedResponse2.deserialize = deserialize;
})(IsConnectedResponse || (IsConnectedResponse = {}));
var SignAndSubmitTransactionRequest;
((SignAndSubmitTransactionRequest2) => {
  SignAndSubmitTransactionRequest2.name = "signAndSubmitTransaction";
  SignAndSubmitTransactionRequest2.supportedVersions = [1, 2, 3];
  SignAndSubmitTransactionRequest2.currentVersion = 3;
  function serializeArgs(serializer, value) {
    if (value.network !== void 0 && !isSupportedNetwork(value.network)) {
      throw new Error(`Unsupported network '${value.network}'`);
    }
    serializer.serializeBool(value.signerAddress !== void 0);
    if (value.signerAddress !== void 0) {
      serializer.serialize(value.signerAddress);
    }
    serializer.serializeOptionStr(value.network);
    if ("bcsToBytes" in value.payload) {
      serializer.serializeBool(true);
      serializer.serialize(value.payload);
    } else {
      serializer.serializeBool(false);
      serializeTransactionPayloadInput(serializer, value.payload);
    }
    serializer.serializeU64(value.expirationTimestamp ?? 0);
    serializer.serializeU32AsUleb128(value.gasUnitPrice ?? 0);
    serializer.serializeU32AsUleb128(value.maxGasAmount ?? 0);
    serializer.serializeU32AsUleb128(value.feePayer ? 1 : 0);
    if (value.feePayer) {
      serializeAccountAuthenticatorInput(serializer, value.feePayer);
    }
  }
  SignAndSubmitTransactionRequest2.serializeArgs = serializeArgs;
  function deserializeArgs(deserializer, version2) {
    const hasSignerAddress = version2 >= 3 && deserializer.deserializeBool();
    const signerAddress = hasSignerAddress ? deserializer.deserialize(c) : void 0;
    const network = version2 === 1 ? deserializer.deserializeStr() : deserializer.deserializeOptionStr();
    if (network !== void 0 && !isSupportedNetwork(network)) {
      throw new Error(`Unsupported network '${network}'`);
    }
    const isPayloadBcsSerializable = version2 === 1 || deserializer.deserializeBool();
    const payload = isPayloadBcsSerializable ? deserializer.deserialize(a) : deserializeTransactionPayloadInput(deserializer);
    const expirationTimestamp = Number(deserializer.deserializeU64());
    const gasUnitPrice = deserializer.deserializeUleb128AsU32();
    const maxGasAmount = deserializer.deserializeUleb128AsU32();
    const hasFeePayer = deserializer.deserializeUleb128AsU32();
    const feePayer = hasFeePayer ? deserializeAccountAuthenticatorInput(deserializer) : void 0;
    return {
      expirationTimestamp: expirationTimestamp > 0 ? expirationTimestamp : void 0,
      feePayer,
      gasUnitPrice: gasUnitPrice > 0 ? gasUnitPrice : void 0,
      maxGasAmount: maxGasAmount > 0 ? maxGasAmount : void 0,
      network,
      payload,
      signerAddress
    };
  }
  SignAndSubmitTransactionRequest2.deserializeArgs = deserializeArgs;
  function serialize(dappInfo, args) {
    const request2 = { args, dappInfo, name: SignAndSubmitTransactionRequest2.name, version: SignAndSubmitTransactionRequest2.currentVersion };
    return serializeWalletRequestWithArgs(request2, serializeArgs);
  }
  SignAndSubmitTransactionRequest2.serialize = serialize;
  function deserialize(serializedRequest) {
    return deserializeWalletRequestWithArgs(
      serializedRequest,
      (deserializer) => deserializeArgs(deserializer, serializedRequest.version)
    );
  }
  SignAndSubmitTransactionRequest2.deserialize = deserialize;
  function isSerialized(request2) {
    return request2.name === SignAndSubmitTransactionRequest2.name && SignAndSubmitTransactionRequest2.supportedVersions.includes(request2.version);
  }
  SignAndSubmitTransactionRequest2.isSerialized = isSerialized;
})(SignAndSubmitTransactionRequest || (SignAndSubmitTransactionRequest = {}));
var SignAndSubmitTransactionResponse;
((SignAndSubmitTransactionResponse2) => {
  function serializeApprovalArgs(serializer, value) {
    serializer.serializeStr(value.txnHash);
  }
  function deserializeApprovalArgs(deserializer) {
    const txnHash = deserializer.deserializeStr();
    return { txnHash };
  }
  const serializeArgs = makeUserResponseSerializeFn(serializeApprovalArgs);
  const deserializeArgs = makeUserResponseDeserializeFn(deserializeApprovalArgs);
  function serialize(args) {
    return serializeWalletResponse(args, serializeArgs);
  }
  SignAndSubmitTransactionResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, deserializeArgs);
  }
  SignAndSubmitTransactionResponse2.deserialize = deserialize;
})(SignAndSubmitTransactionResponse || (SignAndSubmitTransactionResponse = {}));
var SignMessageRequest;
((SignMessageRequest2) => {
  SignMessageRequest2.name = "signMessage";
  SignMessageRequest2.supportedVersions = [1, 2];
  SignMessageRequest2.currentVersion = 2;
  function serializeArgs(serializer, value) {
    serializer.serializeBool(value.signerAddress !== void 0);
    if (value.signerAddress !== void 0) {
      serializer.serialize(value.signerAddress);
    }
    serializer.serializeU8(value.chainId);
    serializer.serializeBytes(value.nonce);
    serializer.serializeBytes(value.message);
  }
  function deserializeArgs(deserializer, version2) {
    const hasSignerAddress = version2 >= 2 && deserializer.deserializeBool();
    const signerAddress = hasSignerAddress ? deserializer.deserialize(c) : void 0;
    const chainId = deserializer.deserializeU8();
    const nonce = deserializer.deserializeBytes();
    const message = deserializer.deserializeBytes();
    return { chainId, message, nonce, signerAddress };
  }
  function serialize(dappInfo, args) {
    const request2 = { args, dappInfo, name: SignMessageRequest2.name, version: SignMessageRequest2.currentVersion };
    return serializeWalletRequestWithArgs(request2, serializeArgs);
  }
  SignMessageRequest2.serialize = serialize;
  function deserialize(serializedRequest) {
    return deserializeWalletRequestWithArgs(serializedRequest, (d24) => deserializeArgs(d24, serializedRequest.version));
  }
  SignMessageRequest2.deserialize = deserialize;
  function isSerialized(request2) {
    return request2.name === SignMessageRequest2.name && request2.version === SignMessageRequest2.currentVersion;
  }
  SignMessageRequest2.isSerialized = isSerialized;
})(SignMessageRequest || (SignMessageRequest = {}));
var SignMessageResponse;
((SignMessageResponse2) => {
  function serializeApprovalArgs(serializer, value) {
    serializer.serializeStr(value.fullMessage);
    serializeSignature(serializer, value.signature);
  }
  function deserializeApprovalArgs(deserializer) {
    const fullMessage = deserializer.deserializeStr();
    const signature = deserializeSignature(deserializer);
    return { fullMessage, signature };
  }
  const serializeArgs = makeUserResponseSerializeFn(serializeApprovalArgs);
  const deserializeArgs = makeUserResponseDeserializeFn(deserializeApprovalArgs);
  function serialize(args) {
    return serializeWalletResponse(args, serializeArgs);
  }
  SignMessageResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, deserializeArgs);
  }
  SignMessageResponse2.deserialize = deserialize;
})(SignMessageResponse || (SignMessageResponse = {}));
var SignTransactionRequest;
((SignTransactionRequest2) => {
  SignTransactionRequest2.name = "signTransaction";
  SignTransactionRequest2.supportedVersions = [1, 2, 3];
  SignTransactionRequest2.currentVersion = 3;
  function normalizeArgs(args) {
    const { feePayer, secondarySigners, senderPublicKey, signerAddress, transaction } = args;
    const sender = {
      address: transaction.sender,
      publicKey: senderPublicKey
    };
    const network = chainIdToNetwork(args.transaction.chain_id.chainId);
    return {
      expirationTimestamp: Number(transaction.expiration_timestamp_secs),
      feePayer,
      gasUnitPrice: Number(transaction.gas_unit_price),
      maxGasAmount: Number(transaction.max_gas_amount),
      network,
      payload: transaction.payload,
      secondarySigners,
      sender,
      signerAddress
    };
  }
  SignTransactionRequest2.normalizeArgs = normalizeArgs;
  function serializeArgs(serializer, value) {
    if (value.network !== void 0 && !isSupportedNetwork(value.network)) {
      throw new Error(`Unsupported network '${value.network}'`);
    }
    serializer.serializeBool(value.signerAddress !== void 0);
    if (value.signerAddress !== void 0) {
      serializer.serialize(value.signerAddress);
    }
    serializer.serializeOptionStr(value.network);
    serializer.serializeBool(value.sender !== void 0);
    if (value.sender !== void 0) {
      serializeAccountInput(serializer, value.sender);
    }
    serializer.serialize(value.payload);
    serializer.serializeU32AsUleb128(value.expirationSecondsFromNow ?? 0);
    serializer.serializeU64(value.expirationTimestamp ?? 0);
    serializer.serializeU32AsUleb128(value.gasUnitPrice ?? 0);
    serializer.serializeU32AsUleb128(value.maxGasAmount ?? 0);
    serializer.serializeBool(value.feePayer !== void 0);
    if (value.feePayer !== void 0) {
      serializeAccountInput(serializer, value.feePayer);
    }
    const secondarySigners = value.secondarySigners ?? [];
    serializer.serializeU32AsUleb128(secondarySigners.length);
    for (const signer of secondarySigners) {
      serializeAccountInput(serializer, signer);
    }
  }
  function deserializeArgs(deserializer, version2) {
    const hasSignerAddress = version2 >= 3 && deserializer.deserializeBool();
    const signerAddress = hasSignerAddress ? deserializer.deserialize(c) : void 0;
    const network = version2 === 1 ? deserializer.deserializeStr() : deserializer.deserializeOptionStr();
    if (network !== void 0 && !isSupportedNetwork(network)) {
      throw new Error(`Unsupported network '${network}'`);
    }
    const hasSender = deserializer.deserializeBool();
    const sender = hasSender ? deserializeAccountInput(deserializer) : void 0;
    const payload = deserializer.deserialize(a);
    const expirationSecondsFromNow = deserializer.deserializeUleb128AsU32();
    const expirationTimestamp = Number(deserializer.deserializeU64());
    const gasUnitPrice = deserializer.deserializeUleb128AsU32();
    const maxGasAmount = deserializer.deserializeUleb128AsU32();
    const hasFeePayer = deserializer.deserializeBool();
    const feePayer = hasFeePayer ? deserializeAccountInput(deserializer) : void 0;
    const secondarySignersLength = deserializer.deserializeUleb128AsU32();
    const secondarySigners = [];
    for (let i49 = 0; i49 < secondarySignersLength; i49 += 1) {
      secondarySigners.push(deserializeAccountInput(deserializer));
    }
    return {
      expirationSecondsFromNow: expirationSecondsFromNow > 0 ? expirationSecondsFromNow : void 0,
      expirationTimestamp: expirationTimestamp > 0 ? expirationTimestamp : void 0,
      feePayer,
      gasUnitPrice: gasUnitPrice > 0 ? gasUnitPrice : void 0,
      maxGasAmount: maxGasAmount > 0 ? maxGasAmount : void 0,
      network,
      payload,
      secondarySigners,
      sender,
      signerAddress
    };
  }
  function serialize(dappInfo, args) {
    const request2 = { args, dappInfo, name: SignTransactionRequest2.name, version: SignTransactionRequest2.currentVersion };
    return serializeWalletRequestWithArgs(request2, serializeArgs);
  }
  SignTransactionRequest2.serialize = serialize;
  function deserialize(serializedRequest) {
    return deserializeWalletRequestWithArgs(
      serializedRequest,
      (deserializer) => deserializeArgs(deserializer, serializedRequest.version)
    );
  }
  SignTransactionRequest2.deserialize = deserialize;
  function isSerialized(request2) {
    return request2.name === SignTransactionRequest2.name && SignTransactionRequest2.supportedVersions.includes(request2.version);
  }
  SignTransactionRequest2.isSerialized = isSerialized;
})(SignTransactionRequest || (SignTransactionRequest = {}));
var SignTransactionResponse;
((SignTransactionResponse2) => {
  function serializeApprovalArgs(serializer, value) {
    serializer.serialize(value.authenticator);
    serializer.serializeBool(value.rawTransaction !== void 0);
    if (value.rawTransaction !== void 0) {
      serializer.serialize(value.rawTransaction);
    }
  }
  function deserializeApprovalArgs(deserializer) {
    const authenticator = deserializer.deserialize(r);
    const hasRawTransaction = deserializer.deserializeBool();
    const rawTransaction = hasRawTransaction ? deserializer.deserialize(t3) : void 0;
    return {
      authenticator,
      rawTransaction
    };
  }
  const serializeArgs = makeUserResponseSerializeFn(serializeApprovalArgs);
  const deserializeArgs = makeUserResponseDeserializeFn(deserializeApprovalArgs);
  function serialize(args) {
    return serializeWalletResponse(args, serializeArgs);
  }
  SignTransactionResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, deserializeArgs);
  }
  SignTransactionResponse2.deserialize = deserialize;
})(SignTransactionResponse || (SignTransactionResponse = {}));
function isTypedMessage(messageCls, message) {
  return (message == null ? void 0 : message.__messageType) === messageCls.TYPE;
}
var _AptosWalletRequestMessage = class _AptosWalletRequestMessage2 {
  constructor(nonce, serializedValue) {
    this.nonce = nonce;
    this.serializedValue = serializedValue;
    this.__messageType = _AptosWalletRequestMessage2.TYPE;
  }
};
_AptosWalletRequestMessage.TYPE = "AptosWalletRequest";
var _AptosWalletSuccessResponseMessage = class _AptosWalletSuccessResponseMessage2 {
  constructor(serializedValue, nonce) {
    this.serializedValue = serializedValue;
    this.nonce = nonce;
    this.__messageType = _AptosWalletSuccessResponseMessage2.TYPE;
  }
};
_AptosWalletSuccessResponseMessage.TYPE = "AptosWalletSuccessResponseMessage";
var _AptosWalletErrorResponseMessage = class _AptosWalletErrorResponseMessage2 {
  constructor(error, nonce) {
    this.error = error;
    this.nonce = nonce;
    this.__messageType = _AptosWalletErrorResponseMessage2.TYPE;
  }
};
_AptosWalletErrorResponseMessage.TYPE = "AptosWalletErrorResponseMessage";
var _PromptOpenerPingRequestMessage = class _PromptOpenerPingRequestMessage2 {
  constructor() {
    this.__messageType = _PromptOpenerPingRequestMessage2.TYPE;
  }
};
_PromptOpenerPingRequestMessage.TYPE = "PromptOpenerPingRequest";
var PromptOpenerPingRequestMessage = _PromptOpenerPingRequestMessage;
var _PromptOpenerPingResponseMessage = class _PromptOpenerPingResponseMessage2 {
  constructor() {
    this.__messageType = _PromptOpenerPingResponseMessage2.TYPE;
  }
};
_PromptOpenerPingResponseMessage.TYPE = "PromptOpenerPingResponse";
var PromptOpenerPingResponseMessage = _PromptOpenerPingResponseMessage;
var _PromptApprovalResponseMessage = class _PromptApprovalResponseMessage2 {
  constructor(serializedValue) {
    this.serializedValue = serializedValue;
    this.__messageType = _PromptApprovalResponseMessage2.TYPE;
  }
};
_PromptApprovalResponseMessage.TYPE = "PromptApprovalResponse";
var PromptApprovalResponseMessage = _PromptApprovalResponseMessage;
var _PromptUnauthorizedErrorMessage = class _PromptUnauthorizedErrorMessage2 {
  constructor() {
    this.__messageType = _PromptUnauthorizedErrorMessage2.TYPE;
  }
};
_PromptUnauthorizedErrorMessage.TYPE = "PromptUnauthorizedError";
var PromptUnauthorizedErrorMessage = _PromptUnauthorizedErrorMessage;
function urlEncodeWalletRequest(request2) {
  const serializer = new n();
  serializer.serializeStr(request2.name);
  serializer.serializeBytes(request2.data);
  serializer.serializeStr(request2.version.toString());
  return bytesToBase64(serializer.toUint8Array());
}

// node_modules/@identity-connect/crypto/dist/index.mjs
var EncryptionEnvelopeError = class extends Error {
};
var EnvelopeMessageMismatchError = class _EnvelopeMessageMismatchError extends EncryptionEnvelopeError {
  constructor(message, field) {
    super(message);
    this.field = field;
    this.name = "EnvelopeMessageMismatchError";
    Object.setPrototypeOf(this, _EnvelopeMessageMismatchError.prototype);
  }
};
var DecryptionError = class _DecryptionError extends EncryptionEnvelopeError {
  constructor(message) {
    super(message);
    this.name = "DecryptionError";
    Object.setPrototypeOf(this, _DecryptionError.prototype);
  }
};
var KeyTypes = ((KeyTypes2) => {
  KeyTypes2["Ed25519PublicKey"] = "Ed25519PublicKey";
  KeyTypes2["Ed25519SecretKey"] = "Ed25519SecretKey";
  KeyTypes2["X25519PublicKey"] = "X25519PublicKey";
  KeyTypes2["X25519SecretKey"] = "X25519SecretKey";
  return KeyTypes2;
})(KeyTypes || {});
function createX25519KeyPair() {
  return keypairToX25519(import_tweetnacl2.default.box.keyPair());
}
function createEd25519KeyPair() {
  return keypairToEd25519(import_tweetnacl2.default.sign.keyPair());
}
function toKey(rawKey, type) {
  return {
    key: rawKey,
    type
  };
}
function keypairToEd25519(keyPair) {
  return {
    publicKey: toKey(
      keyPair.publicKey,
      "Ed25519PublicKey"
      /* Ed25519PublicKey */
    ),
    secretKey: toKey(
      keyPair.secretKey,
      "Ed25519SecretKey"
      /* Ed25519SecretKey */
    )
  };
}
function keypairToX25519(keyPair) {
  return {
    publicKey: toKey(
      keyPair.publicKey,
      "X25519PublicKey"
      /* X25519PublicKey */
    ),
    secretKey: toKey(
      keyPair.secretKey,
      "X25519SecretKey"
      /* X25519SecretKey */
    )
  };
}
function decodeBase64(base64Str) {
  if (globalThis.Buffer) {
    return new Uint8Array(Buffer.from(base64Str, "base64"));
  }
  return Uint8Array.from(atob(base64Str), (m17) => m17.codePointAt(0));
}
function encodeBase64(bytes) {
  if (globalThis.Buffer) {
    return Buffer.from(bytes).toString("base64");
  }
  return btoa(Array.from(bytes, (x11) => String.fromCodePoint(x11)).join(""));
}
function concatUint8array(arrayOne, arrayTwo) {
  const mergedArray = new Uint8Array(arrayOne.length + arrayTwo.length);
  mergedArray.set(arrayOne);
  mergedArray.set(arrayTwo, arrayOne.length);
  return mergedArray;
}
var SIGNATURE_PREFIX = "APTOS::IDENTITY_CONNECT";
function convertEd25519PublicKeyToX25519PublicKey(ed25519PublicKey, errorKeyName) {
  const x25519PublicKey = import_ed2curve.default.convertPublicKey(ed25519PublicKey.key.slice(0, 32));
  if (!x25519PublicKey)
    throw new Error(`${errorKeyName} is not a valid Ed25519 public key`);
  return toKey(
    x25519PublicKey,
    "X25519PublicKey"
    /* X25519PublicKey */
  );
}
function convertEd25519SecretKeyToX25519SecretKey(ed25519SecretKey) {
  const x25519SecretKey = import_ed2curve.default.convertSecretKey(ed25519SecretKey.key.slice(0, 32));
  return toKey(
    x25519SecretKey,
    "X25519SecretKey"
    /* X25519SecretKey */
  );
}
function serializeEncryptionResult(enc) {
  return {
    nonceB64: encodeBase64(enc.nonce),
    securedB64: encodeBase64(enc.secured)
  };
}
function deserializeEncryptionResult(enc) {
  return {
    nonce: decodeBase64(enc.nonceB64),
    secured: decodeBase64(enc.securedB64)
  };
}
function encryptMessageDirect(senderX25519SecretKey, receiverX25519PublicKey, message) {
  const nonce = import_tweetnacl.default.randomBytes(import_tweetnacl.default.box.nonceLength);
  const messageUint8 = new TextEncoder().encode(message);
  const secured = import_tweetnacl.default.box(messageUint8, nonce, receiverX25519PublicKey.key, senderX25519SecretKey.key.slice(0, 32));
  return { nonce, secured };
}
function encryptObject(senderX25519SecretKey, receiverEd25519PublicKey, message) {
  const receiverX25519PublicKey = convertEd25519PublicKeyToX25519PublicKey(
    receiverEd25519PublicKey,
    "receiver public key"
  );
  return encryptObjectDirect(senderX25519SecretKey, receiverX25519PublicKey, message);
}
function encryptObjectDirect(senderX25519SecretKey, receiverX25519PublicKey, message) {
  return encryptMessageDirect(senderX25519SecretKey, receiverX25519PublicKey, JSON.stringify(message));
}
function decryptMessageDirect(senderX25519PublicKey, receiverX25519SecretKey, securedMessage, nonce) {
  let decryptedUint8;
  try {
    decryptedUint8 = import_tweetnacl.default.box.open(
      securedMessage,
      nonce,
      senderX25519PublicKey.key.slice(0, 32),
      receiverX25519SecretKey.key.slice(0, 32)
    );
  } catch (e10) {
    throw new DecryptionError(`Could not decrypt message: ${e10.message}`);
  }
  if (!decryptedUint8)
    throw new DecryptionError("Could not decrypt message");
  return new TextDecoder().decode(decryptedUint8);
}
function decryptObject(senderX25519PublicKey, receiverEd25519SecretKey, securedMessage, nonce) {
  const receiverX25519SecretKey = convertEd25519SecretKeyToX25519SecretKey(receiverEd25519SecretKey);
  return decryptObjectDirect(senderX25519PublicKey, receiverX25519SecretKey, securedMessage, nonce);
}
function decryptObjectDirect(senderX25519PublicKey, receiverX25519SecretKey, securedMessage, nonce) {
  const decryptedStr = decryptMessageDirect(senderX25519PublicKey, receiverX25519SecretKey, securedMessage, nonce);
  return JSON.parse(decryptedStr);
}
function messageHash(message, purpose) {
  const signaturePrefixHash = new Uint8Array(sha3_256(`${SIGNATURE_PREFIX}::${purpose}::`));
  return new Uint8Array(sha3_256(concatUint8array(signaturePrefixHash, message)));
}
function signWithEd25519SecretKey(message, signingEd25519SecretKey, purpose) {
  return import_tweetnacl.default.sign.detached(messageHash(message, purpose), signingEd25519SecretKey.key);
}
function verifySignature(message, signature, signingPublicKey, purpose) {
  return signingPublicKey.verifySignature({ message: messageHash(message, purpose), signature });
}
var REQUIRED_FIELDS = [
  "receiverEd25519PublicKeyB64",
  "senderEd25519PublicKeyB64",
  "senderX25519PublicKeyB64",
  "sequence",
  "timestampMillis"
].sort();
function ensurePrivatePublicFieldsDisjoint(privateMessage, publicMessage) {
  const intersection = Object.keys(privateMessage).filter((x11) => Object.keys(publicMessage).includes(x11));
  if (intersection.length > 0) {
    const field = intersection[0];
    throw new EnvelopeMessageMismatchError(`Field ${field} appears in both private and public message fields`, field);
  }
}
function ensureMetadataFields(message) {
  const messageKeys = Object.keys(message).sort();
  const extraFields = messageKeys.filter((key) => !REQUIRED_FIELDS.includes(key));
  const missingFields = REQUIRED_FIELDS.filter((key) => !messageKeys.includes(key));
  if (extraFields.length > 0 || missingFields.length > 0) {
    let extraFieldsStr = extraFields.length > 0 ? `extra(${extraFields.join(", ")})` : "";
    const missingFieldsStr = missingFields.length > 0 ? `missing(${missingFields.join(", ")})` : "";
    extraFieldsStr = extraFieldsStr.length > 0 && missingFieldsStr.length > 0 ? `${extraFieldsStr}, ` : extraFieldsStr;
    throw new EnvelopeMessageMismatchError(
      `PublicMessage metadata fields do not conform to spec: ${extraFieldsStr}${missingFieldsStr}`,
      "_metadata"
    );
  }
}
function encryptAndSignEnvelope(senderEd25519SecretKey, senderEd25519PublicKey, receiverEd25519PublicKey, sequence, publicMessage, privateMessage) {
  const senderEphemeralX25519KeyPair = createX25519KeyPair();
  const metadata = constructMetadata(
    senderEd25519PublicKey,
    receiverEd25519PublicKey,
    sequence,
    senderEphemeralX25519KeyPair.publicKey
  );
  ensureMetadataFields(metadata);
  ensurePrivatePublicFieldsDisjoint(privateMessage, publicMessage);
  return dangerouslyEncryptAndSignEnvelopeUnvalidated(
    senderEd25519SecretKey,
    receiverEd25519PublicKey,
    metadata,
    privateMessage,
    publicMessage,
    senderEphemeralX25519KeyPair
  );
}
function constructMetadata(senderEd25519PublicKey, receiverEd25519PublicKey, sequence, senderEphemeralX25519PublicKey) {
  return {
    receiverEd25519PublicKeyB64: encodeBase64(receiverEd25519PublicKey.key),
    senderEd25519PublicKeyB64: encodeBase64(senderEd25519PublicKey.key),
    senderX25519PublicKeyB64: encodeBase64(senderEphemeralX25519PublicKey.key),
    sequence,
    timestampMillis: Date.now()
  };
}
function dangerouslyEncryptAndSignEnvelopeUnvalidated(senderEd25519SecretKey, receiverEd25519PublicKey, metadata, privateMessage, publicMessage, senderEphemeralX25519KeyPair) {
  const encryptionResult = encryptObject(
    senderEphemeralX25519KeyPair.secretKey,
    receiverEd25519PublicKey,
    privateMessage
  );
  const encryptedPrivateMessage = serializeEncryptionResult(encryptionResult);
  const encryptedPrivateMessageBytes = decodeBase64(encryptedPrivateMessage.securedB64);
  const serializedPublicMessage = JSON.stringify({ ...publicMessage, _metadata: metadata });
  const publicMessageBytes = new TextEncoder().encode(serializedPublicMessage);
  const messageSignature = signEnvelope(publicMessageBytes, encryptedPrivateMessageBytes, senderEd25519SecretKey);
  return {
    encryptedPrivateMessage,
    messageSignature,
    serializedPublicMessage
  };
}
function combineHashedEnvelopeMessageBytes(publicMessageBytes, privateMessageBytes) {
  const publicMessageBytesHash = sha3_256(publicMessageBytes);
  const privateMessageBytesHash = sha3_256(privateMessageBytes);
  const combinedHash = new Uint8Array(publicMessageBytesHash.length + privateMessageBytesHash.length);
  combinedHash.set(publicMessageBytesHash);
  combinedHash.set(privateMessageBytesHash, publicMessageBytesHash.length);
  return sha3_256(combinedHash);
}
function signEnvelope(publicMessageBytes, privateMessageBytes, senderEd25519SecretKey) {
  const messageHashBytes = combineHashedEnvelopeMessageBytes(publicMessageBytes, privateMessageBytes);
  const signatureBytes = signWithEd25519SecretKey(messageHashBytes, senderEd25519SecretKey, "SECURED_ENVELOPE");
  return i.fromHexInput(signatureBytes).toString();
}
function verifyEnvelopeSignature(publicMessageBytes, privateMessageBytes, messageSignatureInput, senderEd25519PublicKey) {
  const messageSignature = new c2(i.fromHexInput(messageSignatureInput).toUint8Array());
  const senderPublicKey = new m(senderEd25519PublicKey.key);
  const messageHashBytes = combineHashedEnvelopeMessageBytes(publicMessageBytes, privateMessageBytes);
  const messageVerified = verifySignature(messageHashBytes, messageSignature, senderPublicKey, "SECURED_ENVELOPE");
  if (!messageVerified) {
    throw new EnvelopeMessageMismatchError("Could not verify SecuredEnvelope signature", "messageSignature");
  }
}
function decryptEnvelope(senderEd25519PublicKey, receiverEd25519SecretKey, message) {
  const { encryptedPrivateMessage, messageSignature, serializedPublicMessage } = message;
  const publicMessage = JSON.parse(serializedPublicMessage);
  const rawPrivateMessage = decodeBase64(encryptedPrivateMessage.securedB64);
  const rawPublicMessage = new TextEncoder().encode(serializedPublicMessage);
  verifyEnvelopeSignature(rawPublicMessage, rawPrivateMessage, messageSignature, senderEd25519PublicKey);
  const senderEd25519PublicKeyB64 = encodeBase64(senderEd25519PublicKey.key);
  const expectedPublicKeyB64 = publicMessage._metadata.senderEd25519PublicKeyB64;
  if (senderEd25519PublicKeyB64 !== expectedPublicKeyB64) {
    throw new EnvelopeMessageMismatchError(
      "senderEd25519PublicKey in envelope does not match provided receiverEd25519SecretKey",
      "senderPublicKey"
    );
  }
  const senderX25519PublicKeyBytes = decodeBase64(publicMessage._metadata.senderX25519PublicKeyB64);
  const senderX25519PublicKey = toKey(
    senderX25519PublicKeyBytes,
    "X25519PublicKey"
    /* X25519PublicKey */
  );
  const encryptionResult = deserializeEncryptionResult(encryptedPrivateMessage);
  const privateMessage = decryptObject(
    senderX25519PublicKey,
    receiverEd25519SecretKey,
    encryptionResult.secured,
    encryptionResult.nonce
  );
  ensureMetadataFields(publicMessage._metadata);
  ensurePrivatePublicFieldsDisjoint(privateMessage, publicMessage);
  return {
    messageSignature,
    privateMessage,
    publicMessage
  };
}
function serializePublicKeyB64(publicKey) {
  const serializer = new n();
  serializePublicKey(serializer, publicKey);
  return bytesToBase64(serializer.toUint8Array());
}
function deserializePublicKeyB64(publicKeyB64) {
  const serializedPublicKey = base64ToBytes(publicKeyB64);
  const deserializer = new n2(serializedPublicKey);
  return deserializePublicKey(deserializer);
}
function deserializeEd25519PublicKeyB64(ed25519PublicKeyB64) {
  return new m(decodeBase64(ed25519PublicKeyB64));
}
var AccountConnectionAction = ((AccountConnectionAction2) => {
  AccountConnectionAction2["ADD"] = "add";
  AccountConnectionAction2["REMOVE"] = "remove";
  return AccountConnectionAction2;
})(AccountConnectionAction || {});

// node_modules/@aptos-connect/web-transport/dist/index.mjs
var DEFAULT_PROMPT_SIZE = { height: 695, width: 465 };
var PROMPT_POLLER_INTERVAL = 500;
var dismissalSerializedResponse = ConnectResponse.serialize({ status: "dismissed" });
var PromptUnauthorizedError = class extends Error {
  constructor() {
    super("Unauthorized");
  }
};
function openPrompt(url, size = DEFAULT_PROMPT_SIZE) {
  const { height, width } = size;
  const options = {
    height,
    left: window.screenLeft + Math.round((window.outerWidth - width) / 2),
    popup: true,
    top: window.screenTop + Math.round((window.outerHeight - height) / 2),
    width
  };
  const strOptions = Object.entries(options).map(([key, value]) => `${key}=${JSON.stringify(value)}`).reduce((acc, entry) => `${acc}, ${entry}`);
  const href = url instanceof URL ? url.href : url;
  const promptWindow = window.open(href, void 0, strOptions);
  if (promptWindow === null) {
    throw new Error("Couldn't open prompt");
  }
  return promptWindow;
}
async function waitForPromptResponse(baseUrl, promptWindow) {
  return new Promise((resolve, reject) => {
    const listeners = {
      onMessage: (message) => {
        if (message.source !== promptWindow || message.origin !== baseUrl) {
          return;
        }
        if (isTypedMessage(PromptUnauthorizedErrorMessage, message.data)) {
          window.removeEventListener("message", listeners.onMessage);
          clearTimeout(listeners.promptPollerId);
          reject(new PromptUnauthorizedError());
          return;
        }
        if (isTypedMessage(PromptOpenerPingRequestMessage, message.data)) {
          promptWindow.postMessage(new PromptOpenerPingResponseMessage(), baseUrl);
          return;
        }
        if (isTypedMessage(PromptApprovalResponseMessage, message.data)) {
          window.removeEventListener("message", listeners.onMessage);
          clearTimeout(listeners.promptPollerId);
          resolve(message.data.serializedValue);
        }
      },
      promptPollerId: setInterval(() => {
        if (promptWindow.closed) {
          window.removeEventListener("message", listeners.onMessage);
          clearTimeout(listeners.promptPollerId);
          resolve(dismissalSerializedResponse);
        }
      }, PROMPT_POLLER_INTERVAL)
    };
    window.addEventListener("message", listeners.onMessage);
  });
}
var localDappStateKey = "@aptos-connect/dapp-local-state";
function serializeLocalDappState(state) {
  const serializer = new n();
  serializer.serializeU32AsUleb128(state.connectedAccounts.length);
  for (const account of state.connectedAccounts) {
    serializeAccountInfo(serializer, account);
  }
  return serializer.toUint8Array();
}
function deserializeLocalDappState(serializedValue) {
  const deserializer = new n2(serializedValue);
  const connectedAccountsLength = deserializer.deserializeUleb128AsU32();
  const connectedAccounts = [];
  for (let i49 = 0; i49 < connectedAccountsLength; i49 += 1) {
    connectedAccounts.push(deserializeAccountInfo(deserializer));
  }
  return { connectedAccounts };
}
function getState() {
  const encodedValue = window.localStorage.getItem(localDappStateKey);
  return encodedValue ? deserializeLocalDappState(base64ToBytes(encodedValue)) : { connectedAccounts: [] };
}
function setState(state) {
  const serializedValue = serializeLocalDappState(state);
  const encodedValue = bytesToBase64(serializedValue);
  window.localStorage.setItem(localDappStateKey, encodedValue);
}
function getConnectedAccounts() {
  const state = getState();
  return state.connectedAccounts;
}
function addConnectedAccount(account) {
  const { connectedAccounts, ...state } = getState();
  connectedAccounts.push(account);
  setState({ ...state, connectedAccounts });
}
function removeConnectedAccount(address) {
  const { connectedAccounts, ...state } = getState();
  const index = connectedAccounts.findIndex((a26) => a26.address.equals(address));
  if (index >= 0) {
    connectedAccounts.splice(index, 1);
  }
  setState({ ...state, connectedAccounts });
}
var WebWalletTransport = class {
  constructor(baseUrl) {
    this.baseUrl = baseUrl;
    this.baseUrl = baseUrl;
  }
  async sendPromptRequest(request2) {
    const url = new URL(`${this.baseUrl}/prompt/`);
    url.searchParams.set("request", urlEncodeWalletRequest(request2));
    const prompt = openPrompt(url);
    return waitForPromptResponse(this.baseUrl, prompt);
  }
  async sendRequest(request2) {
    switch (request2.name) {
      case IsConnectedRequest.name: {
        const connectedAccounts = getConnectedAccounts();
        return IsConnectedResponse.serialize(connectedAccounts.length > 0);
      }
      case GetConnectedAccountsRequest.name: {
        const connectedAccounts = getConnectedAccounts();
        return GetConnectedAccountsResponse.serialize(connectedAccounts);
      }
      case ConnectRequest.name: {
        const serializedResponse = await this.sendPromptRequest(request2);
        const response = ConnectResponse.deserialize(serializedResponse);
        if (response.args.status === "approved") {
          const { account, pairing } = response.args.args;
          if (pairing === void 0) {
            addConnectedAccount(account);
          }
        }
        return serializedResponse;
      }
      case DisconnectRequest.name: {
        const [activeAccount] = getConnectedAccounts();
        if (activeAccount) {
          removeConnectedAccount(activeAccount.address);
        }
        return DisconnectResponse.serialize({});
      }
      case SignMessageRequest.name:
      case SignTransactionRequest.name:
      case SignAndSubmitTransactionRequest.name: {
        return this.sendPromptRequest(request2);
      }
      default: {
        throw new Error("Unexpected request");
      }
    }
  }
};

// node_modules/@identity-connect/api/dist/index.mjs
var NetworkName = ((NetworkName22) => {
  NetworkName22["DEVNET"] = "devnet";
  NetworkName22["MAINNET"] = "mainnet";
  NetworkName22["TESTNET"] = "testnet";
  return NetworkName22;
})(NetworkName || {});
var PairingStatus = ((PairingStatus2) => {
  PairingStatus2["Finalized"] = "FINALIZED";
  PairingStatus2["Pending"] = "PENDING";
  return PairingStatus2;
})(PairingStatus || {});
var SigningRequestTypes = ((SigningRequestTypes2) => {
  SigningRequestTypes2["SIGN_AND_SUBMIT_TRANSACTION"] = "SIGN_AND_SUBMIT_TRANSACTION";
  SigningRequestTypes2["SIGN_MESSAGE"] = "SIGN_MESSAGE";
  SigningRequestTypes2["SIGN_TRANSACTION"] = "SIGN_TRANSACTION";
  return SigningRequestTypes2;
})(SigningRequestTypes || {});
var SigningRequestStatus = ((SigningRequestStatus2) => {
  SigningRequestStatus2["APPROVED"] = "APPROVED";
  SigningRequestStatus2["CANCELLED"] = "CANCELLED";
  SigningRequestStatus2["INVALID"] = "INVALID";
  SigningRequestStatus2["PENDING"] = "PENDING";
  SigningRequestStatus2["REJECTED"] = "REJECTED";
  return SigningRequestStatus2;
})(SigningRequestStatus || {});

// node_modules/@identity-connect/wallet-api/dist/index.mjs
function isBcsSerializableV1(value) {
  return (value == null ? void 0 : value.serialize) !== void 0;
}
function isBcsSerializableV2(value) {
  return (value == null ? void 0 : value.serialize) !== void 0 && (value == null ? void 0 : value.bcsToBytes) !== void 0 && (value == null ? void 0 : value.bcsToHex) !== void 0;
}
function isBcsSerializable(value) {
  return isBcsSerializableV1(value) || isBcsSerializableV2(value);
}
function bcsSerialize(serializable) {
  if (isBcsSerializableV2(serializable)) {
    return serializable.bcsToHex().toString();
  }
  const serializedValueBytes = bcs_exports.bcsToBytes(serializable);
  return i.fromHexInput(serializedValueBytes).toString();
}
function bcsDeserialize(deserializableClass, serializedValue) {
  const serializedValueBytes = i.fromHexString(serializedValue).toUint8Array();
  const deserializer = new n2(serializedValueBytes);
  return deserializableClass.deserialize(deserializer);
}
var UnexpectedValueError = class _UnexpectedValueError extends Error {
  constructor(message) {
    super(message);
    this.name = "UnexpectedValueError";
    Object.setPrototypeOf(this, _UnexpectedValueError.prototype);
  }
};
function serializeEntryFunctionArg(arg) {
  if (arg instanceof Uint8Array) {
    return {
      type: "Uint8Array",
      value: i.fromHexInput(arg).toString()
    };
  }
  if (Array.isArray(arg)) {
    return arg.map(serializeEntryFunctionArg);
  }
  return arg;
}
function serializeEntryFunctionPayload(payload) {
  const normalizedArgs = payload.arguments.map(serializeEntryFunctionArg);
  return {
    ...payload,
    arguments: normalizedArgs,
    type: "entry_function_payload"
  };
}
function serializeJsonTransactionPayload(payload) {
  if (payload.type === "entry_function_payload" || payload.type === void 0) {
    return serializeEntryFunctionPayload(payload);
  }
  if (payload.type === "multisig_payload") {
    const innerPayload = payload.transaction_payload !== void 0 ? serializeEntryFunctionPayload(payload.transaction_payload) : void 0;
    return { ...payload, transaction_payload: innerPayload };
  }
  throw new UnexpectedValueError();
}
function serializeRawTransaction(rawTxn) {
  const value = bcsSerialize(rawTxn);
  if ("fee_payer_address" in rawTxn) {
    return { type: "fee_payer_raw_txn", value };
  }
  if ("secondary_signer_addresses" in rawTxn) {
    return { type: "multi_agent_raw_txn", value };
  }
  if ("chain_id" in rawTxn) {
    return { type: "raw_txn", value };
  }
  throw new UnexpectedValueError("Invalid raw transaction type");
}
function serializeSignAndSubmitTransactionRequestArgs(args) {
  if ("payload" in args) {
    const serializedPayload = isBcsSerializable(args.payload) ? bcsSerialize(args.payload) : serializeJsonTransactionPayload(args.payload);
    return { options: args.options, payload: serializedPayload };
  }
  if ("feePayerAuthenticator" in args) {
    return {
      feePayerAuthenticator: bcsSerialize(args.feePayerAuthenticator),
      rawTxn: serializeRawTransaction(args.rawTxn)
    };
  }
  if ("rawTxn" in args) {
    return { rawTxn: serializeRawTransaction(args.rawTxn) };
  }
  throw new UnexpectedValueError();
}
function serializeSignTransactionRequestArgs(args) {
  if ("payload" in args) {
    const serializedPayload = isBcsSerializable(args.payload) ? bcsSerialize(args.payload) : serializeJsonTransactionPayload(args.payload);
    return { options: args.options, payload: serializedPayload };
  }
  if ("rawTxn" in args) {
    const serializedRawTxn = serializeRawTransaction(args.rawTxn);
    return { rawTxn: serializedRawTxn };
  }
  throw new UnexpectedValueError();
}
function deserializeSignTransactionResponseArgs(args) {
  const accountAuthenticator = bcsDeserialize(r, args.accountAuthenticator);
  if ("rawTxn" in args) {
    const rawTxn = bcsDeserialize(t3, args.rawTxn);
    return { accountAuthenticator, rawTxn };
  }
  return { accountAuthenticator };
}

// node_modules/@identity-connect/dapp-sdk/dist/index.mjs
var DEFAULT_FRONTEND_URL = "https://aptosconnect.app";
var SignatureRequestError = class _SignatureRequestError extends Error {
  constructor(status) {
    super(status);
    this.name = "SignatureRequestError";
    Object.setPrototypeOf(this, _SignatureRequestError.prototype);
  }
};
var UnexpectedSignatureResponseError = class _UnexpectedSignatureResponseError extends Error {
  constructor(missingFields) {
    const message = `Missing the following fields: ${missingFields.join(", ")}`;
    super(message);
    this.name = "UnexpectedSignatureResponseError";
    Object.setPrototypeOf(this, _UnexpectedSignatureResponseError.prototype);
  }
};
var PairingExpiredError = class _PairingExpiredError extends Error {
  constructor() {
    super();
    this.name = "PairingExpiredError";
    Object.setPrototypeOf(this, _PairingExpiredError.prototype);
  }
};
var DAPP_PAIRINGS_WINDOW_STORAGE_KEY = "icDappPairings";
var windowStateAccessors = {
  async get(address) {
    const pairings = await this.getAll();
    return pairings[address];
  },
  async getAll() {
    const serialized = window.localStorage.getItem(DAPP_PAIRINGS_WINDOW_STORAGE_KEY);
    return serialized ? JSON.parse(serialized) : {};
  },
  async update(address, pairing) {
    const pairings = await this.getAll();
    if (pairing === void 0) {
      delete pairings[address];
    } else {
      pairings[address] = pairing;
    }
    const newSerialized = JSON.stringify(pairings);
    window.localStorage.setItem(DAPP_PAIRINGS_WINDOW_STORAGE_KEY, newSerialized);
  }
};
var SIGN_MESSAGE_RESPONSE_REQUIRED_FIELDS = [
  "address",
  "application",
  "chainId",
  "fullMessage",
  "message",
  "nonce",
  "prefix",
  "signature"
];
function validateSignMessageResponse(response) {
  const providedFields = new Set(Object.keys(response));
  const missingFields = SIGN_MESSAGE_RESPONSE_REQUIRED_FIELDS.filter((field) => !providedFields.has(field));
  if (missingFields.length > 0) {
    throw new UnexpectedSignatureResponseError(missingFields);
  }
}
var SIGN_AND_SUBMIT_TRANSACTION_RESPONSE_REQUIRED_FIELDS = ["hash"];
function validateSignAndSubmitTransactionResponse(response) {
  const providedFields = new Set(Object.keys(response));
  const missingFields = SIGN_AND_SUBMIT_TRANSACTION_RESPONSE_REQUIRED_FIELDS.filter(
    (field) => !providedFields.has(field)
  );
  if (missingFields.length > 0) {
    throw new UnexpectedSignatureResponseError(missingFields);
  }
}
var API_VERSION = "0.2.0";
var SIGNING_REQUEST_POLLING_INTERVAL = 2500;
var SEQUENCE_NUMBER_MISMATCH_PATTERN = /^Sequence number mismatch, expected (?:\S+ to be )?(\d+)/;
async function waitFor(milliseconds) {
  return new Promise((resolve) => {
    setTimeout(resolve, milliseconds);
  });
}
async function withRetries(requestFn, onError, retries = 1) {
  for (let i49 = 0; i49 < retries; i49 += 1) {
    try {
      return await requestFn();
    } catch (err) {
      onError(err);
    }
  }
  return requestFn();
}
var ACPairingClient = class {
  constructor({
    accessors = windowStateAccessors,
    axiosConfig,
    defaultNetworkName = NetworkName.MAINNET
  } = {}) {
    this.onDisconnectListeners = /* @__PURE__ */ new Set();
    this.accessors = accessors;
    this.defaultNetworkName = defaultNetworkName;
    this.axiosInstance = axios_default.create({
      baseURL: DEFAULT_FRONTEND_URL,
      ...axiosConfig
    });
    const isClientSideRendering = typeof window !== "undefined";
    this.initPromise = isClientSideRendering ? this.syncFirstPairing() : void 0;
  }
  async getPairing(id) {
    const response = await this.axiosInstance.get(`v1/pairing/${id}/`);
    return response.data.data.pairing;
  }
  async syncFirstPairing() {
    const pairings = await this.accessors.getAll();
    const firstPairing = Object.values(pairings)[0];
    if (firstPairing === void 0) {
      return;
    }
    try {
      const { dappSpecificWallet, maxDappSequenceNumber } = await this.getPairing(firstPairing.pairingId);
      await this.accessors.update(firstPairing.accountAddress, {
        ...firstPairing,
        currSequenceNumber: maxDappSequenceNumber,
        dappWalletId: dappSpecificWallet == null ? void 0 : dappSpecificWallet.id
      });
    } catch (err) {
      await this.accessors.update(firstPairing.accountAddress, void 0);
    }
  }
  async createSigningRequest(pairing, type, networkName, requestBody) {
    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);
    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);
    const accountTransportEd25519PublicKey = decodeBase64(pairing.accountTransportEd25519PublicKeyB64);
    let sequenceNumber = pairing.currSequenceNumber + 1;
    return withRetries(
      async () => {
        const requestEnvelope = await encryptAndSignEnvelope(
          toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey),
          toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey),
          toKey(accountTransportEd25519PublicKey, KeyTypes.Ed25519PublicKey),
          sequenceNumber,
          { apiVersion: API_VERSION, networkName, requestType: type },
          requestBody
        );
        const response = await this.axiosInstance.post(
          `v1/pairing/${pairing.pairingId}/signing-request/`,
          requestEnvelope
        );
        await this.accessors.update(pairing.accountAddress, {
          ...pairing,
          currSequenceNumber: sequenceNumber
        });
        return response.data.data.signingRequest;
      },
      (err) => {
        var _a, _b, _c;
        if (isAxiosError(err)) {
          const errorMessage = (_b = (_a = err.response) == null ? void 0 : _a.data) == null ? void 0 : _b.message;
          const expectedSequenceNumber = (_c = errorMessage == null ? void 0 : errorMessage.match(SEQUENCE_NUMBER_MISMATCH_PATTERN)) == null ? void 0 : _c[1];
          if (expectedSequenceNumber !== void 0) {
            sequenceNumber = Number(expectedSequenceNumber);
            return;
          }
        }
        throw err;
      }
    );
  }
  async getSigningRequest(id) {
    var _a, _b;
    const response = await this.axiosInstance.get(
      `v1/signing-request/${id}/`,
      {
        validateStatus: (status) => status === 200 || status === 404
      }
    );
    return (_b = (_a = response.data) == null ? void 0 : _a.data) == null ? void 0 : _b.signingRequest;
  }
  async deletePairing(pairingId, secretKey, publicKey) {
    const requestEnvelope = await encryptAndSignEnvelope(
      secretKey,
      publicKey,
      publicKey,
      0,
      // ignored
      {},
      {}
    );
    await this.axiosInstance.post(
      `v1/pairing/${pairingId}/delete/`,
      requestEnvelope,
      { validateStatus: (status) => status === 204 || status === 404 }
    );
  }
  async cancelSigningRequest(pairing, id) {
    const sequenceNumber = pairing.currSequenceNumber;
    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);
    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);
    const accountTransportEd25519PublicKey = decodeBase64(pairing.accountTransportEd25519PublicKeyB64);
    const requestEnvelope = await encryptAndSignEnvelope(
      toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey),
      toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey),
      toKey(accountTransportEd25519PublicKey, KeyTypes.Ed25519PublicKey),
      sequenceNumber + 1,
      {},
      {}
    );
    const response = await this.axiosInstance.patch(
      `v1/signing-request/${id}/cancel/`,
      requestEnvelope
    );
    await this.accessors.update(pairing.accountAddress, {
      ...pairing,
      currSequenceNumber: sequenceNumber + 1
    });
    return response.data.data.signingRequest;
  }
  async signRequest(address, type, requestBody, { cancelToken, networkName } = {}) {
    await this.initPromise;
    const pairing = await this.accessors.get(address);
    if (pairing === void 0) {
      throw new Error("The requested account is not paired");
    }
    let signingRequest;
    try {
      signingRequest = await this.createSigningRequest(
        pairing,
        type,
        networkName || this.defaultNetworkName,
        requestBody
      );
      while (signingRequest.status === "PENDING") {
        await waitFor(SIGNING_REQUEST_POLLING_INTERVAL);
        if (cancelToken == null ? void 0 : cancelToken.cancelled) {
          signingRequest.status = SigningRequestStatus.CANCELLED;
          break;
        }
        signingRequest = await this.getSigningRequest(signingRequest.id) ?? signingRequest;
      }
    } catch (err) {
      if (isAxiosError(err) && err.code === "404") {
        await this.accessors.update(address, void 0);
        for (const listener of this.onDisconnectListeners) {
          listener(address);
        }
        throw new PairingExpiredError();
      }
      throw err;
    }
    if (signingRequest.status !== "APPROVED") {
      throw new SignatureRequestError(signingRequest.status);
    }
    const decrypted = decryptEnvelope(
      toKey(decodeBase64(pairing.accountTransportEd25519PublicKeyB64), KeyTypes.Ed25519PublicKey),
      toKey(decodeBase64(pairing.dappEd25519SecretKeyB64), KeyTypes.Ed25519SecretKey),
      signingRequest.responseEnvelope
    );
    return decrypted.privateMessage;
  }
  // region Public API
  /**
   * Requests a connection to an account (internally known as pairing).
   * @returns either the address of the connected account, or undefined if the
   * connection was cancelled.
   */
  async addPairing({ publicKey, secretKey }, finalizedPairing) {
    await this.accessors.update(finalizedPairing.account.accountAddress, {
      accountAddress: finalizedPairing.account.accountAddress,
      accountAlias: finalizedPairing.account.userSubmittedAlias ?? void 0,
      accountPublicKeyB64: finalizedPairing.account.publicKeyB64,
      accountTransportEd25519PublicKeyB64: finalizedPairing.account.transportEd25519PublicKeyB64,
      currSequenceNumber: finalizedPairing.maxDappSequenceNumber,
      dappEd25519PublicKeyB64: encodeBase64(publicKey.key),
      dappEd25519SecretKeyB64: encodeBase64(secretKey.key),
      dappWalletId: finalizedPairing.dappSpecificWalletId,
      pairingId: finalizedPairing.id
    });
  }
  async disconnect(address) {
    const pairing = await this.accessors.get(address);
    if (pairing === void 0) {
      throw new Error("The specified account is not paired");
    }
    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);
    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);
    await this.deletePairing(
      pairing.pairingId,
      toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey),
      toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey)
    );
    await this.accessors.update(address, void 0);
    for (const listener of this.onDisconnectListeners) {
      listener(address);
    }
  }
  async signMessage(address, args, options) {
    const response = await this.signRequest(
      address,
      SigningRequestTypes.SIGN_MESSAGE,
      args,
      options
    );
    validateSignMessageResponse(response);
    return response;
  }
  async signTransaction(address, args, options) {
    const serializedRequestArgs = serializeSignTransactionRequestArgs(args);
    const serializedResponseArgs = await this.signRequest(address, SigningRequestTypes.SIGN_TRANSACTION, serializedRequestArgs, options);
    return deserializeSignTransactionResponseArgs(serializedResponseArgs);
  }
  // endregion
  async signAndSubmitTransaction(address, args, options) {
    var _a, _b, _c, _d;
    const serializedRequestArgs = serializeSignAndSubmitTransactionRequestArgs(args);
    try {
      const responseArgs = await this.signRequest(address, SigningRequestTypes.SIGN_AND_SUBMIT_TRANSACTION, serializedRequestArgs, options);
      validateSignAndSubmitTransactionResponse(responseArgs);
      return responseArgs;
    } catch (e10) {
      if (e10 instanceof AxiosError && ((_b = (_a = e10.response) == null ? void 0 : _a.data) == null ? void 0 : _b.message)) {
        throw new Error((_d = (_c = e10.response) == null ? void 0 : _c.data) == null ? void 0 : _d.message);
      }
      throw e10;
    }
  }
  async getConnectedAccounts() {
    await this.initPromise;
    const pairings = await this.accessors.getAll();
    return Object.values(pairings).map(
      ({ accountAddress, accountEd25519PublicKeyB64, accountPublicKeyB64 }) => ({
        address: c.from(accountAddress),
        publicKey: accountPublicKeyB64 !== void 0 ? deserializePublicKeyB64(accountPublicKeyB64) : deserializeEd25519PublicKeyB64(accountEd25519PublicKeyB64)
      })
    );
  }
  onDisconnect(listener) {
    this.onDisconnectListeners.add(listener);
    return () => this.onDisconnectListeners.delete(listener);
  }
};
var ACDappClient = class {
  constructor({
    backendBaseURL,
    dappId,
    dappImageURI,
    dappName,
    defaultNetworkName = NetworkName.MAINNET,
    frontendBaseURL = DEFAULT_FRONTEND_URL
  } = {}) {
    this.defaultNetworkName = defaultNetworkName;
    this.dappInfo = {
      domain: window.location.origin,
      imageURI: dappImageURI,
      name: dappName ?? document.title
    };
    this.transport = new WebWalletTransport(frontendBaseURL);
    this.dappId = dappId;
    this.pairingClient = new ACPairingClient({
      axiosConfig: {
        baseURL: backendBaseURL ?? frontendBaseURL
      },
      defaultNetworkName
    });
  }
  // region Public API
  async getKeylessAccounts() {
    const serializedRequest = GetConnectedAccountsRequest.serialize(this.dappInfo);
    const serializedResponse = await this.transport.sendRequest(serializedRequest);
    const response = GetConnectedAccountsResponse.deserialize(serializedResponse);
    return response.args;
  }
  async getIcAccounts() {
    return this.pairingClient.getConnectedAccounts() ?? [];
  }
  async isIcAccount(address) {
    const icAccounts = await this.getIcAccounts();
    return icAccounts.find((account) => account.address.equals(c.from(address))) !== void 0;
  }
  async getConnectedAccounts() {
    const keylessAccounts = await this.getKeylessAccounts();
    const icAccounts = await this.getIcAccounts();
    return [...keylessAccounts, ...icAccounts];
  }
  async disconnect(address) {
    if (await this.isIcAccount(address)) {
      const stringAddress = c.from(address).toString();
      await this.pairingClient.disconnect(stringAddress);
    } else {
      const serializedRequest = DisconnectRequest.serialize(this.dappInfo);
      await this.transport.sendRequest(serializedRequest);
    }
  }
  async connect() {
    const dappKeypair = createEd25519KeyPair();
    const requestArgs = {
      dappEd25519PublicKeyB64: encodeBase64(dappKeypair.publicKey.key),
      dappId: this.dappId
    };
    const serializedRequest = ConnectRequest.serialize(this.dappInfo, requestArgs);
    const serializedResponse = await this.transport.sendRequest(serializedRequest);
    const response = ConnectResponse.deserialize(serializedResponse);
    if (response.args.status === "approved") {
      const { account, pairing } = response.args.args;
      if (pairing) {
        await this.pairingClient.addPairing(dappKeypair, pairing);
      }
      return makeUserApproval({ account });
    }
    return response.args;
  }
  async signMessage(args) {
    const { signerAddress } = args;
    if (await this.isIcAccount(signerAddress)) {
      const { chainId } = args;
      const network = chainIdToNetwork(chainId);
      let message;
      let nonce;
      try {
        message = new TextDecoder().decode(args.message);
        nonce = new TextDecoder().decode(args.nonce);
      } catch (err) {
        throw new Error("Only UTF-8 encoded text is supported when using IC");
      }
      const { fullMessage, signature: hexSignature } = await this.pairingClient.signMessage(
        signerAddress.toString(),
        {
          address: true,
          application: true,
          chainId: true,
          message,
          nonce
        },
        { networkName: network }
      );
      const signatureBytes = i.fromHexInput(hexSignature).toUint8Array();
      const signature = signatureBytes.length === c2.LENGTH ? new c2(signatureBytes) : u.deserialize(new n2(signatureBytes));
      return makeUserApproval({
        fullMessage,
        signature
      });
    }
    const serializedRequest = SignMessageRequest.serialize(this.dappInfo, args);
    const serializedResponse = await this.transport.sendRequest(serializedRequest);
    const response = SignMessageResponse.deserialize(serializedResponse);
    return response.args;
  }
  async signTransaction(args) {
    const normalizedArgs = "transaction" in args ? SignTransactionRequest.normalizeArgs(args) : args;
    const { signerAddress } = args;
    if (await this.isIcAccount(signerAddress)) {
      const {
        expirationSecondsFromNow,
        expirationTimestamp,
        feePayer,
        gasUnitPrice,
        maxGasAmount,
        network,
        payload,
        secondarySigners,
        sender,
        sequenceNumber
      } = normalizedArgs;
      if (feePayer !== void 0) {
        throw new Error("Sponsored transaction not currently supported");
      }
      if (secondarySigners && secondarySigners.length > 0) {
        throw new Error("Multi-agent transactions not currently supported");
      }
      const responseArgs = await this.pairingClient.signTransaction(
        signerAddress.toString(),
        {
          options: {
            expirationSecondsFromNow,
            expirationTimestamp,
            gasUnitPrice,
            maxGasAmount,
            sender: sender == null ? void 0 : sender.address.toString(),
            sequenceNumber: sequenceNumber !== void 0 ? Number(sequenceNumber) : void 0
          },
          payload
        },
        {
          networkName: network
        }
      );
      return makeUserApproval({
        authenticator: responseArgs.accountAuthenticator,
        rawTransaction: responseArgs.rawTxn
      });
    }
    const serializedRequest = SignTransactionRequest.serialize(this.dappInfo, normalizedArgs);
    const serializedResponse = await this.transport.sendRequest(serializedRequest);
    const response = SignTransactionResponse.deserialize(serializedResponse);
    return response.args;
  }
  async signAndSubmitTransaction(args) {
    const { signerAddress } = args;
    if (await this.isIcAccount(signerAddress)) {
      const { expirationTimestamp, feePayer, gasUnitPrice, maxGasAmount, network } = args;
      const aptosConfig = new l({ network });
      let payload;
      if ("bcsToBytes" in args.payload) {
        payload = args.payload;
      } else if ("bytecode" in args.payload) {
        payload = await Vn(args.payload);
      } else {
        payload = args.payload.abi !== void 0 ? An({ ...args.payload, abi: args.payload.abi }) : await Vn({ aptosConfig, ...args.payload });
      }
      let convertedArgs;
      if (feePayer !== void 0) {
        const rawTxn = await gn({
          aptosConfig,
          feePayerAddress: feePayer.address,
          options: {
            gasUnitPrice,
            maxGasAmount
          },
          payload,
          sender: signerAddress
        });
        convertedArgs = {
          feePayerAuthenticator: feePayer.authenticator,
          rawTxn: new p(rawTxn, [], feePayer.address)
        };
      } else {
        convertedArgs = {
          options: {
            expirationTimestamp,
            gasUnitPrice,
            maxGasAmount
          },
          payload
        };
      }
      const { hash } = await this.pairingClient.signAndSubmitTransaction(signerAddress.toString(), convertedArgs, {
        networkName: network
      });
      return makeUserApproval({ txnHash: hash });
    }
    const serializedRequest = SignAndSubmitTransactionRequest.serialize(this.dappInfo, args);
    const serializedResponse = await this.transport.sendRequest(serializedRequest);
    const response = SignAndSubmitTransactionResponse.deserialize(serializedResponse);
    return response.args;
  }
  // endregion
};

// node_modules/@aptos-connect/wallet-adapter-plugin/dist/index.mjs
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _address;
var _publicKey;
var AptosConnectAccount = class {
  constructor({ address, ansName, publicKey }) {
    this.chains = e4;
    this.features = [];
    __privateAdd(this, _address, void 0);
    __privateAdd(this, _publicKey, void 0);
    __privateSet(this, _publicKey, publicKey);
    __privateSet(this, _address, address);
    this.label = ansName;
  }
  get address() {
    return __privateGet(this, _address).toString();
  }
  get publicKey() {
    return __privateGet(this, _publicKey).toUint8Array();
  }
  get signingScheme() {
    if (__privateGet(this, _publicKey) instanceof m) {
      return f3.Ed25519;
    }
    if (__privateGet(this, _publicKey) instanceof d) {
      return f3.MultiEd25519;
    }
    if (__privateGet(this, _publicKey) instanceof f) {
      return f3.SingleKey;
    }
    if (__privateGet(this, _publicKey) instanceof f2) {
      return f3.MultiKey;
    }
    throw new Error("Unsupported public key type");
  }
  // endregion
};
_address = /* @__PURE__ */ new WeakMap();
_publicKey = /* @__PURE__ */ new WeakMap();
var walletName = "Continue with Google";
var walletUrl = "https://aptosconnect.app";
var walletIcon = (
  // eslint-disable-next-line max-len
  "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiBjbGFzcz0iaF8yMCB3XzIwIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTIzLjU0IDEyLjc2MTNDMjMuNTQgMTEuOTQ1OSAyMy40NjY4IDExLjE2MTggMjMuMzMwOSAxMC40MDkxSDEyLjVWMTQuODU3NUgxOC42ODkxQzE4LjQyMjUgMTYuMjk1IDE3LjYxMjMgMTcuNTEyOSAxNi4zOTQzIDE4LjMyODRWMjEuMjEzOEgyMC4xMTA5QzIyLjI4NTUgMTkuMjExOCAyMy41NCAxNi4yNjM2IDIzLjU0IDEyLjc2MTNaIiBmaWxsPSIjNDI4NUY0Ij48L3BhdGg+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xMi40OTk1IDIzLjk5OThDMTUuNjA0NSAyMy45OTk4IDE4LjIwNzcgMjIuOTcgMjAuMTEwNCAyMS4yMTM3TDE2LjM5MzggMTguMzI4MkMxNS4zNjQgMTkuMDE4MiAxNC4wNDY3IDE5LjQyNTkgMTIuNDk5NSAxOS40MjU5QzkuNTA0MjUgMTkuNDI1OSA2Ljk2OTAyIDE3LjQwMyA2LjA2NDcgMTQuNjg0OEgyLjIyMjY2VjE3LjY2NDRDNC4xMTQ5MyAyMS40MjI4IDguMDA0MDIgMjMuOTk5OCAxMi40OTk1IDIzLjk5OThaIiBmaWxsPSIjMzRBODUzIj48L3BhdGg+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02LjA2NTIzIDE0LjY4NTFDNS44MzUyMyAxMy45OTUxIDUuNzA0NTUgMTMuMjU4MSA1LjcwNDU1IDEyLjUwMDFDNS43MDQ1NSAxMS43NDIyIDUuODM1MjMgMTEuMDA1MSA2LjA2NTIzIDEwLjMxNTFWNy4zMzU1N0gyLjIyMzE4QzEuNDQ0MzIgOC44ODgwNyAxIDEwLjY0NDQgMSAxMi41MDAxQzEgMTQuMzU1OCAxLjQ0NDMyIDE2LjExMjIgMi4yMjMxOCAxNy42NjQ3TDYuMDY1MjMgMTQuNjg1MVoiIGZpbGw9IiNGQkJDMDUiPjwvcGF0aD48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEyLjQ5OTUgNS41NzM4NkMxNC4xODc5IDUuNTczODYgMTUuNzAzOCA2LjE1NDA5IDE2Ljg5NTYgNy4yOTM2NEwyMC4xOTQgMy45OTUyM0MxOC4yMDI0IDIuMTM5NTUgMTUuNTk5MiAxIDEyLjQ5OTUgMUM4LjAwNDAyIDEgNC4xMTQ5MyAzLjU3NzA1IDIuMjIyNjYgNy4zMzU0NUw2LjA2NDcgMTAuMzE1QzYuOTY5MDIgNy41OTY4MiA5LjUwNDI1IDUuNTczODYgMTIuNDk5NSA1LjU3Mzg2WiIgZmlsbD0iI0VBNDMzNSI+PC9wYXRoPjwvc3ZnPg=="
);
function customAccountToStandardAccount({ address, name, publicKey }) {
  return new d2({
    address,
    ansName: name,
    publicKey
  });
}
var _AptosConnectWallet = class _AptosConnectWallet2 {
  constructor({ network = e.MAINNET, ...clientConfig }) {
    this.name = walletName;
    this.version = "1.0.0";
    this.icon = walletIcon;
    this.url = walletUrl;
    this.chains = e4;
    this.client = new ACDappClient(clientConfig);
    if (!o3[network]) {
      throw new Error("Network not supported");
    }
    const aptosConfig = new l({ network });
    this.aptosClient = new t4(aptosConfig);
  }
  static get connectedAccount() {
    const serialized = localStorage.getItem(_AptosConnectWallet2.connectedAccountStorageKey);
    if (!serialized) {
      return void 0;
    }
    try {
      const { address, publicKey } = JSON.parse(serialized);
      return serialized ? new d2({
        address: c.from(address),
        publicKey: deserializePublicKeyB64(publicKey)
      }) : void 0;
    } catch (err) {
      console.warn("Failed to parse state, resetting it");
      this.connectedAccount = void 0;
      return void 0;
    }
  }
  static set connectedAccount(value) {
    if (value !== void 0) {
      const serialized = {
        address: value.address.toString(),
        publicKey: serializePublicKeyB64(value.publicKey)
      };
      localStorage.setItem(_AptosConnectWallet2.connectedAccountStorageKey, JSON.stringify(serialized));
    } else {
      localStorage.removeItem(_AptosConnectWallet2.connectedAccountStorageKey);
    }
  }
  // eslint-disable-next-line class-methods-use-this
  get accounts() {
    const { connectedAccount } = _AptosConnectWallet2;
    return connectedAccount ? [new AptosConnectAccount(connectedAccount)] : [];
  }
  get features() {
    return {
      [o4]: {
        connect: this.connect.bind(this),
        version: "1.0.0"
      },
      [o5]: {
        disconnect: this.disconnect.bind(this),
        version: "1.0.0"
      },
      [t5]: {
        account: this.getAccount.bind(this),
        version: "1.0.0"
      },
      [t6]: {
        network: this.getNetwork.bind(this),
        version: "1.0.0"
      },
      [n7]: {
        onAccountChange: this.onAccountChange.bind(this),
        version: "1.0.0"
      },
      [e3]: {
        onNetworkChange: this.onNetworkChange.bind(this),
        version: "1.0.0"
      },
      [n5]: {
        signAndSubmitTransaction: this.signAndSubmitTransaction.bind(this),
        version: "1.1.0"
      },
      [e2]: {
        signMessage: this.signMessage.bind(this),
        version: "1.0.0"
      },
      [n6]: {
        signTransaction: this.signTransaction.bind(this),
        version: "1.0.0"
      }
    };
  }
  async connect() {
    const { connectedAccount } = _AptosConnectWallet2;
    if (connectedAccount !== void 0) {
      return { args: connectedAccount, status: r4.APPROVED };
    }
    const response = await this.client.connect();
    if (response.status === "dismissed") {
      return { status: r4.REJECTED };
    }
    const newConnectedAccount = customAccountToStandardAccount(response.args.account);
    _AptosConnectWallet2.connectedAccount = newConnectedAccount;
    return {
      args: newConnectedAccount,
      status: r4.APPROVED
    };
  }
  async disconnect() {
    const { connectedAccount } = _AptosConnectWallet2;
    if (connectedAccount) {
      await this.client.disconnect(connectedAccount.address);
      _AptosConnectWallet2.connectedAccount = void 0;
    }
  }
  // eslint-disable-next-line class-methods-use-this
  async getAccount() {
    const { connectedAccount } = _AptosConnectWallet2;
    if (!connectedAccount) {
      throw new r3(n9.Unauthorized);
    }
    return customAccountToStandardAccount(connectedAccount);
  }
  async getNetwork() {
    const { network } = this.aptosClient.config;
    const chainId = await this.aptosClient.getChainId();
    const url = o3[network];
    return {
      chainId,
      name: network,
      url
    };
  }
  async signMessage(input) {
    const { connectedAccount } = _AptosConnectWallet2;
    if (!connectedAccount) {
      throw new r3(n9.Unauthorized);
    }
    const { chainId } = await this.getNetwork();
    const { message, nonce } = input;
    const encoder = new TextEncoder();
    const messageBytes = encoder.encode(message);
    const nonceBytes = encoder.encode(nonce);
    const response = await this.client.signMessage({
      chainId,
      message: messageBytes,
      nonce: nonceBytes,
      signerAddress: connectedAccount.address
    });
    if (response.status === "dismissed") {
      return { status: r4.REJECTED };
    }
    const { fullMessage, signature } = response.args;
    const extraResponseArgs = {
      address: connectedAccount.address.toString(),
      application: "",
      chainId,
      message,
      nonce,
      prefix: "APTOS"
    };
    return {
      args: {
        fullMessage,
        signature,
        ...extraResponseArgs
      },
      status: r4.APPROVED
    };
  }
  async signTransaction(transaction, _asFeePayer) {
    var _a;
    const { connectedAccount } = _AptosConnectWallet2;
    if (!connectedAccount) {
      throw new r3(n9.Unauthorized);
    }
    const feePayer = transaction.feePayerAddress ? { address: transaction.feePayerAddress } : void 0;
    const secondarySigners = (_a = transaction.secondarySignerAddresses) == null ? void 0 : _a.map((address) => ({ address }));
    const response = await this.client.signTransaction({
      feePayer,
      secondarySigners,
      signerAddress: connectedAccount.address,
      transaction: transaction.rawTransaction
    });
    if (response.status === "dismissed") {
      return { status: r4.REJECTED };
    }
    return {
      args: response.args.authenticator,
      status: r4.APPROVED
    };
  }
  async signAndSubmitTransaction(args) {
    const { gasUnitPrice, maxGasAmount, payload } = args;
    const { connectedAccount } = _AptosConnectWallet2;
    if (!connectedAccount) {
      throw new r3(n9.Unauthorized);
    }
    const response = await this.client.signAndSubmitTransaction({
      gasUnitPrice,
      maxGasAmount,
      network: this.aptosClient.config.network,
      payload,
      signerAddress: connectedAccount.address
    });
    if (response.status === "dismissed") {
      return { status: r4.REJECTED };
    }
    const txnResponse = await this.aptosClient.getTransactionByHash({
      transactionHash: response.args.txnHash
    });
    return {
      args: txnResponse,
      status: r4.APPROVED
    };
  }
  // eslint-disable-next-line class-methods-use-this
  async onAccountChange(_callback) {
  }
  // eslint-disable-next-line class-methods-use-this
  async onNetworkChange(_callback) {
  }
  // endregion
};
_AptosConnectWallet.connectedAccountStorageKey = "@aptos-connect/connectedAccount";
var AptosConnectWallet = _AptosConnectWallet;
function convertV1toV2(src, dst) {
  const serializedBytes = bcs_exports.bcsToBytes(src);
  const deserializerV2 = new n2(serializedBytes);
  return dst.deserialize(deserializerV2);
}
function convertPayloadInputFromV1ToV2(inputV1) {
  if ("multisig_address" in inputV1) {
    throw new Error("Multisig payload not supported");
  }
  if ("code" in inputV1) {
    throw new Error("Script payload not supported");
  }
  if ("function" in inputV1) {
    return {
      function: inputV1.function,
      functionArguments: inputV1.arguments,
      typeArguments: inputV1.type_arguments
    };
  }
  throw new Error("Unsupported payload type");
}
function customAccountToStandardAccount2({ address, name, publicKey }) {
  if (publicKey instanceof d || publicKey instanceof f2) {
    throw new Error("Unsupported public key type");
  }
  return {
    address: address.toString(),
    ansName: name,
    publicKey: publicKey.toString()
  };
}
function accountAuthenticatorToTransactionAuthenticator(accountAuthenticator) {
  if (accountAuthenticator instanceof u2) {
    return new o(accountAuthenticator.public_key, accountAuthenticator.signature);
  }
  if (accountAuthenticator instanceof n3) {
    if (accountAuthenticator.isEd25519()) {
      return new o(
        accountAuthenticator.public_key.publicKey,
        accountAuthenticator.signature.signature
      );
    }
    return new A(accountAuthenticator);
  }
  throw new Error("Cannot convert account authenticator to a compatible transaction authenticator");
}
function unwrapUserResponse(response) {
  if (response.status === "dismissed") {
    throw new r3(0, "Rejected");
  }
  return response.args;
}
var _AptosConnectWalletPlugin = class _AptosConnectWalletPlugin2 {
  constructor({ network = e.MAINNET, ...clientConfig }) {
    this.providerName = "open";
    this.version = "v2";
    this.name = walletName;
    this.url = walletUrl;
    this.icon = walletIcon;
    this.client = new ACDappClient(clientConfig);
    if (!o3[network]) {
      throw new Error("Network not supported");
    }
    const aptosConfig = new l({ network });
    this.aptosClient = new t4(aptosConfig);
  }
  static get connectedAccount() {
    const value = localStorage.getItem(_AptosConnectWalletPlugin2.connectedAccountStorageKey);
    return value ? JSON.parse(value) : void 0;
  }
  static set connectedAccount(value) {
    if (value !== void 0) {
      localStorage.setItem(_AptosConnectWalletPlugin2.connectedAccountStorageKey, JSON.stringify(value));
    } else {
      localStorage.removeItem(_AptosConnectWalletPlugin2.connectedAccountStorageKey);
    }
  }
  // endregion
  async connect() {
    const { connectedAccount } = _AptosConnectWalletPlugin2;
    if (connectedAccount !== void 0) {
      return connectedAccount;
    }
    const response = await this.client.connect();
    if (response.status === "dismissed") {
      throw new r3(n9.Unauthorized);
    }
    const newConnectedAccount = customAccountToStandardAccount2(response.args.account);
    _AptosConnectWalletPlugin2.connectedAccount = newConnectedAccount;
    return newConnectedAccount;
  }
  async account() {
    const [firstAccount] = await this.client.getConnectedAccounts();
    if (firstAccount === void 0) {
      throw new r3(n9.Unauthorized);
    }
    return customAccountToStandardAccount2(firstAccount);
  }
  async disconnect() {
    const { connectedAccount } = _AptosConnectWalletPlugin2;
    if (connectedAccount) {
      await this.client.disconnect(connectedAccount.address);
      _AptosConnectWalletPlugin2.connectedAccount = void 0;
    }
  }
  async signAndSubmitTransaction(payloadV1InputOrGenerateTxnInput, optionsV1) {
    const { connectedAccount } = _AptosConnectWalletPlugin2;
    if (!connectedAccount) {
      throw new r3(n9.Unauthorized);
    }
    let payload;
    let options;
    if ("data" in payloadV1InputOrGenerateTxnInput) {
      const { data: payloadV2Input, options: optionsV2 } = payloadV1InputOrGenerateTxnInput;
      payload = payloadV2Input;
      options = {
        expirationTimestamp: optionsV2 == null ? void 0 : optionsV2.expireTimestamp,
        gasUnitPrice: optionsV2 == null ? void 0 : optionsV2.gasUnitPrice,
        maxGasAmount: optionsV2 == null ? void 0 : optionsV2.maxGasAmount,
        network: this.aptosClient.config.network
      };
    } else {
      payload = convertPayloadInputFromV1ToV2(payloadV1InputOrGenerateTxnInput);
      options = {
        expirationTimestamp: optionsV1 == null ? void 0 : optionsV1.expirationTimestamp,
        gasUnitPrice: (optionsV1 == null ? void 0 : optionsV1.gasUnitPrice) ?? (optionsV1 == null ? void 0 : optionsV1.gas_unit_price),
        maxGasAmount: (optionsV1 == null ? void 0 : optionsV1.maxGasAmount) ?? (optionsV1 == null ? void 0 : optionsV1.max_gas_amount),
        network: this.aptosClient.config.network
      };
    }
    const response = await this.client.signAndSubmitTransaction({
      signerAddress: c.from(connectedAccount.address),
      ...options,
      payload
    });
    const { txnHash } = unwrapUserResponse(response);
    return { hash: txnHash };
  }
  async signAndSubmitBCSTransaction(payloadV1, options) {
    const { connectedAccount } = _AptosConnectWalletPlugin2;
    if (!connectedAccount) {
      throw new r3(n9.Unauthorized);
    }
    const payload = convertV1toV2(payloadV1, a);
    const response = await this.client.signAndSubmitTransaction({
      expirationTimestamp: options == null ? void 0 : options.expirationTimestamp,
      gasUnitPrice: (options == null ? void 0 : options.gasUnitPrice) ?? (options == null ? void 0 : options.gas_unit_price),
      maxGasAmount: (options == null ? void 0 : options.maxGasAmount) ?? (options == null ? void 0 : options.max_gas_amount),
      network: this.aptosClient.config.network,
      payload,
      signerAddress: c.from(connectedAccount.address)
    });
    const { txnHash } = unwrapUserResponse(response);
    return { hash: txnHash };
  }
  async signMessage(args) {
    const { connectedAccount } = _AptosConnectWalletPlugin2;
    if (!connectedAccount) {
      throw new r3(n9.Unauthorized);
    }
    const chainId = await this.aptosClient.getChainId();
    const { message, nonce } = args;
    const encoder = new TextEncoder();
    const messageBytes = encoder.encode(message);
    const nonceBytes = encoder.encode(nonce);
    const response = await this.client.signMessage({
      chainId,
      message: messageBytes,
      nonce: nonceBytes,
      signerAddress: c.from(connectedAccount.address)
    });
    const { fullMessage, signature } = unwrapUserResponse(response);
    const extraResponseArgs = {
      address: connectedAccount.address.toString(),
      application: this.client.dappInfo.domain,
      chainId,
      message,
      nonce,
      prefix: "APTOS"
    };
    return {
      fullMessage,
      signature: signature.toString(),
      ...extraResponseArgs
    };
  }
  async signTransaction(transactionOrPayload, optionsOrAsFeePayer) {
    var _a;
    const { connectedAccount } = _AptosConnectWalletPlugin2;
    if (!connectedAccount) {
      throw new r3(n9.Unauthorized);
    }
    if ("rawTransaction" in transactionOrPayload) {
      const transaction = transactionOrPayload;
      const feePayer = transaction.feePayerAddress ? { address: transaction.feePayerAddress } : void 0;
      const secondarySigners = (_a = transaction.secondarySignerAddresses) == null ? void 0 : _a.map((address) => ({ address }));
      const response2 = await this.client.signTransaction({
        feePayer,
        secondarySigners,
        signerAddress: c.from(connectedAccount.address),
        transaction: transaction.rawTransaction
      });
      const { authenticator: authenticator2 } = unwrapUserResponse(response2);
      return authenticator2;
    }
    if (!(transactionOrPayload instanceof aptos_types_exports.TransactionPayload)) {
      throw new Error("Not supported");
    }
    const payload = convertV1toV2(transactionOrPayload, a);
    const options = optionsOrAsFeePayer;
    const sender = (options == null ? void 0 : options.sender) ? {
      address: c.from(options.sender)
    } : void 0;
    const response = await this.client.signTransaction({
      expirationSecondsFromNow: options == null ? void 0 : options.expirationSecondsFromNow,
      expirationTimestamp: options == null ? void 0 : options.expirationTimestamp,
      gasUnitPrice: (options == null ? void 0 : options.gasUnitPrice) ?? (options == null ? void 0 : options.gas_unit_price),
      maxGasAmount: (options == null ? void 0 : options.maxGasAmount) ?? (options == null ? void 0 : options.max_gas_amount),
      network: this.aptosClient.config.network,
      payload,
      sender,
      sequenceNumber: options == null ? void 0 : options.sequenceNumber,
      signerAddress: c.from(connectedAccount.address)
    });
    const { authenticator, rawTransaction } = unwrapUserResponse(response);
    if (rawTransaction === void 0) {
      throw new Error("The wallet did not return a raw transaction");
    }
    const txnAuthenticator = accountAuthenticatorToTransactionAuthenticator(authenticator);
    const signedTransaction = new n4(rawTransaction, txnAuthenticator);
    return signedTransaction.bcsToBytes();
  }
  // eslint-disable-next-line class-methods-use-this
  async onNetworkChange(_callback) {
  }
  // eslint-disable-next-line class-methods-use-this
  async onAccountChange(_callback) {
  }
  async network() {
    const { network } = this.aptosClient.config;
    const chainId = await this.aptosClient.getChainId();
    const url = o3[network];
    return {
      chainId: chainId.toString(),
      name: network,
      url
    };
  }
};
_AptosConnectWalletPlugin.connectedAccountStorageKey = "AptosConnectWalletPlugin.connectedAccount";

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-VHNX2NUR.mjs
var a2 = `
    fragment TokenActivitiesFields on token_activities_v2 {
  after_value
  before_value
  entry_function_id_str
  event_account_address
  event_index
  from_address
  is_fungible_v2
  property_version_v1
  to_address
  token_amount
  token_data_id
  token_standard
  transaction_timestamp
  transaction_version
  type
}
    `;
var i3 = `
    fragment AnsTokenFragment on current_aptos_names {
  domain
  expiration_timestamp
  registered_address
  subdomain
  token_standard
  is_primary
  owner_address
  subdomain_expiration_policy
  domain_expiration_timestamp
}
    `;
var s2 = `
    fragment CurrentTokenOwnershipFields on current_token_ownerships_v2 {
  token_standard
  token_properties_mutated_v1
  token_data_id
  table_type_v1
  storage_id
  property_version_v1
  owner_address
  last_transaction_version
  last_transaction_timestamp
  is_soulbound_v2
  is_fungible_v2
  amount
  current_token_data {
    collection_id
    description
    is_fungible_v2
    largest_property_version_v1
    last_transaction_timestamp
    last_transaction_version
    maximum
    supply
    token_data_id
    token_name
    token_properties
    token_standard
    token_uri
    decimals
    current_collection {
      collection_id
      collection_name
      creator_address
      current_supply
      description
      last_transaction_timestamp
      last_transaction_version
      max_supply
      mutable_description
      mutable_uri
      table_handle_v1
      token_standard
      total_minted_v2
      uri
    }
  }
}
    `;
var _ = `
    query getAccountCoinsCount($address: String) {
  current_fungible_asset_balances_aggregate(
    where: {owner_address: {_eq: $address}}
  ) {
    aggregate {
      count
    }
  }
}
    `;
var u3 = `
    query getAccountCoinsData($where_condition: current_fungible_asset_balances_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_fungible_asset_balances_order_by!]) {
  current_fungible_asset_balances(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    amount
    asset_type
    is_frozen
    is_primary
    last_transaction_timestamp
    last_transaction_version
    owner_address
    storage_id
    token_standard
    metadata {
      token_standard
      symbol
      supply_aggregator_table_key_v1
      supply_aggregator_table_handle_v1
      project_uri
      name
      last_transaction_version
      last_transaction_timestamp
      icon_uri
      decimals
      creator_address
      asset_type
    }
  }
}
    `;
var c3 = `
    query getAccountCollectionsWithOwnedTokens($where_condition: current_collection_ownership_v2_view_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_collection_ownership_v2_view_order_by!]) {
  current_collection_ownership_v2_view(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    current_collection {
      collection_id
      collection_name
      creator_address
      current_supply
      description
      last_transaction_timestamp
      last_transaction_version
      mutable_description
      max_supply
      mutable_uri
      table_handle_v1
      token_standard
      total_minted_v2
      uri
    }
    collection_id
    collection_name
    collection_uri
    creator_address
    distinct_tokens
    last_transaction_version
    owner_address
    single_token_uri
  }
}
    `;
var d4 = `
    query getAccountOwnedTokens($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${s2}`;
var l2 = `
    query getAccountOwnedTokensByTokenData($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${s2}`;
var y2 = `
    query getAccountOwnedTokensFromCollection($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${s2}`;
var p3 = `
    query getAccountTokensCount($where_condition: current_token_ownerships_v2_bool_exp, $offset: Int, $limit: Int) {
  current_token_ownerships_v2_aggregate(
    where: $where_condition
    offset: $offset
    limit: $limit
  ) {
    aggregate {
      count
    }
  }
}
    `;
var m2 = `
    query getAccountTransactionsCount($address: String) {
  account_transactions_aggregate(where: {account_address: {_eq: $address}}) {
    aggregate {
      count
    }
  }
}
    `;
var g = `
    query getChainTopUserTransactions($limit: Int) {
  user_transactions(limit: $limit, order_by: {version: desc}) {
    version
  }
}
    `;
var T2 = `
    query getCollectionData($where_condition: current_collections_v2_bool_exp!) {
  current_collections_v2(where: $where_condition) {
    uri
    total_minted_v2
    token_standard
    table_handle_v1
    mutable_uri
    mutable_description
    max_supply
    collection_id
    collection_name
    creator_address
    current_supply
    description
    last_transaction_timestamp
    last_transaction_version
    cdn_asset_uris {
      cdn_image_uri
      asset_uri
      animation_optimizer_retry_count
      cdn_animation_uri
      cdn_json_uri
      image_optimizer_retry_count
      json_parser_retry_count
      raw_animation_uri
      raw_image_uri
    }
  }
}
    `;
var b = `
    query getCurrentFungibleAssetBalances($where_condition: current_fungible_asset_balances_bool_exp, $offset: Int, $limit: Int) {
  current_fungible_asset_balances(
    where: $where_condition
    offset: $offset
    limit: $limit
  ) {
    amount
    asset_type
    is_frozen
    is_primary
    last_transaction_timestamp
    last_transaction_version
    owner_address
    storage_id
    token_standard
  }
}
    `;
var $ = `
    query getDelegatedStakingActivities($delegatorAddress: String, $poolAddress: String) {
  delegated_staking_activities(
    where: {delegator_address: {_eq: $delegatorAddress}, pool_address: {_eq: $poolAddress}}
  ) {
    amount
    delegator_address
    event_index
    event_type
    pool_address
    transaction_version
  }
}
    `;
var k = `
    query getEvents($where_condition: events_bool_exp, $offset: Int, $limit: Int, $order_by: [events_order_by!]) {
  events(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    account_address
    creation_number
    data
    event_index
    sequence_number
    transaction_block_height
    transaction_version
    type
    indexed_type
  }
}
    `;
var f4 = `
    query getFungibleAssetActivities($where_condition: fungible_asset_activities_bool_exp, $offset: Int, $limit: Int) {
  fungible_asset_activities(
    where: $where_condition
    offset: $offset
    limit: $limit
  ) {
    amount
    asset_type
    block_height
    entry_function_id_str
    event_index
    gas_fee_payer_address
    is_frozen
    is_gas_fee
    is_transaction_success
    owner_address
    storage_id
    storage_refund_amount
    token_standard
    transaction_timestamp
    transaction_version
    type
  }
}
    `;
var h2 = `
    query getFungibleAssetMetadata($where_condition: fungible_asset_metadata_bool_exp, $offset: Int, $limit: Int) {
  fungible_asset_metadata(where: $where_condition, offset: $offset, limit: $limit) {
    icon_uri
    project_uri
    supply_aggregator_table_handle_v1
    supply_aggregator_table_key_v1
    creator_address
    asset_type
    decimals
    last_transaction_timestamp
    last_transaction_version
    name
    symbol
    token_standard
    supply_v2
    maximum_v2
  }
}
    `;
var G = `
    query getNames($offset: Int, $limit: Int, $where_condition: current_aptos_names_bool_exp, $order_by: [current_aptos_names_order_by!]) {
  current_aptos_names(
    limit: $limit
    where: $where_condition
    order_by: $order_by
    offset: $offset
  ) {
    ...AnsTokenFragment
  }
}
    ${i3}`;
var w = `
    query getNumberOfDelegators($where_condition: num_active_delegator_per_pool_bool_exp, $order_by: [num_active_delegator_per_pool_order_by!]) {
  num_active_delegator_per_pool(where: $where_condition, order_by: $order_by) {
    num_active_delegator
    pool_address
  }
}
    `;
var v = `
    query getObjectData($where_condition: current_objects_bool_exp, $offset: Int, $limit: Int, $order_by: [current_objects_order_by!]) {
  current_objects(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    allow_ungated_transfer
    state_key_hash
    owner_address
    object_address
    last_transaction_version
    last_guid_creation_num
    is_deleted
  }
}
    `;
var C = `
    query getProcessorStatus($where_condition: processor_status_bool_exp) {
  processor_status(where: $where_condition) {
    last_success_version
    processor
    last_updated
  }
}
    `;
var A3 = `
    query getTableItemsData($where_condition: table_items_bool_exp!, $offset: Int, $limit: Int, $order_by: [table_items_order_by!]) {
  table_items(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    decoded_key
    decoded_value
    key
    table_handle
    transaction_version
    write_set_change_index
  }
}
    `;
var q = `
    query getTableItemsMetadata($where_condition: table_metadatas_bool_exp!, $offset: Int, $limit: Int, $order_by: [table_metadatas_order_by!]) {
  table_metadatas(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    handle
    key_type
    value_type
  }
}
    `;
var Q = `
    query getTokenActivity($where_condition: token_activities_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [token_activities_v2_order_by!]) {
  token_activities_v2(
    where: $where_condition
    order_by: $order_by
    offset: $offset
    limit: $limit
  ) {
    ...TokenActivitiesFields
  }
}
    ${a2}`;
var x2 = `
    query getCurrentTokenOwnership($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${s2}`;
var D2 = `
    query getTokenData($where_condition: current_token_datas_v2_bool_exp, $offset: Int, $limit: Int, $order_by: [current_token_datas_v2_order_by!]) {
  current_token_datas_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    collection_id
    description
    is_fungible_v2
    largest_property_version_v1
    last_transaction_timestamp
    last_transaction_version
    maximum
    supply
    token_data_id
    token_name
    token_properties
    token_standard
    token_uri
    decimals
    current_collection {
      collection_id
      collection_name
      creator_address
      current_supply
      description
      last_transaction_timestamp
      last_transaction_version
      max_supply
      mutable_description
      mutable_uri
      table_handle_v1
      token_standard
      total_minted_v2
      uri
    }
  }
}
    `;

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-TDGQGILY.mjs
var n10 = class extends Error {
  constructor({ apiType: r30, aptosRequest: t39, aptosResponse: e10 }) {
    super(d5({ apiType: r30, aptosRequest: t39, aptosResponse: e10 })), this.name = "AptosApiError", this.url = e10.url, this.status = e10.status, this.statusText = e10.statusText, this.data = e10.data, this.request = t39;
  }
};
function d5({ apiType: s14, aptosRequest: r30, aptosResponse: t39 }) {
  var _a, _b, _c, _d, _e2, _f, _g;
  let e10 = (_b = (_a = t39.headers) == null ? void 0 : _a.traceparent) == null ? void 0 : _b.split("-")[1], u17 = e10 ? `(trace_id:${e10}) ` : "", a26 = `Request to [${s14}]: ${r30.method} ${t39.url ?? r30.url} ${u17}failed with`;
  return s14 === "Indexer" && ((_e2 = (_d = (_c = t39.data) == null ? void 0 : _c.errors) == null ? void 0 : _d[0]) == null ? void 0 : _e2.message) != null ? `${a26}: ${t39.data.errors[0].message}` : ((_f = t39.data) == null ? void 0 : _f.message) != null && ((_g = t39.data) == null ? void 0 : _g.error_code) != null ? `${a26}: ${JSON.stringify(t39.data)}` : `${a26} status: ${t39.statusText}(code:${t39.status}) and response body: ${l3(t39.data)}`;
}
var i4 = 400;
function l3(s14) {
  let r30 = JSON.stringify(s14);
  return r30.length <= i4 ? r30 : `truncated(original_size:${r30.length}): ${r30.slice(0, i4 / 2)}...${r30.slice(-i4 / 2)}`;
}

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-ZEYOFDIO.mjs
var o9 = "1.27.1";

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-GNFEBKFV.mjs
async function A4(s14, u17) {
  let { url: t39, method: n27, body: i49, contentType: a26, params: o34, overrides: e10, originMethod: R7 } = s14, p16 = { ...e10 == null ? void 0 : e10.HEADERS, "x-aptos-client": `aptos-typescript-sdk/${o9}`, "content-type": a26 ?? "application/json", "x-aptos-typescript-sdk-origin-method": R7 };
  return (e10 == null ? void 0 : e10.AUTH_TOKEN) && (p16.Authorization = `Bearer ${e10 == null ? void 0 : e10.AUTH_TOKEN}`), (e10 == null ? void 0 : e10.API_KEY) && (p16.Authorization = `Bearer ${e10 == null ? void 0 : e10.API_KEY}`), u17.provider({ url: t39, method: n27, body: i49, params: o34, headers: p16, overrides: e10 });
}
async function y3(s14, u17, t39) {
  let { url: n27, path: i49 } = s14, a26 = i49 ? `${n27}/${i49}` : n27, o34 = await A4({ ...s14, url: a26 }, u17.client), e10 = { status: o34.status, statusText: o34.statusText, data: o34.data, headers: o34.headers, config: o34.config, request: o34.request, url: a26 };
  if (e10.status === 401) throw new n10({ apiType: t39, aptosRequest: s14, aptosResponse: e10 });
  if (t39 === "Indexer") {
    let R7 = e10.data;
    if (R7.errors) throw new n10({ apiType: t39, aptosRequest: s14, aptosResponse: e10 });
    e10.data = R7.data;
  } else if ((t39 === "Pepper" || t39 === "Prover") && e10.status >= 400) throw new n10({ apiType: t39, aptosRequest: s14, aptosResponse: e10 });
  if (e10.status >= 200 && e10.status < 300) return e10;
  throw new n10({ apiType: t39, aptosRequest: s14, aptosResponse: e10 });
}

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-I5XQKNOK.mjs
async function r5(e10) {
  let { aptosConfig: t39, overrides: s14, params: n27, contentType: o34, acceptType: i49, path: a26, originMethod: R7, type: d24 } = e10, u17 = t39.getRequestUrl(d24);
  return y3({ url: u17, method: "GET", originMethod: R7, path: a26, contentType: o34, acceptType: i49, params: n27, overrides: { ...t39.clientConfig, ...s14 } }, t39, e10.type);
}
async function m3(e10) {
  var _a, _b;
  let { aptosConfig: t39 } = e10;
  return r5({ ...e10, type: "Fullnode", overrides: { ...t39.clientConfig, ...t39.fullnodeConfig, ...e10.overrides, HEADERS: { ...(_a = t39.clientConfig) == null ? void 0 : _a.HEADERS, ...(_b = t39.fullnodeConfig) == null ? void 0 : _b.HEADERS } } });
}
async function A5(e10) {
  let t39 = [], s14, n27 = e10.params;
  do {
    let o34 = await r5({ type: "Fullnode", aptosConfig: e10.aptosConfig, originMethod: e10.originMethod, path: e10.path, params: n27, overrides: e10.overrides });
    s14 = o34.headers["x-aptos-cursor"], delete o34.headers, t39.push(...o34.data), n27.start = s14;
  } while (s14 != null);
  return t39;
}

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-5IUXBOS5.mjs
async function o10(e10) {
  let { type: t39, originMethod: s14, path: i49, body: r30, acceptType: R7, contentType: f19, params: c16, aptosConfig: n27, overrides: A18 } = e10, d24 = n27.getRequestUrl(t39);
  return y3({ url: d24, method: "POST", originMethod: s14, path: i49, body: r30, contentType: f19, acceptType: R7, params: c16, overrides: A18 }, n27, e10.type);
}
async function q2(e10) {
  var _a, _b;
  let { aptosConfig: t39 } = e10;
  return o10({ ...e10, type: "Fullnode", overrides: { ...t39.clientConfig, ...t39.fullnodeConfig, ...e10.overrides, HEADERS: { ...(_a = t39.clientConfig) == null ? void 0 : _a.HEADERS, ...(_b = t39.fullnodeConfig) == null ? void 0 : _b.HEADERS } } });
}
async function C2(e10) {
  var _a, _b;
  let { aptosConfig: t39 } = e10;
  return o10({ ...e10, type: "Indexer", overrides: { ...t39.clientConfig, ...t39.indexerConfig, ...e10.overrides, HEADERS: { ...(_a = t39.clientConfig) == null ? void 0 : _a.HEADERS, ...(_b = t39.indexerConfig) == null ? void 0 : _b.HEADERS } } });
}
async function m4(e10) {
  var _a, _b, _c;
  let { aptosConfig: t39 } = e10, s14 = { ...t39, clientConfig: { ...t39.clientConfig } };
  return (_a = s14 == null ? void 0 : s14.clientConfig) == null ? true : delete _a.API_KEY, o10({ ...e10, type: "Faucet", overrides: { ...s14.clientConfig, ...s14.faucetConfig, ...e10.overrides, HEADERS: { ...(_b = s14.clientConfig) == null ? void 0 : _b.HEADERS, ...(_c = s14.faucetConfig) == null ? void 0 : _c.HEADERS } } });
}
async function E(e10) {
  return o10({ ...e10, type: "Pepper" });
}
async function a3(e10) {
  return o10({ ...e10, type: "Prover" });
}

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-SONTIUAM.mjs
async function d6(o34) {
  let { aptosConfig: s14 } = o34, { data: e10 } = await m3({ aptosConfig: s14, originMethod: "getLedgerInfo", path: "" });
  return e10;
}
async function C3(o34) {
  let { aptosConfig: s14, limit: e10 } = o34;
  return (await a4({ aptosConfig: s14, query: { query: g, variables: { limit: e10 } }, originMethod: "getChainTopUserTransactions" })).user_transactions;
}
async function a4(o34) {
  let { aptosConfig: s14, query: e10, originMethod: t39 } = o34, { data: r30 } = await C2({ aptosConfig: s14, originMethod: t39 ?? "queryIndexer", path: "", body: e10, overrides: { WITH_CREDENTIALS: false } });
  return r30;
}
async function u4(o34) {
  let { aptosConfig: s14 } = o34;
  return (await a4({ aptosConfig: s14, query: { query: C }, originMethod: "getProcessorStatuses" })).processor_status;
}
async function h3(o34) {
  let s14 = await u4({ aptosConfig: o34.aptosConfig });
  return BigInt(s14[0].last_success_version);
}
async function T3(o34) {
  let { aptosConfig: s14, processorType: e10 } = o34;
  return (await a4({ aptosConfig: s14, query: { query: C, variables: { where_condition: { processor: { _eq: e10 } } } }, originMethod: "getProcessorStatus" })).processor_status[0];
}

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-AH44UPM4.mjs
var n11 = /* @__PURE__ */ new Map();
function m5(r30, e10, t39) {
  return async (...s14) => {
    if (n11.has(e10)) {
      let { value: i49, timestamp: u17 } = n11.get(e10);
      if (t39 === void 0 || Date.now() - u17 <= t39) return i49;
    }
    let a26 = await r30(...s14);
    return n11.set(e10, { value: a26, timestamp: Date.now() }), a26;
  };
}

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-ZOMXBB6Z.mjs
async function c4(n27) {
  return new Promise((e10) => {
    setTimeout(e10, n27);
  });
}
var u5 = () => Math.floor(Date.now() / 1e3);
function a5(n27) {
  let e10 = new Date(n27 * 1e3);
  return e10.setMinutes(0), e10.setSeconds(0), e10.setMilliseconds(0), Math.floor(e10.getTime() / 1e3);
}
function m6(n27) {
  let e10 = n27.replace(/-/g, "+").replace(/_/g, "/"), o34 = e10 + "==".substring(0, (3 - e10.length % 3) % 3);
  return decode(o34);
}

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-L36ZHC7J.mjs
var S = ((O8) => (O8.FULLNODE = "Fullnode", O8.INDEXER = "Indexer", O8.FAUCET = "Faucet", O8.PEPPER = "Pepper", O8.PROVER = "Prover", O8))(S || {});
var o11 = "0x1::aptos_coin::AptosCoin";
var T4 = "APTOS::RawTransaction";
var A6 = "APTOS::RawTransactionWithData";
var E2 = ((_8) => (_8.ACCOUNT_TRANSACTION_PROCESSOR = "account_transactions_processor", _8.DEFAULT = "default_processor", _8.EVENTS_PROCESSOR = "events_processor", _8.FUNGIBLE_ASSET_PROCESSOR = "fungible_asset_processor", _8.STAKE_PROCESSOR = "stake_processor", _8.TOKEN_V2_PROCESSOR = "token_v2_processor", _8.USER_TRANSACTION_PROCESSOR = "user_transaction_processor", _8.OBJECT_PROCESSOR = "objects_processor", _8))(E2 || {});

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-UO52TECC.mjs
async function H(o34) {
  let { aptosConfig: n27, options: t39 } = o34;
  return A5({ aptosConfig: n27, originMethod: "getTransactions", path: "transactions", params: { start: t39 == null ? void 0 : t39.offset, limit: t39 == null ? void 0 : t39.limit } });
}
async function G2(o34) {
  let { aptosConfig: n27 } = o34;
  return m5(async () => {
    let { data: t39 } = await m3({ aptosConfig: n27, originMethod: "getGasPriceEstimation", path: "estimate_gas_price" });
    return t39;
  }, `gas-price-${n27.network}`, 1e3 * 60 * 5)();
}
async function W2(o34) {
  let { aptosConfig: n27, ledgerVersion: t39 } = o34, { data: s14 } = await m3({ aptosConfig: n27, originMethod: "getTransactionByVersion", path: `transactions/by_version/${t39}` });
  return s14;
}
async function y4(o34) {
  let { aptosConfig: n27, transactionHash: t39 } = o34, { data: s14 } = await m3({ aptosConfig: n27, path: `transactions/by_hash/${t39}`, originMethod: "getTransactionByHash" });
  return s14;
}
async function O(o34) {
  let { aptosConfig: n27, transactionHash: t39 } = o34;
  try {
    return (await y4({ aptosConfig: n27, transactionHash: t39 })).type === "pending_transaction";
  } catch (s14) {
    if ((s14 == null ? void 0 : s14.status) === 404) return true;
    throw s14;
  }
}
async function R(o34) {
  let { aptosConfig: n27, transactionHash: t39 } = o34, { data: s14 } = await m3({ aptosConfig: n27, path: `transactions/wait_by_hash/${t39}`, originMethod: "longWaitForTransaction" });
  return s14;
}
async function q3(o34) {
  let { aptosConfig: n27, transactionHash: t39, options: s14 } = o34, r30 = (s14 == null ? void 0 : s14.timeoutSecs) ?? 20, u17 = (s14 == null ? void 0 : s14.checkSuccess) ?? true, e10 = true, p16 = 0, i49, g11, l20 = 200, h19 = 1.5;
  function c16(a26) {
    if (!(a26 instanceof n10) || (g11 = a26, a26.status !== 404 && a26.status >= 400 && a26.status < 500)) throw a26;
  }
  try {
    i49 = await y4({ aptosConfig: n27, transactionHash: t39 }), e10 = i49.type === "pending_transaction";
  } catch (a26) {
    c16(a26);
  }
  if (e10) {
    let a26 = Date.now();
    try {
      i49 = await R({ aptosConfig: n27, transactionHash: t39 }), e10 = i49.type === "pending_transaction";
    } catch (w5) {
      c16(w5);
    }
    p16 = (Date.now() - a26) / 1e3;
  }
  for (; e10 && !(p16 >= r30); ) {
    try {
      if (i49 = await y4({ aptosConfig: n27, transactionHash: t39 }), e10 = i49.type === "pending_transaction", !e10) break;
    } catch (a26) {
      c16(a26);
    }
    await c4(l20), p16 += l20 / 1e3, l20 *= h19;
  }
  if (i49 === void 0) throw g11 || new m7(`Fetching transaction ${t39} failed and timed out after ${r30} seconds`, i49);
  if (i49.type === "pending_transaction") throw new m7(`Transaction ${t39} timed out in pending state after ${r30} seconds`, i49);
  if (!u17) return i49;
  if (!i49.success) throw new T5(`Transaction ${t39} failed with an error: ${i49.vm_status}`, i49);
  return i49;
}
async function z(o34) {
  let { aptosConfig: n27, processorType: t39 } = o34, s14 = BigInt(o34.minimumLedgerVersion), r30 = 3e3, u17 = (/* @__PURE__ */ new Date()).getTime(), e10 = BigInt(-1);
  for (; e10 < s14; ) {
    if ((/* @__PURE__ */ new Date()).getTime() - u17 > r30) throw new Error("waitForLastSuccessIndexerVersionSync timeout");
    if (t39 === void 0 ? e10 = await h3({ aptosConfig: n27 }) : e10 = (await T3({ aptosConfig: n27, processorType: t39 })).last_success_version, e10 >= s14) break;
    await c4(200);
  }
}
var m7 = class extends Error {
  constructor(n27, t39) {
    super(n27), this.lastSubmittedTransaction = t39;
  }
};
var T5 = class extends Error {
  constructor(n27, t39) {
    super(n27), this.transaction = t39;
  }
};
async function U(o34) {
  let { aptosConfig: n27, ledgerVersion: t39, options: s14 } = o34, { data: r30 } = await m3({ aptosConfig: n27, originMethod: "getBlockByVersion", path: `blocks/by_version/${t39}`, params: { with_transactions: s14 == null ? void 0 : s14.withTransactions } });
  return P({ block: r30, ...o34 });
}
async function X(o34) {
  let { aptosConfig: n27, blockHeight: t39, options: s14 } = o34, { data: r30 } = await m3({ aptosConfig: n27, originMethod: "getBlockByHeight", path: `blocks/by_height/${t39}`, params: { with_transactions: s14 == null ? void 0 : s14.withTransactions } });
  return P({ block: r30, ...o34 });
}
async function P(o34) {
  let { aptosConfig: n27, block: t39, options: s14 } = o34;
  if (s14 == null ? void 0 : s14.withTransactions) {
    t39.transactions = t39.transactions ?? [];
    let r30 = t39.transactions[t39.transactions.length - 1], u17 = BigInt(t39.first_version), e10 = BigInt(t39.last_version), p16 = r30 == null ? void 0 : r30.version, i49;
    if (p16 === void 0 ? i49 = u17 - 1n : i49 = BigInt(p16), i49 === e10) return t39;
    let g11 = [], l20 = 100n;
    for (let c16 = i49 + 1n; c16 < e10; c16 += BigInt(100)) g11.push(H({ aptosConfig: n27, options: { offset: c16, limit: Math.min(Number(l20), Number(e10 - c16 + 1n)) } }));
    let h19 = await Promise.all(g11);
    for (let c16 of h19) t39.transactions.push(...c16);
  }
  return t39;
}

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-PY4TS34X.mjs
async function i5(o34) {
  o34.minimumLedgerVersion !== void 0 && await z({ aptosConfig: o34.config, minimumLedgerVersion: o34.minimumLedgerVersion, processorType: o34.processorType });
}

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-MEKXPGK7.mjs
async function b2(t39) {
  let { aptosConfig: a26, handle: e10, data: o34, options: r30 } = t39;
  return (await q2({ aptosConfig: a26, originMethod: "getTableItem", path: `tables/${e10}/item`, params: { ledger_version: r30 == null ? void 0 : r30.ledgerVersion }, body: o34 })).data;
}
async function f5(t39) {
  let { aptosConfig: a26, options: e10 } = t39, o34 = { query: A3, variables: { where_condition: e10 == null ? void 0 : e10.where, offset: e10 == null ? void 0 : e10.offset, limit: e10 == null ? void 0 : e10.limit, order_by: e10 == null ? void 0 : e10.orderBy } };
  return (await a4({ aptosConfig: a26, query: o34, originMethod: "getTableItemsData" })).table_items;
}
async function T6(t39) {
  let { aptosConfig: a26, options: e10 } = t39, o34 = { query: q, variables: { where_condition: e10 == null ? void 0 : e10.where, offset: e10 == null ? void 0 : e10.offset, limit: e10 == null ? void 0 : e10.limit, order_by: e10 == null ? void 0 : e10.orderBy } };
  return (await a4({ aptosConfig: a26, query: o34, originMethod: "getTableItemsMetadata" })).table_metadatas;
}

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-OEOUZFHD.mjs
var a6 = class {
  constructor(e10) {
    this.config = e10;
  }
  async getTableItem(e10) {
    return b2({ aptosConfig: this.config, ...e10 });
  }
  async getTableItemsData(e10) {
    return await i5({ config: this.config, minimumLedgerVersion: e10.minimumLedgerVersion, processorType: "default_processor" }), f5({ aptosConfig: this.config, ...e10 });
  }
  async getTableItemsMetadata(e10) {
    return await i5({ config: this.config, minimumLedgerVersion: e10.minimumLedgerVersion, processorType: "default_processor" }), T6({ aptosConfig: this.config, ...e10 });
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-6EMN3BOV.mjs
function o12(a26, i49, e10) {
  let r30 = e10.value;
  return e10.value = async function(...t39) {
    let [n27] = t39;
    if (n27.transaction.feePayerAddress && !n27.feePayerAuthenticator) throw new Error("You are submitting a Fee Payer transaction but missing the feePayerAuthenticator");
    return r30.apply(this, t39);
  }, e10;
}
function u6(a26, i49, e10) {
  let r30 = e10.value;
  return e10.value = async function(...t39) {
    let [n27] = t39;
    if (n27.transaction.feePayerAddress && !n27.feePayerPublicKey) throw new Error("You are simulating a Fee Payer transaction but missing the feePayerPublicKey");
    return r30.apply(this, t39);
  }, e10;
}

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-LG7RJQ57.mjs
var s3 = class extends Error {
  constructor(e10, i49) {
    super(e10), this.invalidReason = i49;
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-BCUSI3N6.mjs
var l4 = ((e10) => (e10.TOO_SHORT = "too_short", e10.INVALID_LENGTH = "invalid_length", e10.INVALID_HEX_CHARS = "invalid_hex_chars", e10))(l4 || {});
var i6 = class n13 {
  constructor(t39) {
    this.data = t39;
  }
  toUint8Array() {
    return this.data;
  }
  toStringWithoutPrefix() {
    return bytesToHex(this.data);
  }
  toString() {
    return `0x${this.toStringWithoutPrefix()}`;
  }
  static fromHexString(t39) {
    let r30 = t39;
    if (r30.startsWith("0x") && (r30 = r30.slice(2)), r30.length === 0) throw new s3("Hex string is too short, must be at least 1 char long, excluding the optional leading 0x.", "too_short");
    if (r30.length % 2 !== 0) throw new s3("Hex string must be an even number of hex characters.", "invalid_length");
    try {
      return new n13(hexToBytes(r30));
    } catch (e10) {
      throw new s3(`Hex string contains invalid hex characters: ${e10 == null ? void 0 : e10.message}`, "invalid_hex_chars");
    }
  }
  static fromHexInput(t39) {
    return t39 instanceof Uint8Array ? new n13(t39) : n13.fromHexString(t39);
  }
  static isValid(t39) {
    try {
      return n13.fromHexString(t39), { valid: true };
    } catch (r30) {
      return { valid: false, invalidReason: r30 == null ? void 0 : r30.invalidReason, invalidReasonMessage: r30 == null ? void 0 : r30.message };
    }
  }
  equals(t39) {
    return this.data.length !== t39.data.length ? false : this.data.every((r30, e10) => r30 === t39.data[e10]);
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-56CNRT2K.mjs
var t10 = 255;
var n14 = 65535;
var U2 = 4294967295;
var _2 = 18446744073709551615n;
var o13 = 340282366920938463463374607431768211455n;
var i7 = 115792089237316195423570985008687907853269984665640564039457584007913129639935n;

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-FVA2OPG4.mjs
var h4 = Object.defineProperty;
var i8 = Object.getOwnPropertyDescriptor;
var j2 = (g11, b12, d24, c16) => {
  for (var a26 = c16 > 1 ? void 0 : c16 ? i8(b12, d24) : b12, e10 = g11.length - 1, f19; e10 >= 0; e10--) (f19 = g11[e10]) && (a26 = (c16 ? f19(b12, d24, a26) : f19(a26)) || a26);
  return c16 && a26 && h4(b12, d24, a26), a26;
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-A63SMUOU.mjs
var B2 = class {
  bcsToBytes() {
    let e10 = new n15();
    return this.serialize(e10), e10.toUint8Array();
  }
  bcsToHex() {
    let e10 = this.bcsToBytes();
    return i6.fromHexInput(e10);
  }
};
var n15 = class {
  constructor(e10 = 64) {
    if (e10 <= 0) throw new Error("Length needs to be greater than 0");
    this.buffer = new ArrayBuffer(e10), this.offset = 0;
  }
  ensureBufferWillHandleSize(e10) {
    for (; this.buffer.byteLength < this.offset + e10; ) {
      let t39 = new ArrayBuffer(this.buffer.byteLength * 2);
      new Uint8Array(t39).set(new Uint8Array(this.buffer)), this.buffer = t39;
    }
  }
  appendToBuffer(e10) {
    this.ensureBufferWillHandleSize(e10.length), new Uint8Array(this.buffer, this.offset).set(e10), this.offset += e10.length;
  }
  serializeWithFunction(e10, t39, i49) {
    this.ensureBufferWillHandleSize(t39);
    let a26 = new DataView(this.buffer, this.offset);
    e10.apply(a26, [0, i49, true]), this.offset += t39;
  }
  serializeStr(e10) {
    let t39 = new TextEncoder();
    this.serializeBytes(t39.encode(e10));
  }
  serializeBytes(e10) {
    this.serializeU32AsUleb128(e10.length), this.appendToBuffer(e10);
  }
  serializeFixedBytes(e10) {
    this.appendToBuffer(e10);
  }
  serializeBool(e10) {
    A7(e10);
    let t39 = e10 ? 1 : 0;
    this.appendToBuffer(new Uint8Array([t39]));
  }
  serializeU8(e10) {
    this.appendToBuffer(new Uint8Array([e10]));
  }
  serializeU16(e10) {
    this.serializeWithFunction(DataView.prototype.setUint16, 2, e10);
  }
  serializeU32(e10) {
    this.serializeWithFunction(DataView.prototype.setUint32, 4, e10);
  }
  serializeU64(e10) {
    let t39 = BigInt(e10) & BigInt(U2), i49 = BigInt(e10) >> BigInt(32);
    this.serializeU32(Number(t39)), this.serializeU32(Number(i49));
  }
  serializeU128(e10) {
    let t39 = BigInt(e10) & _2, i49 = BigInt(e10) >> BigInt(64);
    this.serializeU64(t39), this.serializeU64(i49);
  }
  serializeU256(e10) {
    let t39 = BigInt(e10) & o13, i49 = BigInt(e10) >> BigInt(128);
    this.serializeU128(t39), this.serializeU128(i49);
  }
  serializeU32AsUleb128(e10) {
    let t39 = e10, i49 = [];
    for (; t39 >>> 7; ) i49.push(t39 & 127 | 128), t39 >>>= 7;
    i49.push(t39), this.appendToBuffer(new Uint8Array(i49));
  }
  toUint8Array() {
    return new Uint8Array(this.buffer).slice(0, this.offset);
  }
  serialize(e10) {
    e10.serialize(this);
  }
  serializeVector(e10) {
    this.serializeU32AsUleb128(e10.length), e10.forEach((t39) => {
      t39.serialize(this);
    });
  }
  serializeOption(e10) {
    let t39 = e10 !== void 0;
    this.serializeBool(t39), t39 && e10.serialize(this);
  }
  serializeOptionStr(e10) {
    e10 === void 0 ? this.serializeU32AsUleb128(0) : (this.serializeU32AsUleb128(1), this.serializeStr(e10));
  }
};
j2([o14(0, t10)], n15.prototype, "serializeU8", 1), j2([o14(0, n14)], n15.prototype, "serializeU16", 1), j2([o14(0, U2)], n15.prototype, "serializeU32", 1), j2([o14(BigInt(0), _2)], n15.prototype, "serializeU64", 1), j2([o14(BigInt(0), o13)], n15.prototype, "serializeU128", 1), j2([o14(BigInt(0), i7)], n15.prototype, "serializeU256", 1), j2([o14(0, U2)], n15.prototype, "serializeU32AsUleb128", 1);
function A7(r30) {
  if (typeof r30 != "boolean") throw new Error(`${r30} is not a boolean value`);
}
var z2 = (r30, e10, t39) => `${r30} is out of range: [${e10}, ${t39}]`;
function g2(r30, e10, t39) {
  let i49 = BigInt(r30);
  if (i49 > BigInt(t39) || i49 < BigInt(e10)) throw new Error(z2(r30, e10, t39));
}
function o14(r30, e10) {
  return (t39, i49, a26) => {
    let p16 = a26.value;
    return a26.value = function(u17) {
      return g2(u17, r30, e10), p16.apply(this, [u17]);
    }, a26;
  };
}

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-YUNDX5I7.mjs
var r6 = class t11 extends B2 {
  constructor(i49) {
    super(), this.identifier = i49;
  }
  serialize(i49) {
    i49.serializeStr(this.identifier);
  }
  static deserialize(i49) {
    let s14 = i49.deserializeStr();
    return new t11(s14);
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-OHRL766V.mjs
var g3 = ((s14) => (s14.INCORRECT_NUMBER_OF_BYTES = "incorrect_number_of_bytes", s14.INVALID_HEX_CHARS = "invalid_hex_chars", s14.TOO_SHORT = "too_short", s14.TOO_LONG = "too_long", s14.LEADING_ZERO_X_REQUIRED = "leading_zero_x_required", s14.LONG_FORM_REQUIRED_UNLESS_SPECIAL = "long_form_required_unless_special", s14.INVALID_PADDING_ZEROES = "INVALID_PADDING_ZEROES", s14))(g3 || {});
var r7 = class r8 extends B2 {
  constructor(t39) {
    if (super(), t39.length !== r8.LENGTH) throw new s3("AccountAddress data should be exactly 32 bytes long", "incorrect_number_of_bytes");
    this.data = t39;
  }
  isSpecial() {
    return this.data.slice(0, this.data.length - 1).every((t39) => t39 === 0) && this.data[this.data.length - 1] < 16;
  }
  toString() {
    return `0x${this.toStringWithoutPrefix()}`;
  }
  toStringWithoutPrefix() {
    let t39 = bytesToHex(this.data);
    return this.isSpecial() && (t39 = t39[t39.length - 1]), t39;
  }
  toStringLong() {
    return `0x${this.toStringLongWithoutPrefix()}`;
  }
  toStringLongWithoutPrefix() {
    return bytesToHex(this.data);
  }
  toUint8Array() {
    return this.data;
  }
  serialize(t39) {
    t39.serializeFixedBytes(this.data);
  }
  serializeForEntryFunction(t39) {
    let e10 = this.bcsToBytes();
    t39.serializeBytes(e10);
  }
  serializeForScriptFunction(t39) {
    t39.serializeU32AsUleb128(3), t39.serialize(this);
  }
  static deserialize(t39) {
    let e10 = t39.deserializeFixedBytes(r8.LENGTH);
    return new r8(e10);
  }
  static fromStringStrict(t39) {
    if (!t39.startsWith("0x")) throw new s3("Hex string must start with a leading 0x.", "leading_zero_x_required");
    let e10 = r8.fromString(t39);
    if (t39.length !== r8.LONG_STRING_LENGTH + 2) if (e10.isSpecial()) {
      if (t39.length !== 3) throw new s3(`The given hex string ${t39} is a special address not in LONG form, it must be 0x0 to 0xf without padding zeroes.`, "INVALID_PADDING_ZEROES");
    } else throw new s3(`The given hex string ${t39} is not a special address, it must be represented as 0x + 64 chars.`, "long_form_required_unless_special");
    return e10;
  }
  static fromString(t39) {
    let e10 = t39;
    if (t39.startsWith("0x") && (e10 = t39.slice(2)), e10.length === 0) throw new s3("Hex string is too short, must be 1 to 64 chars long, excluding the leading 0x.", "too_short");
    if (e10.length > 64) throw new s3("Hex string is too long, must be 1 to 64 chars long, excluding the leading 0x.", "too_long");
    let n27;
    try {
      n27 = hexToBytes(e10.padStart(64, "0"));
    } catch (c16) {
      throw new s3(`Hex characters are invalid: ${c16 == null ? void 0 : c16.message}`, "invalid_hex_chars");
    }
    return new r8(n27);
  }
  static from(t39) {
    return typeof t39 == "string" ? r8.fromString(t39) : t39 instanceof Uint8Array ? new r8(t39) : t39;
  }
  static fromStrict(t39) {
    return typeof t39 == "string" ? r8.fromStringStrict(t39) : t39 instanceof Uint8Array ? new r8(t39) : t39;
  }
  static isValid(t39) {
    try {
      return t39.strict ? r8.fromStrict(t39.input) : r8.from(t39.input), { valid: true };
    } catch (e10) {
      return { valid: false, invalidReason: e10 == null ? void 0 : e10.invalidReason, invalidReasonMessage: e10 == null ? void 0 : e10.message };
    }
  }
  equals(t39) {
    return this.data.length !== t39.data.length ? false : this.data.every((e10, n27) => e10 === t39.data[n27]);
  }
};
r7.LENGTH = 32, r7.LONG_STRING_LENGTH = 64, r7.ZERO = r7.from("0x0"), r7.ONE = r7.from("0x1"), r7.TWO = r7.from("0x2"), r7.THREE = r7.from("0x3"), r7.FOUR = r7.from("0x4"), r7.A = r7.from("0xA");
var d7 = r7;

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-SUJLWCRN.mjs
var t12 = class extends B2 {
  static deserialize(e10) {
    let r30 = e10.deserializeUleb128AsU32();
    switch (r30) {
      case 0:
        return c5.load(e10);
      case 1:
        return u7.load(e10);
      case 2:
        return p4.load(e10);
      case 3:
        return z3.load(e10);
      case 4:
        return S2.load(e10);
      case 5:
        return U3.load(e10);
      case 6:
        return y5.load(e10);
      case 7:
        return b3.load(e10);
      case 8:
        return d8.load(e10);
      case 9:
        return g4.load(e10);
      case 10:
        return T7.load(e10);
      case 255:
        return h5.load(e10);
      default:
        throw new Error(`Unknown variant index for TypeTag: ${r30}`);
    }
  }
  isBool() {
    return this instanceof c5;
  }
  isAddress() {
    return this instanceof S2;
  }
  isGeneric() {
    return this instanceof h5;
  }
  isSigner() {
    return this instanceof U3;
  }
  isVector() {
    return this instanceof y5;
  }
  isStruct() {
    return this instanceof b3;
  }
  isU8() {
    return this instanceof u7;
  }
  isU16() {
    return this instanceof d8;
  }
  isU32() {
    return this instanceof g4;
  }
  isU64() {
    return this instanceof p4;
  }
  isU128() {
    return this instanceof z3;
  }
  isU256() {
    return this instanceof T7;
  }
};
var c5 = class i9 extends t12 {
  toString() {
    return "bool";
  }
  serialize(e10) {
    e10.serializeU32AsUleb128(0);
  }
  static load(e10) {
    return new i9();
  }
};
var u7 = class i10 extends t12 {
  toString() {
    return "u8";
  }
  serialize(e10) {
    e10.serializeU32AsUleb128(1);
  }
  static load(e10) {
    return new i10();
  }
};
var d8 = class i11 extends t12 {
  toString() {
    return "u16";
  }
  serialize(e10) {
    e10.serializeU32AsUleb128(8);
  }
  static load(e10) {
    return new i11();
  }
};
var g4 = class i12 extends t12 {
  toString() {
    return "u32";
  }
  serialize(e10) {
    e10.serializeU32AsUleb128(9);
  }
  static load(e10) {
    return new i12();
  }
};
var p4 = class i13 extends t12 {
  toString() {
    return "u64";
  }
  serialize(e10) {
    e10.serializeU32AsUleb128(2);
  }
  static load(e10) {
    return new i13();
  }
};
var z3 = class i14 extends t12 {
  toString() {
    return "u128";
  }
  serialize(e10) {
    e10.serializeU32AsUleb128(3);
  }
  static load(e10) {
    return new i14();
  }
};
var T7 = class i15 extends t12 {
  toString() {
    return "u256";
  }
  serialize(e10) {
    e10.serializeU32AsUleb128(10);
  }
  static load(e10) {
    return new i15();
  }
};
var S2 = class i16 extends t12 {
  toString() {
    return "address";
  }
  serialize(e10) {
    e10.serializeU32AsUleb128(4);
  }
  static load(e10) {
    return new i16();
  }
};
var U3 = class i17 extends t12 {
  toString() {
    return "signer";
  }
  serialize(e10) {
    e10.serializeU32AsUleb128(5);
  }
  static load(e10) {
    return new i17();
  }
};
var x3 = class i18 extends t12 {
  constructor(r30) {
    super();
    this.value = r30;
  }
  toString() {
    return `&${this.value.toString()}`;
  }
  serialize(r30) {
    r30.serializeU32AsUleb128(254);
  }
  static load(r30) {
    let s14 = t12.deserialize(r30);
    return new i18(s14);
  }
};
var h5 = class i19 extends t12 {
  constructor(r30) {
    super();
    this.value = r30;
    if (r30 < 0) throw new Error("Generic type parameter index cannot be negative");
  }
  toString() {
    return `T${this.value}`;
  }
  serialize(r30) {
    r30.serializeU32AsUleb128(255), r30.serializeU32(this.value);
  }
  static load(r30) {
    let s14 = r30.deserializeU32();
    return new i19(s14);
  }
};
var y5 = class i20 extends t12 {
  constructor(r30) {
    super();
    this.value = r30;
  }
  toString() {
    return `vector<${this.value.toString()}>`;
  }
  static u8() {
    return new i20(new u7());
  }
  serialize(r30) {
    r30.serializeU32AsUleb128(6), this.value.serialize(r30);
  }
  static load(r30) {
    let s14 = t12.deserialize(r30);
    return new i20(s14);
  }
};
var b3 = class i21 extends t12 {
  constructor(r30) {
    super();
    this.value = r30;
  }
  toString() {
    let r30 = "";
    return this.value.typeArgs.length > 0 && (r30 = `<${this.value.typeArgs.map((s14) => s14.toString()).join(", ")}>`), `${this.value.address.toString()}::${this.value.moduleName.identifier}::${this.value.name.identifier}${r30}`;
  }
  serialize(r30) {
    r30.serializeU32AsUleb128(7), this.value.serialize(r30);
  }
  static load(r30) {
    let s14 = o15.deserialize(r30);
    return new i21(s14);
  }
  isTypeTag(r30, s14, l20) {
    return this.value.moduleName.identifier === s14 && this.value.name.identifier === l20 && this.value.address.equals(r30);
  }
  isString() {
    return this.isTypeTag(d7.ONE, "string", "String");
  }
  isOption() {
    return this.isTypeTag(d7.ONE, "option", "Option");
  }
  isObject() {
    return this.isTypeTag(d7.ONE, "object", "Object");
  }
};
var o15 = class i22 extends B2 {
  constructor(e10, r30, s14, l20) {
    super(), this.address = e10, this.moduleName = r30, this.name = s14, this.typeArgs = l20;
  }
  serialize(e10) {
    e10.serialize(this.address), e10.serialize(this.moduleName), e10.serialize(this.name), e10.serializeVector(this.typeArgs);
  }
  static deserialize(e10) {
    let r30 = d7.deserialize(e10), s14 = r6.deserialize(e10), l20 = r6.deserialize(e10), f19 = e10.deserializeVector(t12);
    return new i22(r30, s14, l20, f19);
  }
};
function E3() {
  return new o15(d7.ONE, new r6("string"), new r6("String"), []);
}
function j3(i49) {
  return new o15(d7.ONE, new r6("object"), new r6("Object"), [i49]);
}

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-NWOMSL6K.mjs
function V(e10) {
  return !!e10.match(/^[_a-zA-Z0-9]+$/);
}
function W3(e10) {
  return !!e10.match(/\s/);
}
function $2(e10) {
  return !!e10.match(/^T[0-9]+$/);
}
function F(e10) {
  return !!e10.match(/^&.+$/);
}
function k2(e10) {
  switch (e10) {
    case "signer":
    case "address":
    case "bool":
    case "u8":
    case "u16":
    case "u32":
    case "u64":
    case "u128":
    case "u256":
      return true;
    default:
      return false;
  }
}
function L(e10, i49) {
  let c16 = i49;
  for (; c16 < e10.length; c16 += 1) {
    let s14 = e10[c16];
    if (!W3(s14)) break;
  }
  return c16;
}
var R2 = ((a26) => (a26.InvalidTypeTag = "unknown type", a26.UnexpectedGenericType = "unexpected generic type", a26.UnexpectedTypeArgumentClose = "unexpected '>'", a26.UnexpectedWhitespaceCharacter = "unexpected whitespace character", a26.UnexpectedComma = "unexpected ','", a26.TypeArgumentCountMismatch = "type argument count doesn't match expected amount", a26.MissingTypeArgumentClose = "no matching '>' for '<'", a26.MissingTypeArgument = "no type argument before ','", a26.UnexpectedPrimitiveTypeArguments = "primitive types not expected to have type arguments", a26.UnexpectedVectorTypeArgumentCount = "vector type expected to have exactly one type argument", a26.UnexpectedStructFormat = "unexpected struct format, must be of the form 0xaddress::module_name::struct_name", a26.InvalidModuleNameCharacter = "module name must only contain alphanumeric or '_' characters", a26.InvalidStructNameCharacter = "struct name must only contain alphanumeric or '_' characters", a26.InvalidAddress = "struct address must be valid", a26))(R2 || {});
var t13 = class extends Error {
  constructor(i49, c16) {
    super(`Failed to parse typeTag '${i49}', ${c16}`);
  }
};
function j4(e10, i49) {
  let c16 = (i49 == null ? void 0 : i49.allowGenerics) ?? false, s14 = [], u17 = [], n27 = [], o34 = 0, r30 = "", T13 = 1;
  for (; o34 < e10.length; ) {
    let d24 = e10[o34];
    if (d24 === "<") s14.push({ savedExpectedTypes: T13, savedStr: r30, savedTypes: n27 }), r30 = "", n27 = [], T13 = 1;
    else if (d24 === ">") {
      if (r30 !== "") {
        let a26 = g5(r30, u17, c16);
        n27.push(a26);
      }
      let p16 = s14.pop();
      if (p16 === void 0) throw new t13(e10, "unexpected '>'");
      if (T13 !== n27.length) throw new t13(e10, "type argument count doesn't match expected amount");
      let { savedStr: m17, savedTypes: h19, savedExpectedTypes: _8 } = p16;
      u17 = n27, n27 = h19, r30 = m17, T13 = _8;
    } else if (d24 === ",") {
      if (s14.length === 0) throw new t13(e10, "unexpected ','");
      if (r30.length === 0) throw new t13(e10, "no type argument before ','");
      let p16 = g5(r30, u17, c16);
      u17 = [], n27.push(p16), r30 = "", T13 += 1;
    } else if (W3(d24)) {
      let p16 = false;
      if (r30.length !== 0) {
        let h19 = g5(r30, u17, c16);
        u17 = [], n27.push(h19), r30 = "", p16 = true;
      }
      o34 = L(e10, o34);
      let m17 = e10[o34];
      if (o34 < e10.length && p16 && m17 !== "," && m17 !== ">") throw new t13(e10, "unexpected whitespace character");
      continue;
    } else r30 += d24;
    o34 += 1;
  }
  if (s14.length > 0) throw new t13(e10, "no matching '>' for '<'");
  switch (n27.length) {
    case 0:
      return g5(r30, u17, c16);
    case 1:
      if (r30 === "") return n27[0];
      throw new t13(e10, "unexpected ','");
    default:
      throw new t13(e10, "unexpected whitespace character");
  }
}
function g5(e10, i49, c16) {
  let s14 = e10.trim(), u17 = s14.toLowerCase();
  if (k2(u17) && i49.length > 0) throw new t13(e10, "primitive types not expected to have type arguments");
  switch (s14.toLowerCase()) {
    case "signer":
      return new U3();
    case "bool":
      return new c5();
    case "address":
      return new S2();
    case "u8":
      return new u7();
    case "u16":
      return new d8();
    case "u32":
      return new g4();
    case "u64":
      return new p4();
    case "u128":
      return new z3();
    case "u256":
      return new T7();
    case "vector":
      if (i49.length !== 1) throw new t13(e10, "vector type expected to have exactly one type argument");
      return new y5(i49[0]);
    default:
      if (F(s14)) {
        let r30 = s14.substring(1);
        return new x3(g5(r30, i49, c16));
      }
      if ($2(s14)) {
        if (c16) return new h5(Number(s14.split("T")[1]));
        throw new t13(e10, "unexpected generic type");
      }
      if (!s14.match(/:/)) throw new t13(e10, "unknown type");
      let n27 = s14.split("::");
      if (n27.length !== 3) throw new t13(e10, "unexpected struct format, must be of the form 0xaddress::module_name::struct_name");
      let o34;
      try {
        o34 = d7.fromString(n27[0]);
      } catch {
        throw new t13(e10, "struct address must be valid");
      }
      if (!V(n27[1])) throw new t13(e10, "module name must only contain alphanumeric or '_' characters");
      if (!V(n27[2])) throw new t13(e10, "struct name must only contain alphanumeric or '_' characters");
      return new b3(new o15(o34, new r6(n27[1]), new r6(n27[2]), i49));
  }
}

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-H6YNXJNF.mjs
var t14 = class a7 extends B2 {
  constructor(e10) {
    super(), this.value = i6.fromHexInput(e10).toUint8Array();
  }
  serialize(e10) {
    e10.serializeFixedBytes(this.value);
  }
  serializeForEntryFunction(e10) {
    e10.serialize(this);
  }
  serializeForScriptFunction(e10) {
    e10.serialize(this);
  }
  static deserialize(e10, s14) {
    let o34 = e10.deserializeFixedBytes(s14);
    return new a7(o34);
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-YPHH6CAO.mjs
var d9 = class i23 extends B2 {
  constructor(e10) {
    super(), A7(e10), this.value = e10;
  }
  serialize(e10) {
    e10.serializeBool(this.value);
  }
  serializeForEntryFunction(e10) {
    let r30 = this.bcsToBytes();
    e10.serializeBytes(r30);
  }
  serializeForScriptFunction(e10) {
    e10.serializeU32AsUleb128(5), e10.serialize(this);
  }
  static deserialize(e10) {
    return new i23(e10.deserializeBool());
  }
};
var U4 = class i24 extends B2 {
  constructor(e10) {
    super(), g2(e10, 0, t10), this.value = e10;
  }
  serialize(e10) {
    e10.serializeU8(this.value);
  }
  serializeForEntryFunction(e10) {
    let r30 = this.bcsToBytes();
    e10.serializeBytes(r30);
  }
  serializeForScriptFunction(e10) {
    e10.serializeU32AsUleb128(0), e10.serialize(this);
  }
  static deserialize(e10) {
    return new i24(e10.deserializeU8());
  }
};
var p5 = class i25 extends B2 {
  constructor(e10) {
    super(), g2(e10, 0, n14), this.value = e10;
  }
  serialize(e10) {
    e10.serializeU16(this.value);
  }
  serializeForEntryFunction(e10) {
    let r30 = this.bcsToBytes();
    e10.serializeBytes(r30);
  }
  serializeForScriptFunction(e10) {
    e10.serializeU32AsUleb128(6), e10.serialize(this);
  }
  static deserialize(e10) {
    return new i25(e10.deserializeU16());
  }
};
var b4 = class i26 extends B2 {
  constructor(e10) {
    super(), g2(e10, 0, U2), this.value = e10;
  }
  serialize(e10) {
    e10.serializeU32(this.value);
  }
  serializeForEntryFunction(e10) {
    let r30 = this.bcsToBytes();
    e10.serializeBytes(r30);
  }
  serializeForScriptFunction(e10) {
    e10.serializeU32AsUleb128(7), e10.serialize(this);
  }
  static deserialize(e10) {
    return new i26(e10.deserializeU32());
  }
};
var y6 = class i27 extends B2 {
  constructor(e10) {
    super(), g2(e10, BigInt(0), _2), this.value = BigInt(e10);
  }
  serialize(e10) {
    e10.serializeU64(this.value);
  }
  serializeForEntryFunction(e10) {
    let r30 = this.bcsToBytes();
    e10.serializeBytes(r30);
  }
  serializeForScriptFunction(e10) {
    e10.serializeU32AsUleb128(1), e10.serialize(this);
  }
  static deserialize(e10) {
    return new i27(e10.deserializeU64());
  }
};
var m8 = class i28 extends B2 {
  constructor(e10) {
    super(), g2(e10, BigInt(0), o13), this.value = BigInt(e10);
  }
  serialize(e10) {
    e10.serializeU128(this.value);
  }
  serializeForEntryFunction(e10) {
    let r30 = this.bcsToBytes();
    e10.serializeBytes(r30);
  }
  serializeForScriptFunction(e10) {
    e10.serializeU32AsUleb128(2), e10.serialize(this);
  }
  static deserialize(e10) {
    return new i28(e10.deserializeU128());
  }
};
var B3 = class i29 extends B2 {
  constructor(e10) {
    super(), g2(e10, BigInt(0), i7), this.value = BigInt(e10);
  }
  serialize(e10) {
    e10.serializeU256(this.value);
  }
  serializeForEntryFunction(e10) {
    let r30 = this.bcsToBytes();
    e10.serializeBytes(r30);
  }
  serializeForScriptFunction(e10) {
    e10.serializeU32AsUleb128(8), e10.serialize(this);
  }
  static deserialize(e10) {
    return new i29(e10.deserializeU256());
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-KMJ6TF6Y.mjs
var t15 = class n16 extends B2 {
  constructor(e10) {
    super(), this.values = e10;
  }
  serializeForEntryFunction(e10) {
    let r30 = this.bcsToBytes();
    e10.serializeBytes(r30);
  }
  serializeForScriptFunction(e10) {
    if (!(this.values[0] instanceof U4) && this.values[0] !== void 0) throw new Error("Script function arguments only accept u8 vectors");
    e10.serializeU32AsUleb128(4), e10.serialize(this);
  }
  static U8(e10) {
    let r30;
    if (Array.isArray(e10) && e10.length === 0) r30 = [];
    else if (Array.isArray(e10) && typeof e10[0] == "number") r30 = e10;
    else if (typeof e10 == "string") {
      let i49 = i6.fromHexInput(e10);
      r30 = Array.from(i49.toUint8Array());
    } else if (e10 instanceof Uint8Array) r30 = Array.from(e10);
    else throw new Error("Invalid input type, must be an number[], Uint8Array, or hex string");
    return new n16(r30.map((i49) => new U4(i49)));
  }
  static U16(e10) {
    return new n16(e10.map((r30) => new p5(r30)));
  }
  static U32(e10) {
    return new n16(e10.map((r30) => new b4(r30)));
  }
  static U64(e10) {
    return new n16(e10.map((r30) => new y6(r30)));
  }
  static U128(e10) {
    return new n16(e10.map((r30) => new m8(r30)));
  }
  static U256(e10) {
    return new n16(e10.map((r30) => new B3(r30)));
  }
  static Bool(e10) {
    return new n16(e10.map((r30) => new d9(r30)));
  }
  static MoveString(e10) {
    return new n16(e10.map((r30) => new a8(r30)));
  }
  serialize(e10) {
    e10.serializeVector(this.values);
  }
  static deserialize(e10, r30) {
    let i49 = e10.deserializeUleb128AsU32(), y14 = new Array();
    for (let p16 = 0; p16 < i49; p16 += 1) y14.push(r30.deserialize(e10));
    return new n16(y14);
  }
};
var a8 = class n17 extends B2 {
  constructor(e10) {
    super(), this.value = e10;
  }
  serialize(e10) {
    e10.serializeStr(this.value);
  }
  serializeForEntryFunction(e10) {
    let r30 = this.bcsToBytes();
    e10.serializeBytes(r30);
  }
  serializeForScriptFunction(e10) {
    let r30 = this.bcsToBytes().slice(1);
    t15.U8(r30).serializeForScriptFunction(e10);
  }
  static deserialize(e10) {
    return new n17(e10.deserializeStr());
  }
};
var z4 = class n18 extends B2 {
  constructor(e10) {
    super(), typeof e10 < "u" && e10 !== null ? this.vec = new t15([e10]) : this.vec = new t15([]), [this.value] = this.vec.values;
  }
  serializeForEntryFunction(e10) {
    let r30 = this.bcsToBytes();
    e10.serializeBytes(r30);
  }
  unwrap() {
    if (this.isSome()) return this.vec.values[0];
    throw new Error("Called unwrap on a MoveOption with no value");
  }
  isSome() {
    return this.vec.values.length === 1;
  }
  serialize(e10) {
    this.vec.serialize(e10);
  }
  static U8(e10) {
    return new n18(e10 != null ? new U4(e10) : void 0);
  }
  static U16(e10) {
    return new n18(e10 != null ? new p5(e10) : void 0);
  }
  static U32(e10) {
    return new n18(e10 != null ? new b4(e10) : void 0);
  }
  static U64(e10) {
    return new n18(e10 != null ? new y6(e10) : void 0);
  }
  static U128(e10) {
    return new n18(e10 != null ? new m8(e10) : void 0);
  }
  static U256(e10) {
    return new n18(e10 != null ? new B3(e10) : void 0);
  }
  static Bool(e10) {
    return new n18(e10 != null ? new d9(e10) : void 0);
  }
  static MoveString(e10) {
    return new n18(e10 != null ? new a8(e10) : void 0);
  }
  static deserialize(e10, r30) {
    let i49 = t15.deserialize(e10, r30);
    return new n18(i49.values[0]);
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-G7UNU5GI.mjs
function D3(n27) {
  return typeof n27 == "boolean";
}
function l5(n27) {
  return typeof n27 == "string";
}
function d10(n27) {
  return typeof n27 == "number";
}
function P2(n27) {
  if (d10(n27)) return n27;
  if (l5(n27) && n27 !== "") return Number.parseInt(n27, 10);
}
function w2(n27) {
  return typeof n27 == "number" || typeof n27 == "bigint" || typeof n27 == "string";
}
function G3(n27) {
  return n27 == null;
}
function $3(n27) {
  return T8(n27) || B4(n27) || U5(n27) || b5(n27) || I(n27) || v2(n27) || h6(n27) || E4(n27) || x4(n27) || S3(n27) || n27 instanceof t15 || n27 instanceof z4;
}
function T8(n27) {
  return n27 instanceof d9;
}
function E4(n27) {
  return n27 instanceof d7;
}
function x4(n27) {
  return n27 instanceof a8;
}
function S3(n27) {
  return n27 instanceof t14;
}
function B4(n27) {
  return n27 instanceof U4;
}
function U5(n27) {
  return n27 instanceof p5;
}
function b5(n27) {
  return n27 instanceof b4;
}
function I(n27) {
  return n27 instanceof y6;
}
function v2(n27) {
  return n27 instanceof m8;
}
function h6(n27) {
  return n27 instanceof B3;
}
function O2(n27) {
  return "bytecode" in n27;
}
function R3(n27, t39) {
  throw new Error(`Type mismatch for argument ${t39}, expected '${n27}'`);
}
function W4(n27) {
  let t39 = n27.params.findIndex((e10) => e10 !== "signer" && e10 !== "&signer");
  return t39 < 0 ? n27.params.length : t39;
}
function L2(n27) {
  let t39 = n27.split("::");
  if (t39.length !== 3) throw new Error(`Invalid function ${n27}`);
  let e10 = t39[0], F8 = t39[1], A18 = t39[2];
  return { moduleAddress: e10, moduleName: F8, functionName: A18 };
}

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-YDZBU2DJ.mjs
var o16 = class t16 extends B2 {
  constructor(e10, r30) {
    super(), this.address = e10, this.name = r30;
  }
  static fromStr(e10) {
    let r30 = e10.split("::");
    if (r30.length !== 2) throw new Error("Invalid module id.");
    return new t16(d7.fromString(r30[0]), new r6(r30[1]));
  }
  serialize(e10) {
    this.address.serialize(e10), this.name.serialize(e10);
  }
  static deserialize(e10) {
    let r30 = d7.deserialize(e10), n27 = r6.deserialize(e10);
    return new t16(r30, n27);
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-P5V7OZNN.mjs
var t17 = class l6 extends B2 {
  constructor(e10) {
    super(), this.value = new t14(e10);
  }
  serialize(e10) {
    e10.serialize(this.value);
  }
  serializeForEntryFunction(e10) {
    e10.serializeU32AsUleb128(this.value.value.length), e10.serialize(this);
  }
  static deserialize(e10, s14) {
    let a26 = t14.deserialize(e10, s14);
    return new l6(a26.value);
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-LDTF3ABK.mjs
function D4(t39) {
  let e10 = t39.deserializeUleb128AsU32();
  switch (e10) {
    case 0:
      return U4.deserialize(t39);
    case 1:
      return y6.deserialize(t39);
    case 2:
      return m8.deserialize(t39);
    case 3:
      return d7.deserialize(t39);
    case 4:
      return t15.deserialize(t39, U4);
    case 5:
      return d9.deserialize(t39);
    case 6:
      return p5.deserialize(t39);
    case 7:
      return b4.deserialize(t39);
    case 8:
      return B3.deserialize(t39);
    default:
      throw new Error(`Unknown variant index for ScriptTransactionArgument: ${e10}`);
  }
}
var a9 = class extends B2 {
  static deserialize(e10) {
    let r30 = e10.deserializeUleb128AsU32();
    switch (r30) {
      case 0:
        return A8.load(e10);
      case 2:
        return z5.load(e10);
      case 3:
        return h7.load(e10);
      default:
        throw new Error(`Unknown variant index for TransactionPayload: ${r30}`);
    }
  }
};
var A8 = class t18 extends a9 {
  constructor(e10) {
    super(), this.script = e10;
  }
  serialize(e10) {
    e10.serializeU32AsUleb128(0), this.script.serialize(e10);
  }
  static load(e10) {
    let r30 = U6.deserialize(e10);
    return new t18(r30);
  }
};
var z5 = class t19 extends a9 {
  constructor(e10) {
    super(), this.entryFunction = e10;
  }
  serialize(e10) {
    e10.serializeU32AsUleb128(2), this.entryFunction.serialize(e10);
  }
  static load(e10) {
    let r30 = l7.deserialize(e10);
    return new t19(r30);
  }
};
var h7 = class t20 extends a9 {
  constructor(e10) {
    super(), this.multiSig = e10;
  }
  serialize(e10) {
    e10.serializeU32AsUleb128(3), this.multiSig.serialize(e10);
  }
  static load(e10) {
    let r30 = f6.deserialize(e10);
    return new t20(r30);
  }
};
var l7 = class t21 {
  constructor(e10, r30, i49, n27) {
    this.module_name = e10, this.function_name = r30, this.type_args = i49, this.args = n27;
  }
  static build(e10, r30, i49, n27) {
    return new t21(o16.fromStr(e10), new r6(r30), i49, n27);
  }
  serialize(e10) {
    this.module_name.serialize(e10), this.function_name.serialize(e10), e10.serializeVector(this.type_args), e10.serializeU32AsUleb128(this.args.length), this.args.forEach((r30) => {
      r30.serializeForEntryFunction(e10);
    });
  }
  static deserialize(e10) {
    let r30 = o16.deserialize(e10), i49 = r6.deserialize(e10), n27 = e10.deserializeVector(t12), o34 = e10.deserializeUleb128AsU32(), s14 = new Array();
    for (let c16 = 0; c16 < o34; c16 += 1) {
      let M5 = e10.deserializeUleb128AsU32(), B10 = t17.deserialize(e10, M5);
      s14.push(B10);
    }
    return new t21(r30, i49, n27, s14);
  }
};
var U6 = class t22 {
  constructor(e10, r30, i49) {
    this.bytecode = e10, this.type_args = r30, this.args = i49;
  }
  serialize(e10) {
    e10.serializeBytes(this.bytecode), e10.serializeVector(this.type_args), e10.serializeU32AsUleb128(this.args.length), this.args.forEach((r30) => {
      r30.serializeForScriptFunction(e10);
    });
  }
  static deserialize(e10) {
    let r30 = e10.deserializeBytes(), i49 = e10.deserializeVector(t12), n27 = e10.deserializeUleb128AsU32(), o34 = new Array();
    for (let s14 = 0; s14 < n27; s14 += 1) {
      let c16 = D4(e10);
      o34.push(c16);
    }
    return new t22(r30, i49, o34);
  }
};
var f6 = class t23 {
  constructor(e10, r30) {
    this.multisig_address = e10, this.transaction_payload = r30;
  }
  serialize(e10) {
    this.multisig_address.serialize(e10), this.transaction_payload === void 0 ? e10.serializeBool(false) : (e10.serializeBool(true), this.transaction_payload.serialize(e10));
  }
  static deserialize(e10) {
    let r30 = d7.deserialize(e10), i49 = e10.deserializeBool(), n27;
    return i49 && (n27 = b6.deserialize(e10)), new t23(r30, n27);
  }
};
var b6 = class t24 extends B2 {
  constructor(e10) {
    super(), this.transaction_payload = e10;
  }
  serialize(e10) {
    e10.serializeU32AsUleb128(0), this.transaction_payload.serialize(e10);
  }
  static deserialize(e10) {
    return e10.deserializeUleb128AsU32(), new t24(l7.deserialize(e10));
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-BOYYQAB4.mjs
var r9 = class a10 extends B2 {
  constructor(e10) {
    super(), this.chainId = e10;
  }
  serialize(e10) {
    e10.serializeU8(this.chainId);
  }
  static deserialize(e10) {
    let s14 = e10.deserializeU8();
    return new a10(s14);
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-GXTEJ7NO.mjs
var t25 = class i30 extends B2 {
  constructor(e10, s14, a26, r30, c16, d24, l20) {
    super(), this.sender = e10, this.sequence_number = s14, this.payload = a26, this.max_gas_amount = r30, this.gas_unit_price = c16, this.expiration_timestamp_secs = d24, this.chain_id = l20;
  }
  serialize(e10) {
    this.sender.serialize(e10), e10.serializeU64(this.sequence_number), this.payload.serialize(e10), e10.serializeU64(this.max_gas_amount), e10.serializeU64(this.gas_unit_price), e10.serializeU64(this.expiration_timestamp_secs), this.chain_id.serialize(e10);
  }
  static deserialize(e10) {
    let s14 = d7.deserialize(e10), a26 = e10.deserializeU64(), r30 = a9.deserialize(e10), c16 = e10.deserializeU64(), d24 = e10.deserializeU64(), l20 = e10.deserializeU64(), m17 = r9.deserialize(e10);
    return new i30(s14, a26, r30, c16, d24, l20, m17);
  }
};
var o17 = class extends B2 {
  static deserialize(e10) {
    let s14 = e10.deserializeUleb128AsU32();
    switch (s14) {
      case 0:
        return u8.load(e10);
      case 1:
        return p6.load(e10);
      default:
        throw new Error(`Unknown variant index for RawTransactionWithData: ${s14}`);
    }
  }
};
var u8 = class i31 extends o17 {
  constructor(e10, s14) {
    super(), this.raw_txn = e10, this.secondary_signer_addresses = s14;
  }
  serialize(e10) {
    e10.serializeU32AsUleb128(0), this.raw_txn.serialize(e10), e10.serializeVector(this.secondary_signer_addresses);
  }
  static load(e10) {
    let s14 = t25.deserialize(e10), a26 = e10.deserializeVector(d7);
    return new i31(s14, a26);
  }
};
var p6 = class i32 extends o17 {
  constructor(e10, s14, a26) {
    super(), this.raw_txn = e10, this.secondary_signer_addresses = s14, this.fee_payer_address = a26;
  }
  serialize(e10) {
    e10.serializeU32AsUleb128(1), this.raw_txn.serialize(e10), e10.serializeVector(this.secondary_signer_addresses), this.fee_payer_address.serialize(e10);
  }
  static load(e10) {
    let s14 = t25.deserialize(e10), a26 = e10.deserializeVector(d7), r30 = d7.deserialize(e10);
    return new i32(s14, a26, r30);
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-3NRBTP3S.mjs
function d11(e10) {
  return e10.feePayerAddress ? new p6(e10.rawTransaction, e10.secondarySignerAddresses ?? [], e10.feePayerAddress) : e10.secondarySignerAddresses ? new u8(e10.rawTransaction, e10.secondarySignerAddresses) : e10.rawTransaction;
}
function n19(e10, r30) {
  let i49 = sha3_256.create();
  if (!r30.startsWith("APTOS::")) throw new Error(`Domain separator needs to start with 'APTOS::'.  Provided - ${r30}`);
  i49.update(r30);
  let s14 = i49.digest(), o34 = e10, t39 = new Uint8Array(s14.length + o34.length);
  return t39.set(s14), t39.set(o34, s14.length), t39;
}
function S4(e10) {
  let r30 = d11(e10);
  return e10.feePayerAddress ? n19(r30.bcsToBytes(), A6) : e10.secondarySignerAddresses ? n19(r30.bcsToBytes(), A6) : n19(r30.bcsToBytes(), T4);
}

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-76OH2Z4Q.mjs
var t26 = class extends B2 {
  toString() {
    let n27 = this.toUint8Array();
    return i6.fromHexInput(n27).toString();
  }
};
var a11 = class extends t26 {
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-MLDQ2TY2.mjs
var o18 = class extends B2 {
  toString() {
    let i49 = this.toUint8Array();
    return i6.fromHexInput(i49).toString();
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-F7EMGK4M.mjs
var o19 = (r30) => typeof r30 == "string" ? i6.isValid(r30).valid ? r30 : Buffer.from(r30, "utf8") : r30;

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-LR65XHSF.mjs
var d12 = /^m\/44'\/637'\/[0-9]+'\/[0-9]+'\/[0-9]+'?$/;
var m9 = /^m\/44'\/637'\/[0-9]+'\/[0-9]+\/[0-9]+$/;
var y7 = ((t39) => (t39.ED25519 = "ed25519 seed", t39))(y7 || {});
var g6 = 2147483648;
function D5(e10) {
  return m9.test(e10);
}
function E5(e10) {
  return d12.test(e10);
}
var A9 = (e10, t39) => {
  let r30 = hmac.create(sha512, e10).update(t39).digest();
  return { key: r30.slice(0, 32), chainCode: r30.slice(32) };
};
var f7 = ({ key: e10, chainCode: t39 }, r30) => {
  let n27 = new ArrayBuffer(4);
  new DataView(n27).setUint32(0, r30);
  let o34 = new Uint8Array(n27), s14 = new Uint8Array([0]), a26 = new Uint8Array([...s14, ...e10, ...o34]);
  return A9(t39, a26);
};
var x5 = (e10) => e10.replace("'", "");
var U7 = (e10) => e10.split("/").slice(1).map(x5);
var h8 = (e10) => {
  let t39 = e10.trim().split(/\s+/).map((r30) => r30.toLowerCase()).join(" ");
  return mnemonicToSeedSync(t39);
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-G5MGSV7Y.mjs
var r10 = class r11 extends B2 {
  constructor(t39) {
    super();
    let { data: e10 } = t39, i49 = i6.fromHexInput(e10);
    if (i49.toUint8Array().length !== r11.LENGTH) throw new Error(`Authentication Key length should be ${r11.LENGTH}`);
    this.data = i49;
  }
  serialize(t39) {
    t39.serializeFixedBytes(this.data.toUint8Array());
  }
  static deserialize(t39) {
    let e10 = t39.deserializeFixedBytes(r11.LENGTH);
    return new r11({ data: e10 });
  }
  toString() {
    return this.data.toString();
  }
  toUint8Array() {
    return this.data.toUint8Array();
  }
  static fromSchemeAndBytes(t39) {
    let { scheme: e10, input: i49 } = t39, u17 = i6.fromHexInput(i49).toUint8Array(), h19 = new Uint8Array([...u17, e10]), a26 = sha3_256.create();
    a26.update(h19);
    let y14 = a26.digest();
    return new r11({ data: y14 });
  }
  static fromPublicKeyAndScheme(t39) {
    let { publicKey: e10 } = t39;
    return e10.authKey();
  }
  static fromPublicKey(t39) {
    let { publicKey: e10 } = t39;
    return e10.authKey();
  }
  derivedAddress() {
    return new d7(this.data.toUint8Array());
  }
};
r10.LENGTH = 32;
var c6 = r10;

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-Q7MD4V7H.mjs
var d13 = [237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16];
function w3(z9) {
  let e10 = z9.toUint8Array().slice(32);
  for (let t39 = d13.length - 1; t39 >= 0; t39 -= 1) {
    if (e10[t39] < d13[t39]) return true;
    if (e10[t39] > d13[t39]) return false;
  }
  return false;
}
var i33 = class i34 extends a11 {
  constructor(e10) {
    super();
    let t39 = i6.fromHexInput(e10);
    if (t39.toUint8Array().length !== i34.LENGTH) throw new Error(`PublicKey length should be ${i34.LENGTH}`);
    this.key = t39;
  }
  verifySignature(e10) {
    let { message: t39, signature: n27 } = e10;
    if (!w3(n27)) return false;
    let o34 = o19(t39), c16 = i6.fromHexInput(o34).toUint8Array(), u17 = n27.toUint8Array(), l20 = this.key.toUint8Array();
    return ed25519.verify(u17, c16, l20);
  }
  authKey() {
    return c6.fromSchemeAndBytes({ scheme: 0, input: this.toUint8Array() });
  }
  toUint8Array() {
    return this.key.toUint8Array();
  }
  serialize(e10) {
    e10.serializeBytes(this.key.toUint8Array());
  }
  static deserialize(e10) {
    let t39 = e10.deserializeBytes();
    return new i34(t39);
  }
  static isPublicKey(e10) {
    return e10 instanceof i34;
  }
  static isInstance(e10) {
    var _a, _b;
    return "key" in e10 && ((_b = (_a = e10.key) == null ? void 0 : _a.data) == null ? void 0 : _b.length) === i34.LENGTH;
  }
};
i33.LENGTH = 32;
var m10 = i33;
var r12 = class r13 extends B2 {
  constructor(e10) {
    super();
    let t39 = i6.fromHexInput(e10);
    if (t39.toUint8Array().length !== r13.LENGTH) throw new Error(`PrivateKey length should be ${r13.LENGTH}`);
    this.signingKey = t39;
  }
  static generate() {
    let e10 = ed25519.utils.randomPrivateKey();
    return new r13(e10);
  }
  static fromDerivationPath(e10, t39) {
    if (!E5(e10)) throw new Error(`Invalid derivation path ${e10}`);
    return r13.fromDerivationPathInner(e10, h8(t39));
  }
  static fromDerivationPathInner(e10, t39, n27 = g6) {
    let { key: o34, chainCode: c16 } = A9(r13.SLIP_0010_SEED, t39), u17 = U7(e10).map((x11) => parseInt(x11, 10)), { key: l20 } = u17.reduce((x11, I7) => f7(x11, I7 + n27), { key: o34, chainCode: c16 });
    return new r13(l20);
  }
  publicKey() {
    let e10 = ed25519.getPublicKey(this.signingKey.toUint8Array());
    return new m10(e10);
  }
  sign(e10) {
    let t39 = o19(e10), n27 = i6.fromHexInput(t39).toUint8Array(), o34 = ed25519.sign(n27, this.signingKey.toUint8Array());
    return new h9(o34);
  }
  toUint8Array() {
    return this.signingKey.toUint8Array();
  }
  toString() {
    return this.signingKey.toString();
  }
  serialize(e10) {
    e10.serializeBytes(this.toUint8Array());
  }
  static deserialize(e10) {
    let t39 = e10.deserializeBytes();
    return new r13(t39);
  }
  static isPrivateKey(e10) {
    return e10 instanceof r13;
  }
};
r12.LENGTH = 32, r12.SLIP_0010_SEED = "ed25519 seed";
var U8 = r12;
var a12 = class a13 extends o18 {
  constructor(e10) {
    super();
    let t39 = i6.fromHexInput(e10);
    if (t39.toUint8Array().length !== a13.LENGTH) throw new Error(`Signature length should be ${a13.LENGTH}`);
    this.data = t39;
  }
  toUint8Array() {
    return this.data.toUint8Array();
  }
  serialize(e10) {
    e10.serializeBytes(this.data.toUint8Array());
  }
  static deserialize(e10) {
    let t39 = e10.deserializeBytes();
    return new a13(t39);
  }
};
a12.LENGTH = 64;
var h9 = a12;

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-UWPO7WWS.mjs
var o20 = class o21 extends a11 {
  constructor(r30) {
    super();
    let { publicKeys: e10, threshold: t39 } = r30;
    if (e10.length > o21.MAX_KEYS || e10.length < o21.MIN_KEYS) throw new Error(`Must have between ${o21.MIN_KEYS} and ${o21.MAX_KEYS} public keys, inclusive`);
    if (t39 < o21.MIN_THRESHOLD || t39 > e10.length) throw new Error(`Threshold must be between ${o21.MIN_THRESHOLD} and ${e10.length}, inclusive`);
    this.publicKeys = e10, this.threshold = t39;
  }
  verifySignature(r30) {
    let { message: e10, signature: t39 } = r30;
    if (!(t39 instanceof y8)) return false;
    let s14 = [];
    for (let i49 = 0; i49 < 4; i49 += 1) for (let n27 = 0; n27 < 8; n27 += 1) if ((t39.bitmap[i49] & 1 << 7 - n27) !== 0) {
      let u17 = i49 * 8 + n27;
      s14.push(u17);
    }
    if (s14.length !== t39.signatures.length) throw new Error("Bitmap and signatures length mismatch");
    if (s14.length < this.threshold) throw new Error("Not enough signatures");
    for (let i49 = 0; i49 < s14.length; i49 += 1) if (!this.publicKeys[s14[i49]].verifySignature({ message: e10, signature: t39.signatures[i49] })) return false;
    return true;
  }
  authKey() {
    return c6.fromSchemeAndBytes({ scheme: 1, input: this.toUint8Array() });
  }
  toUint8Array() {
    let r30 = new Uint8Array(this.publicKeys.length * m10.LENGTH + 1);
    return this.publicKeys.forEach((e10, t39) => {
      r30.set(e10.toUint8Array(), t39 * m10.LENGTH);
    }), r30[this.publicKeys.length * m10.LENGTH] = this.threshold, r30;
  }
  serialize(r30) {
    r30.serializeBytes(this.toUint8Array());
  }
  static deserialize(r30) {
    let e10 = r30.deserializeBytes(), t39 = e10[e10.length - 1], s14 = [];
    for (let i49 = 0; i49 < e10.length - 1; i49 += m10.LENGTH) {
      let n27 = i49;
      s14.push(new m10(e10.subarray(n27, n27 + m10.LENGTH)));
    }
    return new o21({ publicKeys: s14, threshold: t39 });
  }
};
o20.MAX_KEYS = 32, o20.MIN_KEYS = 2, o20.MIN_THRESHOLD = 1;
var d14 = o20;
var a14 = class a15 extends o18 {
  constructor(r30) {
    super();
    let { signatures: e10, bitmap: t39 } = r30;
    if (e10.length > a15.MAX_SIGNATURES_SUPPORTED) throw new Error(`The number of signatures cannot be greater than ${a15.MAX_SIGNATURES_SUPPORTED}`);
    if (this.signatures = e10, !(t39 instanceof Uint8Array)) this.bitmap = a15.createBitmap({ bits: t39 });
    else {
      if (t39.length !== a15.BITMAP_LEN) throw new Error(`"bitmap" length should be ${a15.BITMAP_LEN}`);
      this.bitmap = t39;
    }
  }
  toUint8Array() {
    let r30 = new Uint8Array(this.signatures.length * h9.LENGTH + a15.BITMAP_LEN);
    return this.signatures.forEach((e10, t39) => {
      r30.set(e10.toUint8Array(), t39 * h9.LENGTH);
    }), r30.set(this.bitmap, this.signatures.length * h9.LENGTH), r30;
  }
  serialize(r30) {
    r30.serializeBytes(this.toUint8Array());
  }
  static deserialize(r30) {
    let e10 = r30.deserializeBytes(), t39 = e10.subarray(e10.length - 4), s14 = [];
    for (let i49 = 0; i49 < e10.length - t39.length; i49 += h9.LENGTH) {
      let n27 = i49;
      s14.push(new h9(e10.subarray(n27, n27 + h9.LENGTH)));
    }
    return new a15({ signatures: s14, bitmap: t39 });
  }
  static createBitmap(r30) {
    let { bits: e10 } = r30, t39 = 128, s14 = new Uint8Array([0, 0, 0, 0]), i49 = /* @__PURE__ */ new Set();
    return e10.forEach((n27, c16) => {
      if (n27 >= a15.MAX_SIGNATURES_SUPPORTED) throw new Error(`Cannot have a signature larger than ${a15.MAX_SIGNATURES_SUPPORTED - 1}.`);
      if (i49.has(n27)) throw new Error("Duplicate bits detected.");
      if (c16 > 0 && n27 <= e10[c16 - 1]) throw new Error("The bits need to be sorted in ascending order.");
      i49.add(n27);
      let u17 = Math.floor(n27 / 8), b12 = s14[u17];
      b12 |= t39 >> n27 % 8, s14[u17] = b12;
    }), s14;
  }
};
a14.MAX_SIGNATURES_SUPPORTED = 32, a14.BITMAP_LEN = 4;
var y8 = a14;

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-O4BBULNE.mjs
var i35 = class i36 extends t26 {
  constructor(e10) {
    super();
    let t39 = i6.fromHexInput(e10);
    if (t39.toUint8Array().length !== i36.LENGTH) throw new Error(`PublicKey length should be ${i36.LENGTH}`);
    this.key = t39;
  }
  verifySignature(e10) {
    let { message: t39, signature: n27 } = e10, y14 = o19(t39), l20 = i6.fromHexInput(y14).toUint8Array(), A18 = sha3_256(l20), x11 = n27.toUint8Array();
    return secp256k1.verify(x11, A18, this.key.toUint8Array(), { lowS: true });
  }
  toUint8Array() {
    return this.key.toUint8Array();
  }
  serialize(e10) {
    e10.serializeBytes(this.key.toUint8Array());
  }
  static deserialize(e10) {
    let t39 = e10.deserializeBytes();
    return new i36(t39);
  }
  static isPublicKey(e10) {
    return e10 instanceof i36;
  }
  static isInstance(e10) {
    var _a, _b;
    return "key" in e10 && ((_b = (_a = e10.key) == null ? void 0 : _a.data) == null ? void 0 : _b.length) === i36.LENGTH;
  }
};
i35.LENGTH = 65;
var u9 = i35;
var r14 = class r15 extends B2 {
  constructor(e10) {
    super();
    let t39 = i6.fromHexInput(e10);
    if (t39.toUint8Array().length !== r15.LENGTH) throw new Error(`PrivateKey length should be ${r15.LENGTH}`);
    this.key = t39;
  }
  static generate() {
    let e10 = secp256k1.utils.randomPrivateKey();
    return new r15(e10);
  }
  static fromDerivationPath(e10, t39) {
    if (!D5(e10)) throw new Error(`Invalid derivation path ${e10}`);
    return r15.fromDerivationPathInner(e10, h8(t39));
  }
  static fromDerivationPathInner(e10, t39) {
    let { privateKey: n27 } = HDKey.fromMasterSeed(t39).derive(e10);
    if (n27 === null) throw new Error("Invalid key");
    return new r15(n27);
  }
  sign(e10) {
    let t39 = o19(e10), n27 = i6.fromHexInput(t39), y14 = sha3_256(n27.toUint8Array()), l20 = secp256k1.sign(y14, this.key.toUint8Array(), { lowS: true });
    return new m11(l20.toCompactRawBytes());
  }
  publicKey() {
    let e10 = secp256k1.getPublicKey(this.key.toUint8Array(), false);
    return new u9(e10);
  }
  toUint8Array() {
    return this.key.toUint8Array();
  }
  toString() {
    return this.key.toString();
  }
  serialize(e10) {
    e10.serializeBytes(this.toUint8Array());
  }
  static deserialize(e10) {
    let t39 = e10.deserializeBytes();
    return new r15(t39);
  }
  static isPrivateKey(e10) {
    return e10 instanceof r15;
  }
};
r14.LENGTH = 32;
var v3 = r14;
var a16 = class a17 extends o18 {
  constructor(e10) {
    super();
    let t39 = i6.fromHexInput(e10);
    if (t39.toUint8Array().length !== a17.LENGTH) throw new Error(`Signature length should be ${a17.LENGTH}, received ${t39.toUint8Array().length}`);
    this.data = t39;
  }
  toUint8Array() {
    return this.data.toUint8Array();
  }
  serialize(e10) {
    e10.serializeBytes(this.data.toUint8Array());
  }
  static deserialize(e10) {
    let t39 = e10.deserializeBytes();
    return new a17(t39);
  }
};
a16.LENGTH = 64;
var m11 = a16;

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-IVVWQKCF.mjs
var import_poseidon_lite = __toESM(require_poseidon_lite(), 1);
var e6 = [import_poseidon_lite.poseidon1, import_poseidon_lite.poseidon2, import_poseidon_lite.poseidon3, import_poseidon_lite.poseidon4, import_poseidon_lite.poseidon5, import_poseidon_lite.poseidon6, import_poseidon_lite.poseidon7, import_poseidon_lite.poseidon8, import_poseidon_lite.poseidon9, import_poseidon_lite.poseidon10, import_poseidon_lite.poseidon11, import_poseidon_lite.poseidon12, import_poseidon_lite.poseidon13, import_poseidon_lite.poseidon14, import_poseidon_lite.poseidon15, import_poseidon_lite.poseidon16];
var s4 = 31;
var B5 = 16;
var i37 = (B5 - 1) * s4;
function x6(n27, t39) {
  let o34 = new TextEncoder().encode(n27);
  return $4(o34, t39);
}
function $4(n27, t39) {
  if (n27.length > t39) throw new Error(`Inputted bytes of length ${n27} is longer than ${t39}`);
  let r30 = T9(n27, t39);
  return k3(r30);
}
function m12(n27, t39) {
  if (n27.length > t39) throw new Error(`Input bytes of length ${n27} is longer than ${t39}`);
  let r30 = N(n27, t39);
  return _3(r30);
}
function T9(n27, t39) {
  if (n27.length > t39) throw new Error(`Input bytes of length ${n27} is longer than ${t39}`);
  return m12(n27, t39).concat([BigInt(n27.length)]);
}
function _3(n27) {
  if (n27.length > i37) throw new Error(`Can't pack more than ${i37}.  Was given ${n27.length} bytes`);
  return P3(n27, s4).map((t39) => L3(t39));
}
function P3(n27, t39) {
  let r30 = [];
  for (let o34 = 0; o34 < n27.length; o34 += t39) r30.push(n27.subarray(o34, o34 + t39));
  return r30;
}
function L3(n27) {
  let t39 = BigInt(0);
  for (let r30 = n27.length - 1; r30 >= 0; r30 -= 1) t39 = t39 << BigInt(8) | BigInt(n27[r30]);
  return t39;
}
function C4(n27, t39) {
  let r30 = new Uint8Array(t39);
  for (let o34 = 0; o34 < t39; o34 += 1) r30[o34] = Number(n27 & BigInt(255)), n27 >>= BigInt(8);
  return r30;
}
function N(n27, t39) {
  if (t39 < n27.length) throw new Error("Padded size must be greater than or equal to the input array size.");
  let r30 = new Uint8Array(t39);
  r30.set(n27);
  for (let o34 = n27.length; o34 < t39; o34 += 1) r30[o34] = 0;
  return r30;
}
function k3(n27) {
  if (n27.length > e6.length) throw new Error(`Unable to hash input of length ${n27.length}.  Max input length is ${e6.length}`);
  return e6[n27.length - 1](n27);
}

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-MQGW234H.mjs
var e7 = class extends B2 {
  toString() {
    let s14 = this.bcsToBytes();
    return i6.fromHexInput(s14).toString();
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-KEYAPEAX.mjs
var n20 = class {
  constructor(e10) {
    this.buffer = new ArrayBuffer(e10.length), new Uint8Array(this.buffer).set(e10, 0), this.offset = 0;
  }
  read(e10) {
    if (this.offset + e10 > this.buffer.byteLength) throw new Error("Reached to the end of buffer");
    let i49 = this.buffer.slice(this.offset, this.offset + e10);
    return this.offset += e10, i49;
  }
  remaining() {
    return this.buffer.byteLength - this.offset;
  }
  deserializeStr() {
    let e10 = this.deserializeBytes();
    return new TextDecoder().decode(e10);
  }
  deserializeOptionStr() {
    return this.deserializeBool() ? this.deserializeStr() : void 0;
  }
  deserializeOption(e10) {
    return this.deserializeBool() ? this.deserialize(e10) : void 0;
  }
  deserializeBytes() {
    let e10 = this.deserializeUleb128AsU32();
    return new Uint8Array(this.read(e10));
  }
  deserializeFixedBytes(e10) {
    return new Uint8Array(this.read(e10));
  }
  deserializeBool() {
    let e10 = new Uint8Array(this.read(1))[0];
    if (e10 !== 1 && e10 !== 0) throw new Error("Invalid boolean value");
    return e10 === 1;
  }
  deserializeU8() {
    return new DataView(this.read(1)).getUint8(0);
  }
  deserializeU16() {
    return new DataView(this.read(2)).getUint16(0, true);
  }
  deserializeU32() {
    return new DataView(this.read(4)).getUint32(0, true);
  }
  deserializeU64() {
    let e10 = this.deserializeU32(), i49 = this.deserializeU32();
    return BigInt(BigInt(i49) << BigInt(32) | BigInt(e10));
  }
  deserializeU128() {
    let e10 = this.deserializeU64(), i49 = this.deserializeU64();
    return BigInt(i49 << BigInt(64) | e10);
  }
  deserializeU256() {
    let e10 = this.deserializeU128(), i49 = this.deserializeU128();
    return BigInt(i49 << BigInt(128) | e10);
  }
  deserializeUleb128AsU32() {
    let e10 = BigInt(0), i49 = 0;
    for (; e10 < U2; ) {
      let t39 = this.deserializeU8();
      if (e10 |= BigInt(t39 & 127) << BigInt(i49), !(t39 & 128)) break;
      i49 += 7;
    }
    if (e10 > U2) throw new Error("Overflow while parsing uleb128-encoded uint32 value");
    return Number(e10);
  }
  deserialize(e10) {
    return e10.deserialize(this);
  }
  deserializeVector(e10) {
    let i49 = this.deserializeUleb128AsU32(), t39 = new Array();
    for (let s14 = 0; s14 < i49; s14 += 1) t39.push(this.deserialize(e10));
    return t39;
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-ZXYTLPP6.mjs
var c8 = class i38 extends t26 {
  constructor(e10) {
    super();
    let r30 = e10.constructor.name;
    switch (r30) {
      case m10.name:
        this.publicKey = e10, this.variant = 0;
        break;
      default:
        throw new Error(`Unsupported key for EphemeralPublicKey - ${r30}`);
    }
  }
  toUint8Array() {
    return this.bcsToBytes();
  }
  verifySignature(e10) {
    let { message: r30, signature: a26 } = e10;
    return this.publicKey.verifySignature({ message: r30, signature: a26.signature });
  }
  serialize(e10) {
    if (this.publicKey instanceof m10) e10.serializeU32AsUleb128(0), this.publicKey.serialize(e10);
    else throw new Error("Unknown public key type");
  }
  static deserialize(e10) {
    let r30 = e10.deserializeUleb128AsU32();
    switch (r30) {
      case 0:
        return new i38(m10.deserialize(e10));
      default:
        throw new Error(`Unknown variant index for EphemeralPublicKey: ${r30}`);
    }
  }
  static isPublicKey(e10) {
    return e10 instanceof i38;
  }
};
var p8 = class i39 extends o18 {
  constructor(e10) {
    super();
    let r30 = e10.constructor.name;
    switch (r30) {
      case h9.name:
        this.signature = e10;
        break;
      default:
        throw new Error(`Unsupported signature for EphemeralSignature - ${r30}`);
    }
  }
  toUint8Array() {
    return this.bcsToBytes();
  }
  static fromHex(e10) {
    let r30 = i6.fromHexInput(e10), a26 = new n20(r30.toUint8Array());
    return i39.deserialize(a26);
  }
  serialize(e10) {
    if (this.signature instanceof h9) e10.serializeU32AsUleb128(0), this.signature.serialize(e10);
    else throw new Error("Unknown signature type");
  }
  static deserialize(e10) {
    let r30 = e10.deserializeUleb128AsU32();
    switch (r30) {
      case 0:
        return new i39(h9.deserialize(e10));
      default:
        throw new Error(`Unknown variant index for EphemeralSignature: ${r30}`);
    }
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-4ZMI5G5L.mjs
var F2 = 120;
var L4 = 30;
var N2 = 330;
var o22 = class o23 extends a11 {
  constructor(e10, t39) {
    super();
    let i49 = i6.fromHexInput(t39).toUint8Array();
    if (i49.length !== o23.ID_COMMITMENT_LENGTH) throw new Error(`Id Commitment length in bytes should be ${o23.ID_COMMITMENT_LENGTH}`);
    this.iss = e10, this.idCommitment = i49;
  }
  authKey() {
    let e10 = new n15();
    return e10.serializeU32AsUleb128(3), e10.serializeFixedBytes(this.bcsToBytes()), c6.fromSchemeAndBytes({ scheme: 2, input: e10.toUint8Array() });
  }
  toUint8Array() {
    return this.bcsToBytes();
  }
  toString() {
    return i6.fromHexInput(this.toUint8Array()).toString();
  }
  verifySignature(e10) {
    throw new Error("Not yet implemented");
  }
  serialize(e10) {
    e10.serializeStr(this.iss), e10.serializeBytes(this.idCommitment);
  }
  static deserialize(e10) {
    let t39 = e10.deserializeStr(), i49 = e10.deserializeBytes();
    return new o23(t39, i49);
  }
  static load(e10) {
    let t39 = e10.deserializeStr(), i49 = e10.deserializeBytes();
    return new o23(t39, i49);
  }
  static isPublicKey(e10) {
    return e10 instanceof o23;
  }
  static create(e10) {
    return _4(e10), new o23(e10.iss, _4(e10));
  }
  static fromJwtAndPepper(e10) {
    let { jwt: t39, pepper: i49, uidKey: a26 = "sub" } = e10, n27 = jwtDecode(t39), s14 = n27.iss;
    if (typeof n27.aud != "string") throw new Error("aud was not found or an array of values");
    let M5 = n27.aud, R7 = n27[a26];
    return o23.create({ iss: s14, uidKey: a26, uidVal: R7, aud: M5, pepper: i49 });
  }
  static isInstance(e10) {
    return "iss" in e10 && typeof e10.iss == "string" && "idCommitment" in e10 && e10.idCommitment instanceof Uint8Array;
  }
};
o22.ID_COMMITMENT_LENGTH = 32;
var A11 = o22;
function _4(r30) {
  let { uidKey: e10, uidVal: t39, aud: i49, pepper: a26 } = r30, n27 = [L3(i6.fromHexInput(a26).toUint8Array()), x6(i49, F2), x6(t39, N2), x6(e10, L4)];
  return C4(k3(n27), A11.ID_COMMITMENT_LENGTH);
}
var D6 = class r16 extends o18 {
  constructor(e10) {
    super();
    let { jwtHeader: t39, ephemeralCertificate: i49, expiryDateSecs: a26, ephemeralPublicKey: n27, ephemeralSignature: s14 } = e10;
    this.jwtHeader = t39, this.ephemeralCertificate = i49, this.expiryDateSecs = a26, this.ephemeralPublicKey = n27, this.ephemeralSignature = s14;
  }
  toUint8Array() {
    return this.bcsToBytes();
  }
  serialize(e10) {
    this.ephemeralCertificate.serialize(e10), e10.serializeStr(this.jwtHeader), e10.serializeU64(this.expiryDateSecs), this.ephemeralPublicKey.serialize(e10), this.ephemeralSignature.serialize(e10);
  }
  static deserialize(e10) {
    let t39 = h11.deserialize(e10), i49 = e10.deserializeStr(), a26 = e10.deserializeU64(), n27 = c8.deserialize(e10), s14 = p8.deserialize(e10);
    return new r16({ jwtHeader: i49, expiryDateSecs: Number(a26), ephemeralCertificate: t39, ephemeralPublicKey: n27, ephemeralSignature: s14 });
  }
  static getSimulationSignature() {
    return new r16({ jwtHeader: "{}", ephemeralCertificate: new h11(new S5({ proof: new f9(new g8({ a: new Uint8Array(32), b: new Uint8Array(64), c: new Uint8Array(32) }), 0), expHorizonSecs: 0 }), 0), expiryDateSecs: 0, ephemeralPublicKey: new c8(new m10(new Uint8Array(32))), ephemeralSignature: new p8(new h9(new Uint8Array(64))) });
  }
  static isSignature(e10) {
    return e10 instanceof r16;
  }
};
var h11 = class r17 extends o18 {
  constructor(e10, t39) {
    super(), this.signature = e10, this.variant = t39;
  }
  toUint8Array() {
    return this.signature.toUint8Array();
  }
  serialize(e10) {
    e10.serializeU32AsUleb128(this.variant), this.signature.serialize(e10);
  }
  static deserialize(e10) {
    let t39 = e10.deserializeUleb128AsU32();
    switch (t39) {
      case 0:
        return new r17(S5.deserialize(e10), t39);
      default:
        throw new Error(`Unknown variant index for EphemeralCertificate: ${t39}`);
    }
  }
};
var c9 = class r18 extends B2 {
  constructor(e10) {
    if (super(), this.data = i6.fromHexInput(e10).toUint8Array(), this.data.length !== 32) throw new Error("Input needs to be 32 bytes");
  }
  serialize(e10) {
    e10.serializeFixedBytes(this.data);
  }
  static deserialize(e10) {
    let t39 = e10.deserializeFixedBytes(32);
    return new r18(t39);
  }
};
var l9 = class r19 extends B2 {
  constructor(e10) {
    if (super(), this.data = i6.fromHexInput(e10).toUint8Array(), this.data.length !== 64) throw new Error("Input needs to be 64 bytes");
  }
  serialize(e10) {
    e10.serializeFixedBytes(this.data);
  }
  static deserialize(e10) {
    let t39 = e10.deserializeFixedBytes(64);
    return new r19(t39);
  }
};
var g8 = class r20 extends e7 {
  constructor(e10) {
    super();
    let { a: t39, b: i49, c: a26 } = e10;
    this.a = new c9(t39), this.b = new l9(i49), this.c = new c9(a26);
  }
  serialize(e10) {
    this.a.serialize(e10), this.b.serialize(e10), this.c.serialize(e10);
  }
  static deserialize(e10) {
    let t39 = c9.deserialize(e10).bcsToBytes(), i49 = l9.deserialize(e10).bcsToBytes(), a26 = c9.deserialize(e10).bcsToBytes();
    return new r20({ a: t39, b: i49, c: a26 });
  }
};
var f9 = class r21 extends B2 {
  constructor(e10, t39) {
    super(), this.proof = e10, this.variant = t39;
  }
  serialize(e10) {
    e10.serializeU32AsUleb128(this.variant), this.proof.serialize(e10);
  }
  static deserialize(e10) {
    let t39 = e10.deserializeUleb128AsU32();
    switch (t39) {
      case 0:
        return new r21(g8.deserialize(e10), t39);
      default:
        throw new Error(`Unknown variant index for ZkProof: ${t39}`);
    }
  }
};
var S5 = class r22 extends o18 {
  constructor(e10) {
    super();
    let { proof: t39, expHorizonSecs: i49, trainingWheelsSignature: a26, extraField: n27, overrideAudVal: s14 } = e10;
    this.proof = t39, this.expHorizonSecs = i49, this.trainingWheelsSignature = a26, this.extraField = n27, this.overrideAudVal = s14;
  }
  toUint8Array() {
    return this.bcsToBytes();
  }
  static fromBytes(e10) {
    return r22.deserialize(new n20(e10));
  }
  serialize(e10) {
    this.proof.serialize(e10), e10.serializeU64(this.expHorizonSecs), e10.serializeOptionStr(this.extraField), e10.serializeOptionStr(this.overrideAudVal), e10.serializeOption(this.trainingWheelsSignature);
  }
  static deserialize(e10) {
    let t39 = f9.deserialize(e10), i49 = Number(e10.deserializeU64()), a26 = e10.deserializeOptionStr(), n27 = e10.deserializeOptionStr(), s14 = e10.deserializeOption(p8);
    return new r22({ proof: t39, expHorizonSecs: i49, trainingWheelsSignature: s14, extraField: a26, overrideAudVal: n27 });
  }
};
var z6 = class r23 {
  constructor(e10, t39) {
    this.verficationKey = e10, this.maxExpHorizonSecs = t39;
  }
  static create(e10, t39) {
    return new r23(new K({ alphaG1: e10.alpha_g1, betaG2: e10.beta_g2, deltaG2: e10.delta_g2, gammaAbcG1: e10.gamma_abc_g1, gammaG2: e10.gamma_g2 }), t39);
  }
};
var K = class r24 {
  constructor(e10) {
    let { alphaG1: t39, betaG2: i49, deltaG2: a26, gammaAbcG1: n27, gammaG2: s14 } = e10;
    this.alphaG1 = new c9(t39), this.betaG2 = new l9(i49), this.deltaG2 = new l9(a26), this.gammaAbcG1 = [new c9(n27[0]), new c9(n27[1])], this.gammaG2 = new l9(s14);
  }
  static fromGroth16VerificationKeyResponse(e10) {
    return new r24({ alphaG1: e10.alpha_g1, betaG2: e10.beta_g2, deltaG2: e10.delta_g2, gammaAbcG1: e10.gamma_abc_g1, gammaG2: e10.gamma_g2 });
  }
};
async function be(r30) {
  let { aptosConfig: e10 } = r30;
  return m5(async () => {
    let t39 = await O3(r30), i49 = await j5(r30);
    return z6.create(i49, Number(t39.max_exp_horizon_secs));
  }, `keyless-configuration-${e10.network}`, 1e3 * 60 * 5)();
}
async function O3(r30) {
  let { aptosConfig: e10, options: t39 } = r30, i49 = "0x1::keyless_account::Configuration", { data: a26 } = await m3({ aptosConfig: e10, originMethod: "getKeylessConfigurationResource", path: `accounts/${d7.from("0x1").toString()}/resource/${i49}`, params: { ledger_version: t39 == null ? void 0 : t39.ledgerVersion } });
  return a26.data;
}
async function j5(r30) {
  let { aptosConfig: e10, options: t39 } = r30, i49 = "0x1::keyless_account::Groth16VerificationKey", { data: a26 } = await m3({ aptosConfig: e10, originMethod: "getGroth16VerificationKeyResource", path: `accounts/${d7.from("0x1").toString()}/resource/${i49}`, params: { ledger_version: t39 == null ? void 0 : t39.ledgerVersion } });
  return a26.data;
}

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-NU55IEL4.mjs
var f10 = class r25 extends a11 {
  constructor(e10) {
    if (super(), this.publicKey = e10, e10 instanceof m10) this.variant = 0;
    else if (e10 instanceof u9) this.variant = 1;
    else if (e10 instanceof A11) this.variant = 3;
    else throw new Error("Unsupported public key type");
  }
  verifySignature(e10) {
    let { message: t39, signature: i49 } = e10;
    return l10.isInstance(i49) ? this.publicKey.verifySignature({ message: t39, signature: i49.signature }) : false;
  }
  authKey() {
    return c6.fromSchemeAndBytes({ scheme: 2, input: this.toUint8Array() });
  }
  toUint8Array() {
    return this.bcsToBytes();
  }
  serialize(e10) {
    e10.serializeU32AsUleb128(this.variant), this.publicKey.serialize(e10);
  }
  static deserialize(e10) {
    let t39 = e10.deserializeUleb128AsU32(), i49;
    switch (t39) {
      case 0:
        i49 = m10.deserialize(e10);
        break;
      case 1:
        i49 = u9.deserialize(e10);
        break;
      case 3:
        i49 = A11.deserialize(e10);
        break;
      default:
        throw new Error(`Unknown variant index for AnyPublicKey: ${t39}`);
    }
    return new r25(i49);
  }
  static isPublicKey(e10) {
    return e10 instanceof r25;
  }
  isEd25519() {
    return this.publicKey instanceof m10;
  }
  isSecp256k1PublicKey() {
    return this.publicKey instanceof u9;
  }
  static isInstance(e10) {
    return "publicKey" in e10 && "variant" in e10;
  }
};
var l10 = class r26 extends o18 {
  constructor(e10) {
    if (super(), this.signature = e10, e10 instanceof h9) this.variant = 0;
    else if (e10 instanceof m11) this.variant = 1;
    else if (e10 instanceof D6) this.variant = 3;
    else throw new Error("Unsupported signature type");
  }
  toUint8Array() {
    return console.warn("[Aptos SDK] Calls to AnySignature.toUint8Array() will soon return the underlying signature bytes. Use AnySignature.bcsToBytes() instead."), this.bcsToBytes();
  }
  serialize(e10) {
    e10.serializeU32AsUleb128(this.variant), this.signature.serialize(e10);
  }
  static deserialize(e10) {
    let t39 = e10.deserializeUleb128AsU32(), i49;
    switch (t39) {
      case 0:
        i49 = h9.deserialize(e10);
        break;
      case 1:
        i49 = m11.deserialize(e10);
        break;
      case 3:
        i49 = D6.deserialize(e10);
        break;
      default:
        throw new Error(`Unknown variant index for AnySignature: ${t39}`);
    }
    return new r26(i49);
  }
  static isInstance(e10) {
    return "signature" in e10 && typeof e10.signature == "object" && e10.signature !== null && "toUint8Array" in e10.signature;
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-6ERHGCK2.mjs
function d16(l20) {
  let e10 = l20;
  return e10 -= e10 >> 1 & 1431655765, e10 = (e10 & 858993459) + (e10 >> 2 & 858993459), (e10 + (e10 >> 4) & 252645135) * 16843009 >> 24;
}
var f11 = class l11 extends a11 {
  constructor(e10) {
    super();
    let { publicKeys: r30, signaturesRequired: t39 } = e10;
    if (t39 < 1) throw new Error("The number of required signatures needs to be greater than 0");
    if (r30.length < t39) throw new Error(`Provided ${r30.length} public keys is smaller than the ${t39} required signatures`);
    this.publicKeys = r30.map((i49) => i49 instanceof f10 ? i49 : new f10(i49)), this.signaturesRequired = t39;
  }
  verifySignature(e10) {
    throw new Error("not implemented");
  }
  authKey() {
    return c6.fromSchemeAndBytes({ scheme: 3, input: this.toUint8Array() });
  }
  toUint8Array() {
    return this.bcsToBytes();
  }
  serialize(e10) {
    e10.serializeVector(this.publicKeys), e10.serializeU8(this.signaturesRequired);
  }
  static deserialize(e10) {
    let r30 = e10.deserializeVector(f10), t39 = e10.deserializeU8();
    return new l11({ publicKeys: r30, signaturesRequired: t39 });
  }
  createBitmap(e10) {
    let { bits: r30 } = e10, t39 = 128, i49 = new Uint8Array([0, 0, 0, 0]), a26 = /* @__PURE__ */ new Set();
    return r30.forEach((n27, u17) => {
      if (u17 + 1 > this.publicKeys.length) throw new Error(`Signature index ${u17 + 1} is out of public keys range, ${this.publicKeys.length}.`);
      if (a26.has(n27)) throw new Error(`Duplicate bit ${n27} detected.`);
      a26.add(n27);
      let c16 = Math.floor(n27 / 8), y14 = i49[c16];
      y14 |= t39 >> n27 % 8, i49[c16] = y14;
    }), i49;
  }
  getIndex(e10) {
    let r30 = e10 instanceof f10 ? e10 : new f10(e10), t39 = this.publicKeys.findIndex((i49) => i49.toString() === r30.toString());
    if (t39 !== -1) return t39;
    throw new Error("Public key not found in MultiKey");
  }
};
var s5 = class s6 extends o18 {
  constructor(e10) {
    super();
    let { signatures: r30, bitmap: t39 } = e10;
    if (r30.length > s6.MAX_SIGNATURES_SUPPORTED) throw new Error(`The number of signatures cannot be greater than ${s6.MAX_SIGNATURES_SUPPORTED}`);
    if (this.signatures = r30.map((a26) => a26 instanceof l10 ? a26 : new l10(a26)), !(t39 instanceof Uint8Array)) this.bitmap = s6.createBitmap({ bits: t39 });
    else {
      if (t39.length !== s6.BITMAP_LEN) throw new Error(`"bitmap" length should be ${s6.BITMAP_LEN}`);
      this.bitmap = t39;
    }
    let i49 = this.bitmap.reduce((a26, n27) => a26 + d16(n27), 0);
    if (i49 !== this.signatures.length) throw new Error(`Expecting ${i49} signatures from the bitmap, but got ${this.signatures.length}`);
  }
  static createBitmap(e10) {
    let { bits: r30 } = e10, t39 = 128, i49 = new Uint8Array([0, 0, 0, 0]), a26 = /* @__PURE__ */ new Set();
    return r30.forEach((n27) => {
      if (n27 >= s6.MAX_SIGNATURES_SUPPORTED) throw new Error(`Cannot have a signature larger than ${s6.MAX_SIGNATURES_SUPPORTED - 1}.`);
      if (a26.has(n27)) throw new Error("Duplicate bits detected.");
      a26.add(n27);
      let u17 = Math.floor(n27 / 8), c16 = i49[u17];
      c16 |= t39 >> n27 % 8, i49[u17] = c16;
    }), i49;
  }
  toUint8Array() {
    return this.bcsToBytes();
  }
  serialize(e10) {
    e10.serializeVector(this.signatures), e10.serializeBytes(this.bitmap);
  }
  static deserialize(e10) {
    let r30 = e10.deserializeVector(l10), t39 = e10.deserializeBytes();
    return new s6({ signatures: r30, bitmap: t39 });
  }
};
s5.BITMAP_LEN = 4, s5.MAX_SIGNATURES_SUPPORTED = s5.BITMAP_LEN * 8;
var p9 = s5;

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-Q67DUNMI.mjs
var r27 = class extends B2 {
  static deserialize(i49) {
    let e10 = i49.deserializeUleb128AsU32();
    switch (e10) {
      case 0:
        return u11.load(i49);
      case 1:
        return l12.load(i49);
      case 2:
        return n21.load(i49);
      case 3:
        return a19.load(i49);
      default:
        throw new Error(`Unknown variant index for AccountAuthenticator: ${e10}`);
    }
  }
  isEd25519() {
    return this instanceof u11;
  }
  isMultiEd25519() {
    return this instanceof l12;
  }
  isSingleKey() {
    return this instanceof n21;
  }
  isMultiKey() {
    return this instanceof a19;
  }
};
var u11 = class t27 extends r27 {
  constructor(i49, e10) {
    super(), this.public_key = i49, this.signature = e10;
  }
  serialize(i49) {
    i49.serializeU32AsUleb128(0), this.public_key.serialize(i49), this.signature.serialize(i49);
  }
  static load(i49) {
    let e10 = m10.deserialize(i49), s14 = h9.deserialize(i49);
    return new t27(e10, s14);
  }
};
var l12 = class t28 extends r27 {
  constructor(i49, e10) {
    super(), this.public_key = i49, this.signature = e10;
  }
  serialize(i49) {
    i49.serializeU32AsUleb128(1), this.public_key.serialize(i49), this.signature.serialize(i49);
  }
  static load(i49) {
    let e10 = d14.deserialize(i49), s14 = y8.deserialize(i49);
    return new t28(e10, s14);
  }
};
var n21 = class t29 extends r27 {
  constructor(i49, e10) {
    super(), this.public_key = i49, this.signature = e10;
  }
  serialize(i49) {
    i49.serializeU32AsUleb128(2), this.public_key.serialize(i49), this.signature.serialize(i49);
  }
  static load(i49) {
    let e10 = f10.deserialize(i49), s14 = l10.deserialize(i49);
    return new t29(e10, s14);
  }
};
var a19 = class t30 extends r27 {
  constructor(i49, e10) {
    super(), this.public_keys = i49, this.signatures = e10;
  }
  serialize(i49) {
    i49.serializeU32AsUleb128(3), this.public_keys.serialize(i49), this.signatures.serialize(i49);
  }
  static load(i49) {
    let e10 = f11.deserialize(i49), s14 = p9.deserialize(i49);
    return new t30(e10, s14);
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-ZZRSKHWS.mjs
var h12 = class c10 {
  constructor(e10) {
    this.signingScheme = 2;
    let { privateKey: r30, address: t39 } = e10;
    this.privateKey = r30, this.publicKey = new f10(r30.publicKey()), this.accountAddress = t39 ? d7.from(t39) : this.publicKey.authKey().derivedAddress();
  }
  static generate(e10 = {}) {
    let { scheme: r30 = 0 } = e10, t39;
    switch (r30) {
      case 0:
        t39 = U8.generate();
        break;
      case 2:
        t39 = v3.generate();
        break;
      default:
        throw new Error(`Unsupported signature scheme ${r30}`);
    }
    return new c10({ privateKey: t39 });
  }
  static fromDerivationPath(e10) {
    let { scheme: r30 = 0, path: t39, mnemonic: o34 } = e10, n27;
    switch (r30) {
      case 0:
        n27 = U8.fromDerivationPath(t39, o34);
        break;
      case 2:
        n27 = v3.fromDerivationPath(t39, o34);
        break;
      default:
        throw new Error(`Unsupported signature scheme ${r30}`);
    }
    return new c10({ privateKey: n27 });
  }
  verifySignature(e10) {
    return this.publicKey.verifySignature(e10);
  }
  signWithAuthenticator(e10) {
    return new n21(this.publicKey, this.sign(e10));
  }
  signTransactionWithAuthenticator(e10) {
    return new n21(this.publicKey, this.signTransaction(e10));
  }
  sign(e10) {
    return new l10(this.privateKey.sign(e10));
  }
  signTransaction(e10) {
    return this.sign(S4(e10));
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-JKNTGRSQ.mjs
var c11 = class a20 {
  constructor(t39) {
    this.signingScheme = 0;
    let { privateKey: e10, address: r30 } = t39;
    this.privateKey = e10, this.publicKey = e10.publicKey(), this.accountAddress = r30 ? d7.from(r30) : this.publicKey.authKey().derivedAddress();
  }
  static generate() {
    let t39 = U8.generate();
    return new a20({ privateKey: t39 });
  }
  static fromDerivationPath(t39) {
    let { path: e10, mnemonic: r30 } = t39, u17 = U8.fromDerivationPath(e10, r30);
    return new a20({ privateKey: u17 });
  }
  verifySignature(t39) {
    return this.publicKey.verifySignature(t39);
  }
  signWithAuthenticator(t39) {
    return new u11(this.publicKey, this.privateKey.sign(t39));
  }
  signTransactionWithAuthenticator(t39) {
    return new u11(this.publicKey, this.signTransaction(t39));
  }
  sign(t39) {
    return this.privateKey.sign(t39);
  }
  signTransaction(t39) {
    return this.sign(S4(t39));
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-3SPU4V2B.mjs
var o24 = class {
  static generate(e10 = {}) {
    let { scheme: t39 = 0, legacy: r30 = true } = e10;
    return t39 === 0 && r30 ? c11.generate() : h12.generate({ scheme: t39 });
  }
  static fromPrivateKey(e10) {
    let { privateKey: t39, address: r30, legacy: a26 = true } = e10;
    return t39 instanceof U8 && a26 ? new c11({ privateKey: t39, address: r30 }) : new h12({ privateKey: t39, address: r30 });
  }
  static fromPrivateKeyAndAddress(e10) {
    return this.fromPrivateKey(e10);
  }
  static fromDerivationPath(e10) {
    let { scheme: t39 = 0, mnemonic: r30, path: a26, legacy: s14 = true } = e10;
    return t39 === 0 && s14 ? c11.fromDerivationPath({ mnemonic: r30, path: a26 }) : h12.fromDerivationPath({ scheme: t39, mnemonic: r30, path: a26 });
  }
  static authKey(e10) {
    let { publicKey: t39 } = e10;
    return t39.authKey();
  }
  verifySignature(e10) {
    return this.publicKey.verifySignature(e10);
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-WRRQ7L5K.mjs
var d17 = (e10, r30) => {
  let t39 = e10.bcsToBytes(), s14 = typeof r30 == "string" ? Buffer.from(r30, "utf8") : r30, o34 = new Uint8Array([...t39, ...s14, 254]);
  return new d7(sha3_256(o34));
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-HHU7UCFI.mjs
async function R4(o34) {
  let { aptosConfig: n27, accountAddress: t39 } = o34, { data: e10 } = await m3({ aptosConfig: n27, originMethod: "getInfo", path: `accounts/${d7.from(t39).toString()}` });
  return e10;
}
async function Y(o34) {
  let { aptosConfig: n27, accountAddress: t39, options: e10 } = o34;
  return A5({ aptosConfig: n27, originMethod: "getModules", path: `accounts/${d7.from(t39).toString()}/modules`, params: { ledger_version: e10 == null ? void 0 : e10.ledgerVersion, start: e10 == null ? void 0 : e10.offset, limit: (e10 == null ? void 0 : e10.limit) ?? 1e3 } });
}
async function Z(o34) {
  var _a;
  return ((_a = o34.options) == null ? void 0 : _a.ledgerVersion) !== void 0 ? Q2(o34) : m5(async () => Q2(o34), `module-${o34.accountAddress}-${o34.moduleName}`, 1e3 * 60 * 5)();
}
async function Q2(o34) {
  let { aptosConfig: n27, accountAddress: t39, moduleName: e10, options: r30 } = o34, { data: s14 } = await m3({ aptosConfig: n27, originMethod: "getModule", path: `accounts/${d7.from(t39).toString()}/module/${e10}`, params: { ledger_version: r30 == null ? void 0 : r30.ledgerVersion } });
  return s14;
}
async function ee(o34) {
  let { aptosConfig: n27, accountAddress: t39, options: e10 } = o34;
  return A5({ aptosConfig: n27, originMethod: "getTransactions", path: `accounts/${d7.from(t39).toString()}/transactions`, params: { start: e10 == null ? void 0 : e10.offset, limit: e10 == null ? void 0 : e10.limit } });
}
async function oe(o34) {
  let { aptosConfig: n27, accountAddress: t39, options: e10 } = o34;
  return A5({ aptosConfig: n27, originMethod: "getResources", path: `accounts/${d7.from(t39).toString()}/resources`, params: { ledger_version: e10 == null ? void 0 : e10.ledgerVersion, start: e10 == null ? void 0 : e10.offset, limit: (e10 == null ? void 0 : e10.limit) ?? 999 } });
}
async function x7(o34) {
  let { aptosConfig: n27, accountAddress: t39, resourceType: e10, options: r30 } = o34, { data: s14 } = await m3({ aptosConfig: n27, originMethod: "getResource", path: `accounts/${d7.from(t39).toString()}/resource/${e10}`, params: { ledger_version: r30 == null ? void 0 : r30.ledgerVersion } });
  return s14.data;
}
async function L5(o34) {
  let { aptosConfig: n27, authenticationKey: t39, options: e10 } = o34, r30 = await x7({ aptosConfig: n27, accountAddress: "0x1", resourceType: "0x1::account::OriginatingAddress", options: e10 }), { address_map: { handle: s14 } } = r30, c16 = d7.from(t39);
  try {
    let a26 = await b2({ aptosConfig: n27, handle: s14, data: { key: c16.toString(), key_type: "address", value_type: "address" }, options: e10 });
    return d7.from(a26);
  } catch (a26) {
    if (a26 instanceof n10 && a26.data.error_code === "table_item_not_found") return c16;
    throw a26;
  }
}
async function te(o34) {
  let { aptosConfig: n27, accountAddress: t39 } = o34, r30 = { owner_address: { _eq: d7.from(t39).toStringLong() }, amount: { _gt: 0 } }, c16 = await a4({ aptosConfig: n27, query: { query: p3, variables: { where_condition: r30 } }, originMethod: "getAccountTokensCount" });
  return c16.current_token_ownerships_v2_aggregate.aggregate ? c16.current_token_ownerships_v2_aggregate.aggregate.count : 0;
}
async function ne(o34) {
  let { aptosConfig: n27, accountAddress: t39, options: e10 } = o34, s14 = { owner_address: { _eq: d7.from(t39).toStringLong() }, amount: { _gt: 0 } };
  (e10 == null ? void 0 : e10.tokenStandard) && (s14.token_standard = { _eq: e10 == null ? void 0 : e10.tokenStandard });
  let c16 = { query: d4, variables: { where_condition: s14, offset: e10 == null ? void 0 : e10.offset, limit: e10 == null ? void 0 : e10.limit, order_by: e10 == null ? void 0 : e10.orderBy } };
  return (await a4({ aptosConfig: n27, query: c16, originMethod: "getAccountOwnedTokens" })).current_token_ownerships_v2;
}
async function re(o34) {
  let { aptosConfig: n27, accountAddress: t39, collectionAddress: e10, options: r30 } = o34, s14 = d7.from(t39).toStringLong(), c16 = d7.from(e10).toStringLong(), a26 = { owner_address: { _eq: s14 }, current_token_data: { collection_id: { _eq: c16 } }, amount: { _gt: 0 } };
  (r30 == null ? void 0 : r30.tokenStandard) && (a26.token_standard = { _eq: r30 == null ? void 0 : r30.tokenStandard });
  let u17 = { query: y2, variables: { where_condition: a26, offset: r30 == null ? void 0 : r30.offset, limit: r30 == null ? void 0 : r30.limit, order_by: r30 == null ? void 0 : r30.orderBy } };
  return (await a4({ aptosConfig: n27, query: u17, originMethod: "getAccountOwnedTokensFromCollectionAddress" })).current_token_ownerships_v2;
}
async function se(o34) {
  let { aptosConfig: n27, accountAddress: t39, options: e10 } = o34, s14 = { owner_address: { _eq: d7.from(t39).toStringLong() } };
  (e10 == null ? void 0 : e10.tokenStandard) && (s14.current_collection = { token_standard: { _eq: e10 == null ? void 0 : e10.tokenStandard } });
  let c16 = { query: c3, variables: { where_condition: s14, offset: e10 == null ? void 0 : e10.offset, limit: e10 == null ? void 0 : e10.limit, order_by: e10 == null ? void 0 : e10.orderBy } };
  return (await a4({ aptosConfig: n27, query: c16, originMethod: "getAccountCollectionsWithOwnedTokens" })).current_collection_ownership_v2_view;
}
async function ce(o34) {
  let { aptosConfig: n27, accountAddress: t39 } = o34, e10 = d7.from(t39).toStringLong(), s14 = await a4({ aptosConfig: n27, query: { query: m2, variables: { address: e10 } }, originMethod: "getAccountTransactionsCount" });
  return s14.account_transactions_aggregate.aggregate ? s14.account_transactions_aggregate.aggregate.count : 0;
}
async function ie(o34) {
  let { aptosConfig: n27, accountAddress: t39, coinType: e10, faMetadataAddress: r30 } = o34, s14, c16;
  if (e10 !== void 0 && r30 !== void 0) c16 = d7.from(r30).toStringLong();
  else if (e10 !== void 0 && r30 === void 0) s14 = e10, o34.coinType === o11 ? c16 = d7.A.toStringLong() : c16 = d17(d7.A, e10).toStringLong();
  else if (e10 === void 0 && r30 !== void 0) {
    let m17 = d7.from(r30);
    c16 = m17.toStringLong(), m17 === d7.A && (s14 = o11);
  } else throw new Error("Either coinType, fungibleAssetAddress, or both must be provided");
  let a26 = d7.from(t39).toStringLong(), u17 = { asset_type: { _eq: c16 } };
  e10 !== void 0 && (u17 = { asset_type: { _in: [s14, c16] } });
  let l20 = await B6({ aptosConfig: n27, accountAddress: a26, options: { where: u17 } });
  return l20[0] ? l20[0].amount : 0;
}
async function B6(o34) {
  let { aptosConfig: n27, accountAddress: t39, options: e10 } = o34, r30 = d7.from(t39).toStringLong(), s14 = { ...e10 == null ? void 0 : e10.where, owner_address: { _eq: r30 } }, c16 = { query: u3, variables: { where_condition: s14, offset: e10 == null ? void 0 : e10.offset, limit: e10 == null ? void 0 : e10.limit, order_by: e10 == null ? void 0 : e10.orderBy } };
  return (await a4({ aptosConfig: n27, query: c16, originMethod: "getAccountCoinsData" })).current_fungible_asset_balances;
}
async function ae(o34) {
  let { aptosConfig: n27, accountAddress: t39 } = o34, e10 = d7.from(t39).toStringLong(), s14 = await a4({ aptosConfig: n27, query: { query: _, variables: { address: e10 } }, originMethod: "getAccountCoinsCount" });
  if (!s14.current_fungible_asset_balances_aggregate.aggregate) throw Error("Failed to get the count of account coins");
  return s14.current_fungible_asset_balances_aggregate.aggregate.count;
}
async function de(o34) {
  let { aptosConfig: n27, accountAddress: t39, options: e10 } = o34, s14 = { owner_address: { _eq: d7.from(t39).toStringLong() } }, c16 = { query: v, variables: { where_condition: s14, offset: e10 == null ? void 0 : e10.offset, limit: e10 == null ? void 0 : e10.limit, order_by: e10 == null ? void 0 : e10.orderBy } };
  return (await a4({ aptosConfig: n27, query: c16, originMethod: "getAccountOwnedObjects" })).current_objects;
}
async function ue(o34) {
  let { aptosConfig: n27, privateKey: t39 } = o34, e10 = new f10(t39.publicKey());
  if (t39 instanceof v3) {
    let s14 = c6.fromPublicKey({ publicKey: e10 }).derivedAddress();
    return o24.fromPrivateKey({ privateKey: t39, address: s14 });
  }
  if (t39 instanceof U8) {
    let r30 = c6.fromPublicKey({ publicKey: e10 });
    if (await I3({ authKey: r30, aptosConfig: n27 })) {
      let u17 = r30.derivedAddress();
      return o24.fromPrivateKey({ privateKey: t39, address: u17, legacy: false });
    }
    let c16 = c6.fromPublicKey({ publicKey: e10.publicKey });
    if (await I3({ authKey: c16, aptosConfig: n27 })) {
      let u17 = c16.derivedAddress();
      return o24.fromPrivateKey({ privateKey: t39, address: u17, legacy: true });
    }
  }
  throw new Error(`Can't derive account from private key ${t39}`);
}
async function I3(o34) {
  let { aptosConfig: n27, authKey: t39 } = o34, e10 = await L5({ aptosConfig: n27, authenticationKey: t39.derivedAddress() });
  try {
    return await R4({ aptosConfig: n27, accountAddress: e10 }), true;
  } catch (r30) {
    if (r30.status === 404) return false;
    throw new Error(`Error while looking for an account info ${e10.toString()}`);
  }
}

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-AYX5JMB4.mjs
var Y2 = new TextEncoder();
function sn(n27) {
  return (n27 == null ? void 0 : n27.map((e10) => l5(e10) ? j4(e10) : e10)) ?? [];
}
async function W5(n27, e10, t39, u17) {
  let r30 = await Z({ aptosConfig: u17, accountAddress: n27, moduleName: e10 });
  if (r30.abi) return r30.abi.exposed_functions.find((o34) => o34.name === t39);
}
async function fn(n27, e10, t39, u17) {
  let r30 = await W5(n27, e10, t39, u17);
  if (!r30) throw new Error(`Could not find entry function ABI for '${n27}::${e10}::${t39}'`);
  if (!r30.is_entry) throw new Error(`'${n27}::${e10}::${t39}' is not an entry function`);
  let o34 = W4(r30), T13 = [];
  for (let f19 = o34; f19 < r30.params.length; f19 += 1) T13.push(j4(r30.params[f19], { allowGenerics: true }));
  return { signers: o34, typeParameters: r30.generic_type_params, parameters: T13 };
}
async function on(n27, e10, t39, u17) {
  let r30 = await W5(n27, e10, t39, u17);
  if (!r30) throw new Error(`Could not find view function ABI for '${n27}::${e10}::${t39}'`);
  if (!r30.is_view) throw new Error(`'${n27}::${e10}::${t39}' is not an view function`);
  let o34 = [];
  for (let f19 = 0; f19 < r30.params.length; f19 += 1) o34.push(j4(r30.params[f19], { allowGenerics: true }));
  let T13 = [];
  for (let f19 = 0; f19 < r30.return.length; f19 += 1) T13.push(j4(r30.return[f19], { allowGenerics: true }));
  return { typeParameters: r30.generic_type_params, parameters: o34, returnTypes: T13 };
}
function cn(n27, e10, t39, u17, r30) {
  if (u17 >= e10.parameters.length) throw new Error(`Too many arguments for '${n27}', expected ${e10.parameters.length}`);
  let o34 = e10.parameters[u17];
  return U10(t39, o34, u17, r30);
}
function U10(n27, e10, t39, u17) {
  return $3(n27) ? (p10(e10, n27, t39), n27) : Z2(n27, e10, t39, u17);
}
function Z2(n27, e10, t39, u17) {
  if (e10.isBool()) {
    if (D3(n27)) return new d9(n27);
    if (l5(n27)) {
      if (n27 === "true") return new d9(true);
      if (n27 === "false") return new d9(false);
    }
    R3("boolean", t39);
  }
  if (e10.isAddress()) {
    if (l5(n27)) return d7.fromString(n27);
    R3("string | AccountAddress", t39);
  }
  if (e10.isU8()) {
    let r30 = P2(n27);
    if (r30 !== void 0) return new U4(r30);
    R3("number | string", t39);
  }
  if (e10.isU16()) {
    let r30 = P2(n27);
    if (r30 !== void 0) return new p5(r30);
    R3("number | string", t39);
  }
  if (e10.isU32()) {
    let r30 = P2(n27);
    if (r30 !== void 0) return new b4(r30);
    R3("number | string", t39);
  }
  if (e10.isU64()) {
    if (w2(n27)) return new y6(BigInt(n27));
    R3("bigint | number | string", t39);
  }
  if (e10.isU128()) {
    if (w2(n27)) return new m8(BigInt(n27));
    R3("bigint | number | string", t39);
  }
  if (e10.isU256()) {
    if (w2(n27)) return new B3(BigInt(n27));
    R3("bigint | number | string", t39);
  }
  if (e10.isGeneric()) {
    let r30 = e10.value;
    if (r30 < 0 || r30 >= u17.length) throw new Error(`Generic argument ${e10.toString()} is invalid for argument ${t39}`);
    return U10(n27, u17[r30], t39, u17);
  }
  if (e10.isVector()) {
    if (e10.value.isU8()) {
      if (l5(n27)) return t15.U8(Y2.encode(n27));
      if (n27 instanceof Uint8Array) return t15.U8(n27);
      if (n27 instanceof ArrayBuffer) return t15.U8(new Uint8Array(n27));
    }
    if (Array.isArray(n27)) return new t15(n27.map((r30) => U10(r30, e10.value, t39, u17)));
    throw new Error(`Type mismatch for argument ${t39}, type '${e10.toString()}'`);
  }
  if (e10.isStruct()) {
    if (e10.isString()) {
      if (l5(n27)) return new a8(n27);
      R3("string", t39);
    }
    if (e10.isObject()) {
      if (l5(n27)) return d7.fromString(n27);
      R3("string | AccountAddress", t39);
    }
    if (e10.isOption()) {
      if (G3(n27)) {
        let r30 = e10.value.typeArgs[0];
        return r30 instanceof c5 ? new z4(null) : r30 instanceof S2 ? new z4(null) : r30 instanceof u7 ? new z4(null) : r30 instanceof d8 ? new z4(null) : r30 instanceof g4 ? new z4(null) : r30 instanceof p4 ? new z4(null) : r30 instanceof z3 ? new z4(null) : r30 instanceof T7 ? new z4(null) : new z4(null);
      }
      return new z4(U10(n27, e10.value.typeArgs[0], t39, u17));
    }
    throw new Error(`Unsupported struct input type for argument ${t39}, type '${e10.toString()}'`);
  }
  throw new Error(`Type mismatch for argument ${t39}, type '${e10.toString()}'`);
}
function p10(n27, e10, t39) {
  if (n27.isBool()) {
    if (T8(e10)) return;
    R3("Bool", t39);
  }
  if (n27.isAddress()) {
    if (E4(e10)) return;
    R3("AccountAddress", t39);
  }
  if (n27.isU8()) {
    if (B4(e10)) return;
    R3("U8", t39);
  }
  if (n27.isU16()) {
    if (U5(e10)) return;
    R3("U16", t39);
  }
  if (n27.isU32()) {
    if (b5(e10)) return;
    R3("U32", t39);
  }
  if (n27.isU64()) {
    if (I(e10)) return;
    R3("U64", t39);
  }
  if (n27.isU128()) {
    if (v2(e10)) return;
    R3("U128", t39);
  }
  if (n27.isU256()) {
    if (h6(e10)) return;
    R3("U256", t39);
  }
  if (n27.isVector()) {
    if (e10 instanceof t15) {
      e10.values.length > 0 && p10(n27.value, e10.values[0], t39);
      return;
    }
    R3("MoveVector", t39);
  }
  if (n27 instanceof b3) {
    if (n27.isString()) {
      if (x4(e10)) return;
      R3("MoveString", t39);
    }
    if (n27.isObject()) {
      if (E4(e10)) return;
      R3("AccountAddress", t39);
    }
    if (n27.isOption()) {
      if (e10 instanceof z4) {
        e10.value !== void 0 && p10(n27.value.typeArgs[0], e10.value, t39);
        return;
      }
      R3("MoveOption", t39);
    }
  }
  throw new Error(`Type mismatch for argument ${t39}, expected '${n27.toString()}'`);
}

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-Y3HLYCF3.mjs
var n22 = class extends B2 {
  static deserialize(e10) {
    let r30 = e10.deserializeUleb128AsU32();
    switch (r30) {
      case 0:
        return o25.load(e10);
      case 1:
        return d18.load(e10);
      case 2:
        return u12.load(e10);
      case 3:
        return l13.load(e10);
      case 4:
        return A12.load(e10);
      default:
        throw new Error(`Unknown variant index for TransactionAuthenticator: ${r30}`);
    }
  }
};
var o25 = class s7 extends n22 {
  constructor(e10, r30) {
    super(), this.public_key = e10, this.signature = r30;
  }
  serialize(e10) {
    e10.serializeU32AsUleb128(0), this.public_key.serialize(e10), this.signature.serialize(e10);
  }
  static load(e10) {
    let r30 = m10.deserialize(e10), t39 = h9.deserialize(e10);
    return new s7(r30, t39);
  }
};
var d18 = class s8 extends n22 {
  constructor(e10, r30) {
    super(), this.public_key = e10, this.signature = r30;
  }
  serialize(e10) {
    e10.serializeU32AsUleb128(1), this.public_key.serialize(e10), this.signature.serialize(e10);
  }
  static load(e10) {
    let r30 = d14.deserialize(e10), t39 = y8.deserialize(e10);
    return new s8(r30, t39);
  }
};
var u12 = class s9 extends n22 {
  constructor(e10, r30, t39) {
    super(), this.sender = e10, this.secondary_signer_addresses = r30, this.secondary_signers = t39;
  }
  serialize(e10) {
    e10.serializeU32AsUleb128(2), this.sender.serialize(e10), e10.serializeVector(this.secondary_signer_addresses), e10.serializeVector(this.secondary_signers);
  }
  static load(e10) {
    let r30 = r27.deserialize(e10), t39 = e10.deserializeVector(d7), c16 = e10.deserializeVector(r27);
    return new s9(r30, t39, c16);
  }
};
var l13 = class s10 extends n22 {
  constructor(e10, r30, t39, c16) {
    super(), this.sender = e10, this.secondary_signer_addresses = r30, this.secondary_signers = t39, this.fee_payer = c16;
  }
  serialize(e10) {
    e10.serializeU32AsUleb128(3), this.sender.serialize(e10), e10.serializeVector(this.secondary_signer_addresses), e10.serializeVector(this.secondary_signers), this.fee_payer.address.serialize(e10), this.fee_payer.authenticator.serialize(e10);
  }
  static load(e10) {
    let r30 = r27.deserialize(e10), t39 = e10.deserializeVector(d7), c16 = e10.deserializeVector(r27), _8 = d7.deserialize(e10), z9 = r27.deserialize(e10), S9 = { address: _8, authenticator: z9 };
    return new s10(r30, t39, c16, S9);
  }
};
var A12 = class s11 extends n22 {
  constructor(e10) {
    super(), this.sender = e10;
  }
  serialize(e10) {
    e10.serializeU32AsUleb128(4), this.sender.serialize(e10);
  }
  static load(e10) {
    let r30 = r27.deserialize(e10);
    return new s11(r30);
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-QV6EZL2G.mjs
var n23 = class o26 extends B2 {
  constructor(t39, a26) {
    super(), this.raw_txn = t39, this.authenticator = a26;
  }
  serialize(t39) {
    this.raw_txn.serialize(t39), this.authenticator.serialize(t39);
  }
  static deserialize(t39) {
    let a26 = t25.deserialize(t39), s14 = n22.deserialize(t39);
    return new o26(a26, s14);
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-ZXPBRVOA.mjs
var o27 = class t31 extends B2 {
  constructor(e10, r30) {
    super(), this.rawTransaction = e10, this.feePayerAddress = r30;
  }
  serialize(e10) {
    this.rawTransaction.serialize(e10), this.feePayerAddress === void 0 ? e10.serializeBool(false) : (e10.serializeBool(true), this.feePayerAddress.serialize(e10));
  }
  static deserialize(e10) {
    let r30 = t25.deserialize(e10), d24 = e10.deserializeBool(), s14;
    return d24 && (s14 = d7.deserialize(e10)), new t31(r30, s14);
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-76HTG7Z7.mjs
var o28 = class t32 extends B2 {
  constructor(e10, s14, r30) {
    super(), this.rawTransaction = e10, this.feePayerAddress = r30, this.secondarySignerAddresses = s14;
  }
  serialize(e10) {
    this.rawTransaction.serialize(e10), e10.serializeVector(this.secondarySignerAddresses), this.feePayerAddress === void 0 ? e10.serializeBool(false) : (e10.serializeBool(true), this.feePayerAddress.serialize(e10));
  }
  static deserialize(e10) {
    let s14 = t25.deserialize(e10), r30 = e10.deserializeVector(d7), c16 = e10.deserializeBool(), a26;
    return c16 && (a26 = d7.deserialize(e10)), new t32(s14, r30, a26);
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-BSUYPXRD.mjs
function t33(i49, r30) {
  let l20 = r30.bcsToBytes(), a26 = new n20(l20);
  return i49.deserialize(a26);
}

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-SCHZ67F3.mjs
var s12 = { mainnet: "https://api.mainnet.aptoslabs.com/v1/graphql", testnet: "https://api.testnet.aptoslabs.com/v1/graphql", devnet: "https://api.devnet.aptoslabs.com/v1/graphql", local: "http://127.0.0.1:8090/v1/graphql" };
var o29 = { mainnet: "https://api.mainnet.aptoslabs.com/v1", testnet: "https://api.testnet.aptoslabs.com/v1", devnet: "https://api.devnet.aptoslabs.com/v1", local: "http://127.0.0.1:8080/v1" };
var p11 = { mainnet: "https://faucet.mainnet.aptoslabs.com", testnet: "https://faucet.testnet.aptoslabs.com", devnet: "https://faucet.devnet.aptoslabs.com", local: "http://127.0.0.1:8081" };
var a21 = { mainnet: "https://api.mainnet.aptoslabs.com/keyless/pepper/v0", testnet: "https://api.testnet.aptoslabs.com/keyless/pepper/v0", devnet: "https://api.devnet.aptoslabs.com/keyless/pepper/v0", local: "https://api.devnet.aptoslabs.com/keyless/pepper/v0" };
var n24 = { mainnet: "https://api.mainnet.aptoslabs.com/keyless/prover/v0", testnet: "https://api.testnet.aptoslabs.com/keyless/prover/v0", devnet: "https://api.devnet.aptoslabs.com/keyless/prover/v0", local: "https://api.devnet.aptoslabs.com/keyless/prover/v0" };
var e8 = ((t39) => (t39.MAINNET = "mainnet", t39.TESTNET = "testnet", t39.DEVNET = "devnet", t39.LOCAL = "local", t39.CUSTOM = "custom", t39))(e8 || {});
var r28 = { mainnet: 1, testnet: 2, local: 4 };

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-YY2XW5R4.mjs
async function vn(n27) {
  if (O2(n27)) return yn(n27);
  let { moduleAddress: t39, moduleName: e10, functionName: i49 } = L2(n27.function), a26 = await on2({ key: "entry-function", moduleAddress: t39, moduleName: e10, functionName: i49, aptosConfig: n27.aptosConfig, abi: n27.abi, fetch: fn });
  return mn({ ...n27, abi: a26 });
}
function mn(n27) {
  let t39 = n27.abi, { moduleAddress: e10, moduleName: i49, functionName: a26 } = L2(n27.function), r30 = sn(n27.typeArguments);
  if (r30.length !== t39.typeParameters.length) throw new Error(`Type argument count mismatch, expected ${t39.typeParameters.length}, received ${r30.length}`);
  let o34 = n27.functionArguments.map((s14, d24) => cn(n27.function, t39, s14, d24, r30));
  if (o34.length !== t39.parameters.length) throw new Error(`Too few arguments for '${e10}::${i49}::${a26}', expected ${t39.parameters.length} but got ${o34.length}`);
  let c16 = l7.build(`${e10}::${i49}`, a26, r30, o34);
  if ("multisigAddress" in n27) {
    let s14 = d7.from(n27.multisigAddress);
    return new h7(new f6(s14, new b6(c16)));
  }
  return new z5(c16);
}
async function Kn(n27) {
  let { moduleAddress: t39, moduleName: e10, functionName: i49 } = L2(n27.function), a26 = await on2({ key: "view-function", moduleAddress: t39, moduleName: e10, functionName: i49, aptosConfig: n27.aptosConfig, abi: n27.abi, fetch: on });
  return An2({ abi: a26, ...n27 });
}
function An2(n27) {
  var _a;
  let t39 = n27.abi, { moduleAddress: e10, moduleName: i49, functionName: a26 } = L2(n27.function), r30 = sn(n27.typeArguments);
  if (r30.length !== t39.typeParameters.length) throw new Error(`Type argument count mismatch, expected ${t39.typeParameters.length}, received ${r30.length}`);
  let o34 = ((_a = n27 == null ? void 0 : n27.functionArguments) == null ? void 0 : _a.map((c16, s14) => cn(n27.function, t39, c16, s14, r30))) ?? [];
  if (o34.length !== t39.parameters.length) throw new Error(`Too few arguments for '${e10}::${i49}::${a26}', expected ${t39.parameters.length} but got ${o34.length}`);
  return l7.build(`${e10}::${i49}`, a26, r30, o34);
}
function yn(n27) {
  return new A8(new U6(i6.fromHexInput(n27.bytecode).toUint8Array(), sn(n27.typeArguments), n27.functionArguments));
}
async function fn2(n27) {
  let { aptosConfig: t39, sender: e10, payload: i49, options: a26, feePayerAddress: r30 } = n27, o34 = async () => r28[t39.network] ? { chainId: r28[t39.network] } : { chainId: (await d6({ aptosConfig: t39 })).chain_id }, c16 = async () => (a26 == null ? void 0 : a26.gasUnitPrice) ? { gasEstimate: a26.gasUnitPrice } : { gasEstimate: (await G2({ aptosConfig: t39 })).gas_estimate }, s14 = async () => {
    let g11 = async () => (a26 == null ? void 0 : a26.accountSequenceNumber) !== void 0 ? a26.accountSequenceNumber : (await R4({ aptosConfig: t39, accountAddress: e10 })).sequence_number;
    if (r30 && d7.from(r30).equals(d7.ZERO)) try {
      return await g11();
    } catch {
      return 0;
    }
    else return g11();
  }, [{ chainId: d24 }, { gasEstimate: m17 }, w5] = await Promise.all([o34(), c16(), s14()]), { maxGasAmount: sn3, gasUnitPrice: cn3, expireTimestamp: un2 } = { maxGasAmount: (a26 == null ? void 0 : a26.maxGasAmount) ? BigInt(a26.maxGasAmount) : BigInt(2e5), gasUnitPrice: (a26 == null ? void 0 : a26.gasUnitPrice) ?? BigInt(m17), expireTimestamp: (a26 == null ? void 0 : a26.expireTimestamp) ?? BigInt(Math.floor(Date.now() / 1e3) + 20) };
  return new t25(d7.from(e10), BigInt(w5), i49, BigInt(sn3), BigInt(cn3), BigInt(un2), new r9(d24));
}
async function On(n27) {
  var _a;
  let { aptosConfig: t39, sender: e10, payload: i49, options: a26, feePayerAddress: r30 } = n27, o34 = await fn2({ aptosConfig: t39, sender: e10, payload: i49, options: a26, feePayerAddress: r30 });
  if ("secondarySignerAddresses" in n27) {
    let c16 = ((_a = n27.secondarySignerAddresses) == null ? void 0 : _a.map((s14) => d7.from(s14))) ?? [];
    return new o28(o34, c16, n27.feePayerAddress ? d7.from(n27.feePayerAddress) : void 0);
  }
  return new o27(o34, n27.feePayerAddress ? d7.from(n27.feePayerAddress) : void 0);
}
function Vn2(n27) {
  let { signerPublicKey: t39, transaction: e10, secondarySignersPublicKeys: i49, feePayerPublicKey: a26 } = n27, r30 = h13(t39);
  if (e10.feePayerAddress) {
    let c16 = new p6(e10.rawTransaction, e10.secondarySignerAddresses ?? [], e10.feePayerAddress), s14 = [];
    i49 && (s14 = i49.map((w5) => h13(w5)));
    let d24 = h13(a26), m17 = new l13(r30, e10.secondarySignerAddresses ?? [], s14, { address: e10.feePayerAddress, authenticator: d24 });
    return new n23(c16.raw_txn, m17).bcsToBytes();
  }
  if (e10.secondarySignerAddresses) {
    let c16 = new u8(e10.rawTransaction, e10.secondarySignerAddresses), s14 = [];
    s14 = i49.map((m17) => h13(m17));
    let d24 = new u12(r30, e10.secondarySignerAddresses, s14);
    return new n23(c16.raw_txn, d24).bcsToBytes();
  }
  let o34;
  if (r30 instanceof u11) o34 = new o25(r30.public_key, r30.signature);
  else if (r30 instanceof n21) o34 = new A12(r30);
  else throw new Error("Invalid public key");
  return new n23(e10.rawTransaction, o34).bcsToBytes();
}
function h13(n27) {
  let t39 = new h9(new Uint8Array(64));
  if (m10.isInstance(n27)) return new u11(n27, t39);
  if (f10.isInstance(n27)) return A11.isInstance(n27.publicKey) ? new n21(n27, new l10(D6.getSimulationSignature())) : new n21(n27, new l10(t39));
  if (A11.isInstance(n27) || u9.isInstance(n27)) return console.warn("Expected AccountPublicKey, but got PublicKey. Please wrap your public key with AnyPublicKey."), new n21(new f10(n27), new l10(t39));
  throw new Error("Unsupported public key");
}
function gn2(n27) {
  let { transaction: t39, feePayerAuthenticator: e10, additionalSignersAuthenticators: i49 } = n27, a26 = t33(r27, n27.senderAuthenticator), r30;
  if (t39.feePayerAddress) {
    if (!e10) throw new Error("Must provide a feePayerAuthenticator argument to generate a signed fee payer transaction");
    r30 = new l13(a26, t39.secondarySignerAddresses ?? [], i49 ?? [], { address: t39.feePayerAddress, authenticator: e10 });
  } else if (t39.secondarySignerAddresses) {
    if (!i49) throw new Error("Must provide a additionalSignersAuthenticators argument to generate a signed multi agent transaction");
    r30 = new u12(a26, t39.secondarySignerAddresses, i49);
  } else a26 instanceof u11 ? r30 = new o25(a26.public_key, a26.signature) : r30 = new A12(a26);
  return new n23(t39.rawTransaction, r30).bcsToBytes();
}
function rn(n27) {
  let t39 = sha3_256.create();
  for (let e10 of n27) t39.update(e10);
  return t39.digest();
}
var pn = rn(["APTOS::Transaction"]);
async function on2({ key: n27, moduleAddress: t39, moduleName: e10, functionName: i49, aptosConfig: a26, abi: r30, fetch: o34 }) {
  return r30 !== void 0 ? r30 : m5(async () => o34(t39, e10, i49, a26), `${n27}-${a26.network}-${t39}-${e10}-${i49}`, 1e3 * 60 * 5)();
}

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-ECKJI2TV.mjs
var S6 = 1209600;
var i40 = class i41 extends B2 {
  constructor(e10) {
    super();
    let { privateKey: r30, expiryDateSecs: a26, blinder: n27 } = e10;
    this.privateKey = r30, this.publicKey = new c8(r30.publicKey()), this.expiryDateSecs = a26 || a5(u5() + S6), this.blinder = n27 !== void 0 ? i6.fromHexInput(n27).toUint8Array() : v4();
    let t39 = T9(this.publicKey.bcsToBytes(), 93);
    t39.push(BigInt(this.expiryDateSecs)), t39.push(L3(this.blinder));
    let x11 = k3(t39);
    this.nonce = x11.toString();
  }
  getPublicKey() {
    return this.publicKey;
  }
  isExpired() {
    return Math.floor(Date.now() / 1e3) > this.expiryDateSecs;
  }
  serialize(e10) {
    e10.serializeU32AsUleb128(this.publicKey.variant), e10.serializeBytes(this.privateKey.toUint8Array()), e10.serializeU64(this.expiryDateSecs), e10.serializeFixedBytes(this.blinder);
  }
  static deserialize(e10) {
    let r30 = e10.deserializeUleb128AsU32(), a26;
    switch (r30) {
      case 0:
        a26 = U8.deserialize(e10);
        break;
      default:
        throw new Error(`Unknown variant index for EphemeralPublicKey: ${r30}`);
    }
    let n27 = e10.deserializeU64(), t39 = e10.deserializeFixedBytes(31);
    return new i41({ privateKey: a26, expiryDateSecs: Number(n27), blinder: t39 });
  }
  static fromBytes(e10) {
    return i41.deserialize(new n20(e10));
  }
  static generate(e10) {
    let r30;
    switch (e10 == null ? void 0 : e10.scheme) {
      case 0:
      default:
        r30 = U8.generate();
    }
    return new i41({ privateKey: r30, expiryDateSecs: e10 == null ? void 0 : e10.expiryDateSecs });
  }
  sign(e10) {
    if (this.isExpired()) throw new Error("EphemeralKeyPair has expired");
    return new p8(this.privateKey.sign(e10));
  }
};
i40.BLINDER_LENGTH = 31;
var o30 = i40;
function v4() {
  return randomBytes(o30.BLINDER_LENGTH);
}

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-RA3YPQG2.mjs
var o31 = class o32 extends B2 {
  constructor(e10) {
    super();
    let { address: r30, ephemeralKeyPair: t39, uidKey: i49, uidVal: a26, aud: c16, pepper: p16, proof: n27, proofFetchCallback: s14, jwt: l20 } = e10;
    if (this.ephemeralKeyPair = t39, this.publicKey = A11.create(e10), this.accountAddress = r30 ? d7.from(r30) : this.publicKey.authKey().derivedAddress(), this.uidKey = i49, this.uidVal = a26, this.aud = c16, this.jwt = l20, this.emitter = new eventemitter3_default(), this.proofOrPromise = n27, n27 instanceof S5) this.proof = n27;
    else {
      if (s14 === void 0) throw new Error("Must provide callback for async proof fetch");
      this.emitter.on("proofFetchFinish", async (u17) => {
        await s14(u17), this.emitter.removeAllListeners();
      }), this.init(n27);
    }
    this.signingScheme = 2;
    let h19 = i6.fromHexInput(p16).toUint8Array();
    if (h19.length !== o32.PEPPER_LENGTH) throw new Error(`Pepper length in bytes should be ${o32.PEPPER_LENGTH}`);
    this.pepper = h19;
  }
  async init(e10) {
    try {
      this.proof = await e10, this.emitter.emit("proofFetchFinish", { status: "Success" });
    } catch (r30) {
      r30 instanceof Error ? this.emitter.emit("proofFetchFinish", { status: "Failed", error: r30.toString() }) : this.emitter.emit("proofFetchFinish", { status: "Failed", error: "Unknown" });
    }
  }
  serialize(e10) {
    if (e10.serializeStr(this.jwt), e10.serializeStr(this.uidKey), e10.serializeFixedBytes(this.pepper), this.ephemeralKeyPair.serialize(e10), this.proof === void 0) throw new Error("Connot serialize - proof undefined");
    this.proof.serialize(e10);
  }
  static deserialize(e10) {
    let r30 = e10.deserializeStr(), t39 = e10.deserializeStr(), i49 = e10.deserializeFixedBytes(31), a26 = o30.deserialize(e10), c16 = S5.deserialize(e10);
    return o32.create({ proof: c16, pepper: i49, uidKey: t39, jwt: r30, ephemeralKeyPair: a26 });
  }
  isExpired() {
    return this.ephemeralKeyPair.isExpired();
  }
  signWithAuthenticator(e10) {
    let r30 = new l10(this.sign(e10)), t39 = new f10(this.publicKey);
    return new n21(t39, r30);
  }
  signTransactionWithAuthenticator(e10) {
    let r30 = new l10(this.signTransaction(e10)), t39 = new f10(this.publicKey);
    return new n21(t39, r30);
  }
  async waitForProofFetch() {
    this.proofOrPromise instanceof Promise && await this.proofOrPromise;
  }
  sign(e10) {
    let { expiryDateSecs: r30 } = this.ephemeralKeyPair;
    if (this.isExpired()) throw new Error("EphemeralKeyPair is expired");
    if (this.proof === void 0) throw new Error("Proof not defined");
    let t39 = this.ephemeralKeyPair.getPublicKey(), i49 = this.ephemeralKeyPair.sign(e10);
    return new D6({ jwtHeader: m6(this.jwt.split(".")[0]), ephemeralCertificate: new h11(this.proof, 0), expiryDateSecs: r30, ephemeralPublicKey: t39, ephemeralSignature: i49 });
  }
  signTransaction(e10) {
    if (this.proof === void 0) throw new Error("Proof not found");
    let r30 = d11(e10), i49 = new P4(r30, this.proof.proof).hash();
    return this.sign(i49);
  }
  verifySignature(e10) {
    let { message: r30, signature: t39 } = e10;
    return !(this.isExpired() || !this.ephemeralKeyPair.getPublicKey().verifySignature({ message: r30, signature: t39.ephemeralSignature }));
  }
  static fromBytes(e10) {
    return o32.deserialize(new n20(e10));
  }
  static create(e10) {
    let { address: r30, proof: t39, jwt: i49, ephemeralKeyPair: a26, pepper: c16, uidKey: p16 = "sub", proofFetchCallback: n27 } = e10, s14 = jwtDecode(i49), l20 = s14.iss;
    if (typeof s14.aud != "string") throw new Error("aud was not found or an array of values");
    let h19 = s14.aud, u17 = s14[p16];
    return new o32({ address: r30, proof: t39, ephemeralKeyPair: a26, iss: l20, uidKey: p16, uidVal: u17, aud: h19, pepper: c16, jwt: i49, proofFetchCallback: n27 });
  }
};
o31.PEPPER_LENGTH = 31;
var k4 = o31;
var P4 = class extends B2 {
  constructor(r30, t39) {
    super();
    this.domainSeparator = "APTOS::TransactionAndProof";
    this.transaction = r30, this.proof = t39;
  }
  serialize(r30) {
    r30.serializeFixedBytes(this.transaction.bcsToBytes()), r30.serializeOption(this.proof);
  }
  hash() {
    return n19(this.bcsToBytes(), this.domainSeparator);
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-EZIF26UH.mjs
var l14 = class a22 {
  constructor(i49) {
    let { multiKey: s14, signers: e10 } = i49;
    this.publicKey = s14, this.signingScheme = 3, this.accountAddress = this.publicKey.authKey().derivedAddress();
    let r30 = [];
    for (let t39 of e10) r30.push(this.publicKey.getIndex(t39.publicKey));
    let n27 = e10.map((t39, c16) => [t39, r30[c16]]);
    n27.sort((t39, c16) => t39[1] - c16[1]), this.signers = n27.map((t39) => t39[0]), this.signerIndicies = n27.map((t39) => t39[1]), this.signaturesBitmap = this.publicKey.createBitmap({ bits: r30 });
  }
  static fromPublicKeysAndSigners(i49) {
    let { publicKeys: s14, signaturesRequired: e10, signers: r30 } = i49, n27 = new f11({ publicKeys: s14, signaturesRequired: e10 });
    return new a22({ multiKey: n27, signers: r30 });
  }
  static isMultiKeySigner(i49) {
    return i49 instanceof a22;
  }
  signWithAuthenticator(i49) {
    return new a19(this.publicKey, this.sign(i49));
  }
  signTransactionWithAuthenticator(i49) {
    return new a19(this.publicKey, this.signTransaction(i49));
  }
  async waitForProofFetch() {
    let s14 = this.signers.filter((e10) => e10 instanceof k4).map(async (e10) => e10.waitForProofFetch());
    await Promise.all(s14);
  }
  sign(i49) {
    let s14 = [];
    for (let e10 of this.signers) s14.push(e10.sign(i49));
    return new p9({ signatures: s14, bitmap: this.signaturesBitmap });
  }
  signTransaction(i49) {
    let s14 = [];
    for (let e10 of this.signers) s14.push(e10.signTransaction(i49));
    return new p9({ signatures: s14, bitmap: this.signaturesBitmap });
  }
  verifySignature(i49) {
    let { message: s14, signature: e10 } = i49;
    if (!this.signerIndicies.every((n27, t39) => t39 === 0 || n27 >= this.signerIndicies[t39 - 1])) return false;
    for (let n27 = 0; n27 < e10.signatures.length; n27 += 1) {
      let t39 = e10.signatures[n27];
      if (!this.publicKey.publicKeys[this.signerIndicies[n27]].verifySignature({ message: s14, signature: t39 })) return false;
    }
    return true;
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-HKMG3LZX.mjs
var c12 = class extends B2 {
  constructor(e10) {
    super();
    this.accountAddress = d7.ONE;
    this.moduleName = new a8("account");
    this.structName = new a8("RotationProofChallenge");
    this.sequenceNumber = new y6(e10.sequenceNumber), this.originator = e10.originator, this.currentAuthKey = e10.currentAuthKey, this.newPublicKey = t15.U8(e10.newPublicKey.toUint8Array());
  }
  serialize(e10) {
    e10.serialize(this.accountAddress), e10.serialize(this.moduleName), e10.serialize(this.structName), e10.serialize(this.sequenceNumber), e10.serialize(this.originator), e10.serialize(this.currentAuthKey), e10.serialize(this.newPublicKey);
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-F7NVDHR2.mjs
async function h14(t39) {
  let a26 = await D7(t39);
  return G4(t39, a26);
}
async function D7(t39) {
  let { aptosConfig: a26, data: n27 } = t39, e10, o34;
  return "bytecode" in n27 ? o34 = await vn(n27) : "multisigAddress" in n27 ? (e10 = { aptosConfig: a26, multisigAddress: n27.multisigAddress, function: n27.function, functionArguments: n27.functionArguments, typeArguments: n27.typeArguments, abi: n27.abi }, o34 = await vn(e10)) : (e10 = { aptosConfig: a26, function: n27.function, functionArguments: n27.functionArguments, typeArguments: n27.typeArguments, abi: n27.abi }, o34 = await vn(e10)), o34;
}
async function G4(t39, a26) {
  let { aptosConfig: n27, sender: e10, options: o34 } = t39, i49;
  if (K2(t39) && (i49 = d7.ZERO.toString()), U11(t39)) {
    let { secondarySignerAddresses: c16 } = t39;
    return On({ aptosConfig: n27, sender: e10, payload: a26, options: o34, secondarySignerAddresses: c16, feePayerAddress: i49 });
  }
  return On({ aptosConfig: n27, sender: e10, payload: a26, options: o34, feePayerAddress: i49 });
}
function K2(t39) {
  return t39.withFeePayer === true;
}
function U11(t39) {
  return "secondarySignerAddresses" in t39;
}
function Y3(t39) {
  let { transaction: a26 } = t39;
  return S4(a26);
}
function _5(t39) {
  let { signer: a26, transaction: n27 } = t39;
  return a26.signTransactionWithAuthenticator(n27);
}
async function $5(t39) {
  var _a, _b, _c;
  let { aptosConfig: a26, transaction: n27, signerPublicKey: e10, secondarySignersPublicKeys: o34, feePayerPublicKey: i49, options: c16 } = t39, u17 = Vn2({ transaction: n27, signerPublicKey: e10, secondarySignersPublicKeys: o34, feePayerPublicKey: i49, options: c16 }), { data: m17 } = await q2({ aptosConfig: a26, body: u17, path: "transactions/simulate", params: { estimate_gas_unit_price: ((_a = t39.options) == null ? void 0 : _a.estimateGasUnitPrice) ?? false, estimate_max_gas_amount: ((_b = t39.options) == null ? void 0 : _b.estimateMaxGasAmount) ?? false, estimate_prioritized_gas_unit_price: ((_c = t39.options) == null ? void 0 : _c.estimatePrioritizedGasUnitPrice) ?? false }, originMethod: "simulateTransaction", contentType: "application/x.aptos.signed_transaction+bcs" });
  return m17;
}
async function B7(t39) {
  let { aptosConfig: a26 } = t39, n27 = gn2({ ...t39 }), { data: e10 } = await q2({ aptosConfig: a26, body: n27, path: "transactions", originMethod: "submitTransaction", contentType: "application/x.aptos.signed_transaction+bcs" });
  return e10;
}
async function M(t39) {
  let { aptosConfig: a26, signer: n27, transaction: e10 } = t39;
  (n27 instanceof k4 || n27 instanceof l14) && await n27.waitForProofFetch();
  let o34 = _5({ signer: n27, transaction: e10 });
  return B7({ aptosConfig: a26, transaction: e10, senderAuthenticator: o34 });
}
var N3 = { typeParameters: [], parameters: [y5.u8(), new y5(y5.u8())] };
async function nn(t39) {
  let { aptosConfig: a26, account: n27, metadataBytes: e10, moduleBytecode: o34, options: i49 } = t39, c16 = o34.map((u17) => t15.U8(u17));
  return h14({ aptosConfig: a26, sender: d7.from(n27), data: { function: "0x1::code::publish_package_txn", functionArguments: [t15.U8(e10), new t15(c16)], abi: N3 }, options: i49 });
}
var F3 = { typeParameters: [], parameters: [new u7(), y5.u8(), new u7(), y5.u8(), y5.u8(), y5.u8()] };
async function tn(t39) {
  let { aptosConfig: a26, fromAccount: n27, toNewPrivateKey: e10 } = t39, o34 = await R4({ aptosConfig: a26, accountAddress: n27.accountAddress }), i49 = o24.fromPrivateKey({ privateKey: e10, legacy: true }), u17 = new c12({ sequenceNumber: BigInt(o34.sequence_number), originator: n27.accountAddress, currentAuthKey: d7.from(o34.authentication_key), newPublicKey: i49.publicKey }).bcsToBytes(), m17 = n27.sign(u17), R7 = i49.sign(u17), x11 = await h14({ aptosConfig: a26, sender: n27.accountAddress, data: { function: "0x1::account::rotate_authentication_key", functionArguments: [new U4(n27.signingScheme), t15.U8(n27.publicKey.toUint8Array()), new U4(i49.signingScheme), t15.U8(i49.publicKey.toUint8Array()), t15.U8(m17.toUint8Array()), t15.U8(R7.toUint8Array())], abi: F3 } });
  return M({ aptosConfig: a26, signer: n27, transaction: x11 });
}

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-2N2VEGT6.mjs
var i42 = class {
  constructor(n27) {
    this.config = n27;
  }
  async simple(n27) {
    return $5({ aptosConfig: this.config, ...n27 });
  }
  async multiAgent(n27) {
    return $5({ aptosConfig: this.config, ...n27 });
  }
};
j2([u6], i42.prototype, "simple", 1), j2([u6], i42.prototype, "multiAgent", 1);

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-ZQFFRZJ4.mjs
var n25 = class {
  constructor(t39) {
    this.config = t39;
  }
  async simple(t39) {
    return B7({ aptosConfig: this.config, ...t39 });
  }
  async multiAgent(t39) {
    return B7({ aptosConfig: this.config, ...t39 });
  }
};
j2([o12], n25.prototype, "simple", 1), j2([o12], n25.prototype, "multiAgent", 1);

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-UV7M72QD.mjs
var o33 = class {
  constructor(n27) {
    this.config = n27;
  }
  async simple(n27) {
    return h14({ aptosConfig: this.config, ...n27 });
  }
  async multiAgent(n27) {
    return h14({ aptosConfig: this.config, ...n27 });
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-2CC67KW5.mjs
var r29 = class {
  constructor(t39, i49, o34, a26, c16) {
    this.lastUncommintedNumber = null;
    this.currentNumber = null;
    this.lock = false;
    this.aptosConfig = t39, this.account = i49, this.maxWaitTime = o34, this.maximumInFlight = a26, this.sleepTime = c16;
  }
  async nextSequenceNumber() {
    for (; this.lock; ) await c4(this.sleepTime);
    this.lock = true;
    let t39 = BigInt(0);
    try {
      if ((this.lastUncommintedNumber === null || this.currentNumber === null) && await this.initialize(), this.currentNumber - this.lastUncommintedNumber >= this.maximumInFlight) {
        await this.update();
        let i49 = u5();
        for (; this.currentNumber - this.lastUncommintedNumber >= this.maximumInFlight; ) await c4(this.sleepTime), u5() - i49 > this.maxWaitTime ? (console.warn(`Waited over 30 seconds for a transaction to commit, resyncing ${this.account.accountAddress.toString()}`), await this.initialize()) : await this.update();
      }
      t39 = this.currentNumber, this.currentNumber += BigInt(1);
    } catch (i49) {
      console.error("error in getting next sequence number for this account", i49);
    } finally {
      this.lock = false;
    }
    return t39;
  }
  async initialize() {
    let { sequence_number: t39 } = await R4({ aptosConfig: this.aptosConfig, accountAddress: this.account.accountAddress });
    this.currentNumber = BigInt(t39), this.lastUncommintedNumber = BigInt(t39);
  }
  async update() {
    let { sequence_number: t39 } = await R4({ aptosConfig: this.aptosConfig, accountAddress: this.account.accountAddress });
    return this.lastUncommintedNumber = BigInt(t39), this.lastUncommintedNumber;
  }
  async synchronize() {
    if (this.lastUncommintedNumber !== this.currentNumber) {
      for (; this.lock; ) await c4(this.sleepTime);
      this.lock = true;
      try {
        await this.update();
        let t39 = u5();
        for (; this.lastUncommintedNumber !== this.currentNumber; ) u5() - t39 > this.maxWaitTime ? (console.warn(`Waited over 30 seconds for a transaction to commit, resyncing ${this.account.accountAddress.toString()}`), await this.initialize()) : (await c4(this.sleepTime), await this.update());
      } catch (t39) {
        console.error("error in synchronizing this account sequence number with the one on chain", t39);
      } finally {
        this.lock = false;
      }
    }
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-U6Z4FNB7.mjs
var i43 = class {
  constructor() {
    this.queue = [];
    this.pendingDequeue = [];
    this.cancelled = false;
  }
  enqueue(e10) {
    var _a;
    if (this.cancelled = false, this.pendingDequeue.length > 0) {
      (_a = this.pendingDequeue.shift()) == null ? void 0 : _a.resolve(e10);
      return;
    }
    this.queue.push(e10);
  }
  async dequeue() {
    return this.queue.length > 0 ? Promise.resolve(this.queue.shift()) : new Promise((e10, u17) => {
      this.pendingDequeue.push({ resolve: e10, reject: u17 });
    });
  }
  isEmpty() {
    return this.queue.length === 0;
  }
  cancel() {
    this.cancelled = true, this.pendingDequeue.forEach(async ({ reject: e10 }) => {
      e10(new n26("Task cancelled"));
    }), this.pendingDequeue = [], this.queue.length = 0;
  }
  isCancelled() {
    return this.cancelled;
  }
  pendingDequeueLength() {
    return this.pendingDequeue.length;
  }
};
var n26 = class extends Error {
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-HRIYZBXY.mjs
var m13 = "fulfilled";
var f12 = ((n27) => (n27.TransactionSent = "transactionSent", n27.TransactionSendFailed = "transactionSendFailed", n27.TransactionExecuted = "transactionExecuted", n27.TransactionExecutionFailed = "transactionExecutionFailed", n27.ExecutionFinish = "executionFinish", n27))(f12 || {});
var p12 = class extends eventemitter3_default {
  constructor(t39, e10, a26 = 30, n27 = 100, i49 = 10) {
    super();
    this.taskQueue = new i43();
    this.transactionsQueue = new i43();
    this.outstandingTransactions = new i43();
    this.sentTransactions = [];
    this.executedTransactions = [];
    this.aptosConfig = t39, this.account = e10, this.started = false, this.accountSequnceNumber = new r29(t39, e10, a26, n27, i49);
  }
  async submitNextTransaction() {
    try {
      for (; ; ) {
        let t39 = await this.accountSequnceNumber.nextSequenceNumber();
        if (t39 === null) return;
        let e10 = await this.generateNextTransaction(this.account, t39);
        if (!e10) return;
        let a26 = M({ aptosConfig: this.aptosConfig, transaction: e10, signer: this.account });
        await this.outstandingTransactions.enqueue([a26, t39]);
      }
    } catch (t39) {
      if (t39 instanceof n26) return;
      throw new Error(`Submit transaction failed for ${this.account.accountAddress.toString()} with error ${t39}`);
    }
  }
  async processTransactions() {
    try {
      for (; ; ) {
        let t39 = [], e10 = [], [a26, n27] = await this.outstandingTransactions.dequeue();
        for (t39.push(a26), e10.push(n27); !this.outstandingTransactions.isEmpty(); ) [a26, n27] = await this.outstandingTransactions.dequeue(), t39.push(a26), e10.push(n27);
        let i49 = await Promise.allSettled(t39);
        for (let s14 = 0; s14 < i49.length && s14 < e10.length; s14 += 1) {
          let r30 = i49[s14];
          n27 = e10[s14], r30.status === m13 ? (this.sentTransactions.push([r30.value.hash, n27, null]), this.emit("transactionSent", { message: `transaction hash ${r30.value.hash} has been committed to chain`, transactionHash: r30.value.hash }), await this.checkTransaction(r30, n27)) : (this.sentTransactions.push([r30.status, n27, r30.reason]), this.emit("transactionSendFailed", { message: `failed to commit transaction ${this.sentTransactions.length} with error ${r30.reason}`, error: r30.reason }));
        }
        this.emit("executionFinish", { message: `execute ${i49.length} transactions finished` });
      }
    } catch (t39) {
      if (t39 instanceof n26) return;
      throw new Error(`Process execution failed for ${this.account.accountAddress.toString()} with error ${t39}`);
    }
  }
  async checkTransaction(t39, e10) {
    try {
      let a26 = [];
      a26.push(q3({ aptosConfig: this.aptosConfig, transactionHash: t39.value.hash }));
      let n27 = await Promise.allSettled(a26);
      for (let i49 = 0; i49 < n27.length; i49 += 1) {
        let s14 = n27[i49];
        s14.status === m13 ? (this.executedTransactions.push([s14.value.hash, e10, null]), this.emit("transactionExecuted", { message: `transaction hash ${s14.value.hash} has been executed on chain`, transactionHash: t39.value.hash })) : (this.executedTransactions.push([s14.status, e10, s14.reason]), this.emit("transactionExecutionFailed", { message: `failed to execute transaction ${this.executedTransactions.length} with error ${s14.reason}`, error: s14.reason }));
      }
    } catch (a26) {
      throw new Error(`Check transaction failed for ${this.account.accountAddress.toString()} with error ${a26}`);
    }
  }
  async push(t39, e10) {
    this.transactionsQueue.enqueue([t39, e10]);
  }
  async generateNextTransaction(t39, e10) {
    if (this.transactionsQueue.isEmpty()) return;
    let [a26, n27] = await this.transactionsQueue.dequeue();
    return h14({ aptosConfig: this.aptosConfig, sender: t39.accountAddress, data: a26, options: { ...n27, accountSequenceNumber: e10 } });
  }
  async run() {
    try {
      for (; !this.taskQueue.isCancelled(); ) await (await this.taskQueue.dequeue())();
    } catch (t39) {
      throw new Error(`Unable to start transaction batching: ${t39}`);
    }
  }
  start() {
    if (this.started) throw new Error("worker has already started");
    this.started = true, this.taskQueue.enqueue(() => this.submitNextTransaction()), this.taskQueue.enqueue(() => this.processTransactions()), this.run();
  }
  stop() {
    if (this.taskQueue.isCancelled()) throw new Error("worker has already stopped");
    this.started = false, this.taskQueue.cancel();
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-FNT3VLRD.mjs
var i44 = class extends eventemitter3_default {
  constructor(t39) {
    super(), this.config = t39;
  }
  start(t39) {
    let { sender: n27 } = t39;
    this.account = n27, this.transactionWorker = new p12(this.config, n27), this.transactionWorker.start(), this.registerToEvents();
  }
  push(t39) {
    let { data: n27, options: o34 } = t39;
    for (let r30 of n27) this.transactionWorker.push(r30, o34);
  }
  registerToEvents() {
    this.transactionWorker.on("transactionSent", async (t39) => {
      this.emit("transactionSent", t39);
    }), this.transactionWorker.on("transactionSendFailed", async (t39) => {
      this.emit("transactionSendFailed", t39);
    }), this.transactionWorker.on("transactionExecuted", async (t39) => {
      this.emit("transactionExecuted", t39);
    }), this.transactionWorker.on("transactionExecutionFailed", async (t39) => {
      this.emit("transactionExecutionFailed", t39);
    }), this.transactionWorker.on("executionFinish", async (t39) => {
      this.emit("executionFinish", t39);
    });
  }
  forSingleAccount(t39) {
    try {
      let { sender: n27, data: o34, options: r30 } = t39;
      this.start({ sender: n27 }), this.push({ data: o34, options: r30 });
    } catch (n27) {
      throw new Error(`failed to submit transactions with error: ${n27}`);
    }
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-74YFNJ7A.mjs
var h15 = class {
  constructor(n27) {
    this.config = n27, this.build = new o33(this.config), this.simulate = new i42(this.config), this.submit = new n25(this.config), this.batch = new i44(this.config);
  }
  async getTransactions(n27) {
    return H({ aptosConfig: this.config, ...n27 });
  }
  async getTransactionByVersion(n27) {
    return W2({ aptosConfig: this.config, ...n27 });
  }
  async getTransactionByHash(n27) {
    return y4({ aptosConfig: this.config, ...n27 });
  }
  async isPendingTransaction(n27) {
    return O({ aptosConfig: this.config, ...n27 });
  }
  async waitForTransaction(n27) {
    return q3({ aptosConfig: this.config, ...n27 });
  }
  async getGasPriceEstimation() {
    return G2({ aptosConfig: this.config });
  }
  getSigningMessage(n27) {
    return Y3(n27);
  }
  async publishPackageTransaction(n27) {
    return nn({ aptosConfig: this.config, ...n27 });
  }
  async rotateAuthKey(n27) {
    return tn({ aptosConfig: this.config, ...n27 });
  }
  sign(n27) {
    return _5({ ...n27 });
  }
  signAsFeePayer(n27) {
    let { signer: t39, transaction: o34 } = n27;
    if (!o34.feePayerAddress) throw new Error(`Transaction ${o34} is not a Fee Payer transaction`);
    return o34.feePayerAddress = t39.accountAddress, _5({ signer: t39, transaction: o34 });
  }
  async batchTransactionsForSingleAccount(n27) {
    try {
      let { sender: t39, data: o34, options: P8 } = n27;
      this.batch.forSingleAccount({ sender: t39, data: o34, options: P8 });
    } catch (t39) {
      throw new Error(`failed to submit transactions with error: ${t39}`);
    }
  }
  async signAndSubmitTransaction(n27) {
    let { signer: t39, transaction: o34 } = n27;
    return M({ aptosConfig: this.config, signer: t39, transaction: o34 });
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-WABFFJGI.mjs
var a23 = 300;
var u13 = (t39) => {
  if (t39 && t39.length > a23) throw new Error(`Event type length exceeds the maximum length of ${a23}`);
};
async function m14(t39) {
  let { aptosConfig: o34, eventType: e10, options: n27 } = t39;
  return p13({ aptosConfig: o34, options: { ...n27, where: { account_address: { _eq: "0x0000000000000000000000000000000000000000000000000000000000000000" }, creation_number: { _eq: "0" }, sequence_number: { _eq: "0" }, indexed_type: { _eq: e10 } } } });
}
async function f13(t39) {
  let { accountAddress: o34, aptosConfig: e10, creationNumber: n27, options: s14 } = t39, r30 = { account_address: { _eq: d7.from(o34).toStringLong() }, creation_number: { _eq: n27 } };
  return p13({ aptosConfig: e10, options: { ...s14, where: r30 } });
}
async function _6(t39) {
  let { accountAddress: o34, aptosConfig: e10, eventType: n27, options: s14 } = t39, r30 = { account_address: { _eq: d7.from(o34).toStringLong() }, indexed_type: { _eq: n27 } };
  return p13({ aptosConfig: e10, options: { ...s14, where: r30 } });
}
async function p13(t39) {
  var _a, _b;
  let { aptosConfig: o34, options: e10 } = t39;
  u13((_b = (_a = e10 == null ? void 0 : e10.where) == null ? void 0 : _a.indexed_type) == null ? void 0 : _b._eq);
  let n27 = { query: k, variables: { where_condition: e10 == null ? void 0 : e10.where, offset: e10 == null ? void 0 : e10.offset, limit: e10 == null ? void 0 : e10.limit, order_by: e10 == null ? void 0 : e10.orderBy } };
  return (await a4({ aptosConfig: o34, query: n27, originMethod: "getEvents" })).events;
}

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-GHKMF253.mjs
var i45 = class {
  constructor(e10) {
    this.config = e10;
  }
  async getModuleEventsByEventType(e10) {
    return await i5({ config: this.config, minimumLedgerVersion: e10.minimumLedgerVersion, processorType: "events_processor" }), m14({ aptosConfig: this.config, ...e10 });
  }
  async getAccountEventsByCreationNumber(e10) {
    return await i5({ config: this.config, minimumLedgerVersion: e10.minimumLedgerVersion, processorType: "events_processor" }), f13({ aptosConfig: this.config, ...e10 });
  }
  async getAccountEventsByEventType(e10) {
    return await i5({ config: this.config, minimumLedgerVersion: e10.minimumLedgerVersion, processorType: "events_processor" }), _6({ aptosConfig: this.config, ...e10 });
  }
  async getEvents(e10) {
    return await i5({ config: this.config, minimumLedgerVersion: e10 == null ? void 0 : e10.minimumLedgerVersion, processorType: "events_processor" }), p13({ aptosConfig: this.config, ...e10 });
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-NCWD4NA3.mjs
async function x8(a26) {
  let { aptosConfig: t39, accountAddress: i49, amount: p16, options: n27 } = a26, u17 = (n27 == null ? void 0 : n27.timeoutSecs) || 20, { data: d24 } = await m4({ aptosConfig: t39, path: "fund", body: { address: d7.from(i49).toString(), amount: p16 }, originMethod: "fundAccount" }), m17 = d24.txn_hashes[0], o34 = await q3({ aptosConfig: t39, transactionHash: m17, options: { timeoutSecs: u17, checkSuccess: n27 == null ? void 0 : n27.checkSuccess } });
  if (o34.type === "user_transaction") return o34;
  throw new Error(`Unexpected transaction received for fund account: ${o34.type}`);
}

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-FOHGSNYZ.mjs
var i46 = class {
  constructor(o34) {
    this.config = o34;
  }
  async fundAccount(o34) {
    var _a, _b;
    let n27 = await x8({ aptosConfig: this.config, ...o34 });
    return (((_a = o34.options) == null ? void 0 : _a.waitForIndexer) === void 0 || ((_b = o34.options) == null ? void 0 : _b.waitForIndexer)) && await z({ aptosConfig: this.config, minimumLedgerVersion: BigInt(n27.version), processorType: "fungible_asset_processor" }), n27;
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-WFOYGJS5.mjs
async function G5(t39) {
  let { aptosConfig: s14, options: e10 } = t39, n27 = { query: h2, variables: { where_condition: e10 == null ? void 0 : e10.where, limit: e10 == null ? void 0 : e10.limit, offset: e10 == null ? void 0 : e10.offset } };
  return (await a4({ aptosConfig: s14, query: n27, originMethod: "getFungibleAssetMetadata" })).fungible_asset_metadata;
}
async function h16(t39) {
  let { aptosConfig: s14, options: e10 } = t39, n27 = { query: f4, variables: { where_condition: e10 == null ? void 0 : e10.where, limit: e10 == null ? void 0 : e10.limit, offset: e10 == null ? void 0 : e10.offset } };
  return (await a4({ aptosConfig: s14, query: n27, originMethod: "getFungibleAssetActivities" })).fungible_asset_activities;
}
async function M2(t39) {
  let { aptosConfig: s14, options: e10 } = t39, n27 = { query: b, variables: { where_condition: e10 == null ? void 0 : e10.where, limit: e10 == null ? void 0 : e10.limit, offset: e10 == null ? void 0 : e10.offset } };
  return (await a4({ aptosConfig: s14, query: n27, originMethod: "getCurrentFungibleAssetBalances" })).current_fungible_asset_balances;
}
var b8 = { typeParameters: [{ constraints: [] }], parameters: [j4("0x1::object::Object"), new S2(), new p4()] };
async function x9(t39) {
  let { aptosConfig: s14, sender: e10, fungibleAssetMetadataAddress: n27, recipient: i49, amount: l20, options: f19 } = t39;
  return h14({ aptosConfig: s14, sender: e10.accountAddress, data: { function: "0x1::primary_fungible_store::transfer", typeArguments: ["0x1::fungible_asset::Metadata"], functionArguments: [n27, i49, l20], abi: b8 }, options: f19 });
}

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-H33YIMTU.mjs
var a24 = class {
  constructor(e10) {
    this.config = e10;
  }
  async getFungibleAssetMetadata(e10) {
    return await i5({ config: this.config, minimumLedgerVersion: e10 == null ? void 0 : e10.minimumLedgerVersion, processorType: "fungible_asset_processor" }), G5({ aptosConfig: this.config, ...e10 });
  }
  async getFungibleAssetMetadataByAssetType(e10) {
    return await i5({ config: this.config, minimumLedgerVersion: e10 == null ? void 0 : e10.minimumLedgerVersion, processorType: "fungible_asset_processor" }), (await G5({ aptosConfig: this.config, options: { where: { asset_type: { _eq: e10.assetType } } } }))[0];
  }
  async getFungibleAssetMetadataByCreatorAddress(e10) {
    return await i5({ config: this.config, minimumLedgerVersion: e10 == null ? void 0 : e10.minimumLedgerVersion, processorType: "fungible_asset_processor" }), await G5({ aptosConfig: this.config, options: { where: { creator_address: { _eq: d7.from(e10.creatorAddress).toStringLong() } } } });
  }
  async getFungibleAssetActivities(e10) {
    return await i5({ config: this.config, minimumLedgerVersion: e10 == null ? void 0 : e10.minimumLedgerVersion, processorType: "fungible_asset_processor" }), h16({ aptosConfig: this.config, ...e10 });
  }
  async getCurrentFungibleAssetBalances(e10) {
    return await i5({ config: this.config, minimumLedgerVersion: e10 == null ? void 0 : e10.minimumLedgerVersion, processorType: "fungible_asset_processor" }), M2({ aptosConfig: this.config, ...e10 });
  }
  async transferFungibleAsset(e10) {
    return x9({ aptosConfig: this.config, ...e10 });
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-ORXEFE6X.mjs
async function F4(n27) {
  let { aptosConfig: e10, payload: o34, options: t39 } = n27, i49 = await Kn({ ...o34, aptosConfig: e10 }), r30 = new n15();
  i49.serialize(r30);
  let u17 = r30.toUint8Array(), { data: d24 } = await q2({ aptosConfig: e10, path: "view", originMethod: "view", contentType: "application/x.aptos.view_function+bcs", params: { ledger_version: t39 == null ? void 0 : t39.ledgerVersion }, body: u17 });
  return d24;
}
async function M3(n27) {
  let { aptosConfig: e10, payload: o34, options: t39 } = n27, { data: i49 } = await q2({ aptosConfig: e10, originMethod: "viewJson", path: "view", params: { ledger_version: t39 == null ? void 0 : t39.ledgerVersion }, body: { function: o34.function, type_arguments: o34.typeArguments ?? [], arguments: o34.functionArguments ?? [] } });
  return i49;
}

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-T2NJUIOQ.mjs
var p14 = class {
  constructor(o34) {
    this.config = o34;
  }
  async getLedgerInfo() {
    return d6({ aptosConfig: this.config });
  }
  async getChainId() {
    return (await this.getLedgerInfo()).chain_id;
  }
  async getBlockByVersion(o34) {
    return U({ aptosConfig: this.config, ...o34 });
  }
  async getBlockByHeight(o34) {
    return X({ aptosConfig: this.config, ...o34 });
  }
  async view(o34) {
    return F4({ aptosConfig: this.config, ...o34 });
  }
  async viewJson(o34) {
    return M3({ aptosConfig: this.config, ...o34 });
  }
  async getChainTopUserTransactions(o34) {
    return C3({ aptosConfig: this.config, ...o34 });
  }
  async queryIndexer(o34) {
    return a4({ aptosConfig: this.config, ...o34 });
  }
  async getIndexerLastSuccessVersion() {
    return h3({ aptosConfig: this.config });
  }
  async getProcessorStatus(o34) {
    return T3({ aptosConfig: this.config, processorType: o34 });
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-YXITAP46.mjs
async function A13(o34) {
  let { aptosConfig: n27, jwt: s14, ephemeralKeyPair: e10, uidKey: r30 = "sub", derivationPath: i49 } = o34, t39 = { jwt_b64: s14, epk: e10.getPublicKey().bcsToHex().toStringWithoutPrefix(), exp_date_secs: e10.expiryDateSecs, epk_blinder: i6.fromHexInput(e10.blinder).toStringWithoutPrefix(), uid_key: r30, derivation_path: i49 }, { data: a26 } = await E({ aptosConfig: n27, path: "fetch", body: t39, originMethod: "getPepper", overrides: { WITH_CREDENTIALS: false } });
  return i6.fromHexInput(a26.pepper).toUint8Array();
}
async function E7(o34) {
  let { aptosConfig: n27, jwt: s14, ephemeralKeyPair: e10, pepper: r30 = await A13(o34), uidKey: i49 = "sub" } = o34;
  if (i6.fromHexInput(r30).toUint8Array().length !== k4.PEPPER_LENGTH) throw new Error(`Pepper needs to be ${k4.PEPPER_LENGTH} bytes`);
  let { maxExpHorizonSecs: t39 } = await be({ aptosConfig: n27 });
  if (t39 < e10.expiryDateSecs - u5()) throw Error(`The EphemeralKeyPair is too long lived.  It's lifespan must be less than ${t39}`);
  let a26 = { jwt_b64: s14, epk: e10.getPublicKey().bcsToHex().toStringWithoutPrefix(), epk_blinder: i6.fromHexInput(e10.blinder).toStringWithoutPrefix(), exp_date_secs: e10.expiryDateSecs, exp_horizon_secs: t39, pepper: i6.fromHexInput(r30).toStringWithoutPrefix(), uid_key: i49 }, { data: f19 } = await a3({ aptosConfig: n27, path: "prove", body: a26, originMethod: "getProof", overrides: { WITH_CREDENTIALS: false } }), c16 = f19.proof, u17 = new g8({ a: c16.a, b: c16.b, c: c16.c });
  return new S5({ proof: new f9(u17, 0), trainingWheelsSignature: p8.fromHex(f19.training_wheels_signature), expHorizonSecs: t39 });
}
async function W6(o34) {
  let { aptosConfig: n27, jwt: s14, uidKey: e10, proofFetchCallback: r30, pepper: i49 = await A13(o34) } = o34, t39 = E7({ ...o34, pepper: i49 }), a26 = r30 ? t39 : await t39, f19 = A11.fromJwtAndPepper({ jwt: s14, pepper: i49, uidKey: e10 }), c16 = await L5({ aptosConfig: n27, authenticationKey: f19.authKey().derivedAddress() });
  return k4.create({ ...o34, address: c16, proof: a26, pepper: i49, proofFetchCallback: r30 });
}

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-WHW4Z7TK.mjs
var i47 = class {
  constructor(e10) {
    this.config = e10;
  }
  async getPepper(e10) {
    return A13({ aptosConfig: this.config, ...e10 });
  }
  async getProof(e10) {
    return E7({ aptosConfig: this.config, ...e10 });
  }
  async deriveKeylessAccount(e10) {
    return W6({ aptosConfig: this.config, ...e10 });
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-5L3PLK3W.mjs
async function d19(e10) {
  let { aptosConfig: o34, options: t39 } = e10, r30 = { query: v, variables: { where_condition: t39 == null ? void 0 : t39.where, offset: t39 == null ? void 0 : t39.offset, limit: t39 == null ? void 0 : t39.limit, order_by: t39 == null ? void 0 : t39.orderBy } };
  return (await a4({ aptosConfig: o34, query: r30, originMethod: "getObjectData" })).current_objects;
}
async function f14(e10) {
  let { aptosConfig: o34, objectAddress: t39, options: r30 } = e10, c16 = { object_address: { _eq: d7.from(t39).toStringLong() } };
  return (await d19({ aptosConfig: o34, options: { ...r30, where: c16 } }))[0];
}

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-USOIC4HO.mjs
var t35 = class {
  constructor(e10) {
    this.config = e10;
  }
  async getObjectDataByObjectAddress(e10) {
    return await i5({ config: this.config, minimumLedgerVersion: e10.minimumLedgerVersion, processorType: "objects_processor" }), f14({ aptosConfig: this.config, ...e10 });
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-A4T373F3.mjs
async function m15(e10) {
  let { aptosConfig: t39, poolAddress: o34 } = e10, r30 = d7.from(o34).toStringLong(), i49 = await a4({ aptosConfig: t39, query: { query: w, variables: { where_condition: { pool_address: { _eq: r30 } } } } });
  return i49.num_active_delegator_per_pool[0] ? i49.num_active_delegator_per_pool[0].num_active_delegator : 0;
}
async function f15(e10) {
  let { aptosConfig: t39, options: o34 } = e10, r30 = { query: w, variables: { order_by: o34 == null ? void 0 : o34.orderBy } };
  return (await a4({ aptosConfig: t39, query: r30 })).num_active_delegator_per_pool;
}
async function A14(e10) {
  let { aptosConfig: t39, delegatorAddress: o34, poolAddress: r30 } = e10, a26 = { query: $, variables: { delegatorAddress: d7.from(o34).toStringLong(), poolAddress: d7.from(r30).toStringLong() } };
  return (await a4({ aptosConfig: t39, query: a26 })).delegated_staking_activities;
}

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-6BYVG7H4.mjs
var t36 = class {
  constructor(e10) {
    this.config = e10;
  }
  async getNumberOfDelegators(e10) {
    return await i5({ config: this.config, minimumLedgerVersion: e10 == null ? void 0 : e10.minimumLedgerVersion, processorType: "stake_processor" }), m15({ aptosConfig: this.config, ...e10 });
  }
  async getNumberOfDelegatorsForAllPools(e10) {
    return await i5({ config: this.config, minimumLedgerVersion: e10 == null ? void 0 : e10.minimumLedgerVersion, processorType: "stake_processor" }), f15({ aptosConfig: this.config, ...e10 });
  }
  async getDelegatedStakingActivities(e10) {
    return await i5({ config: this.config, minimumLedgerVersion: e10 == null ? void 0 : e10.minimumLedgerVersion, processorType: "stake_processor" }), A14({ aptosConfig: this.config, ...e10 });
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-4SDUQ7AS.mjs
var l15 = class {
  constructor(e10) {
    this.config = e10;
  }
  async getAccountInfo(e10) {
    return R4({ aptosConfig: this.config, ...e10 });
  }
  async getAccountModules(e10) {
    return Y({ aptosConfig: this.config, ...e10 });
  }
  async getAccountModule(e10) {
    return Z({ aptosConfig: this.config, ...e10 });
  }
  async getAccountTransactions(e10) {
    return ee({ aptosConfig: this.config, ...e10 });
  }
  async getAccountResources(e10) {
    return oe({ aptosConfig: this.config, ...e10 });
  }
  async getAccountResource(e10) {
    return x7({ aptosConfig: this.config, ...e10 });
  }
  async lookupOriginalAccountAddress(e10) {
    return L5({ aptosConfig: this.config, ...e10 });
  }
  async getAccountTokensCount(e10) {
    return await i5({ config: this.config, minimumLedgerVersion: e10.minimumLedgerVersion, processorType: "account_transactions_processor" }), te({ aptosConfig: this.config, ...e10 });
  }
  async getAccountOwnedTokens(e10) {
    return await i5({ config: this.config, minimumLedgerVersion: e10.minimumLedgerVersion, processorType: "token_v2_processor" }), ne({ aptosConfig: this.config, ...e10 });
  }
  async getAccountOwnedTokensFromCollectionAddress(e10) {
    return await i5({ config: this.config, minimumLedgerVersion: e10.minimumLedgerVersion, processorType: "token_v2_processor" }), re({ aptosConfig: this.config, ...e10 });
  }
  async getAccountCollectionsWithOwnedTokens(e10) {
    return await i5({ config: this.config, minimumLedgerVersion: e10.minimumLedgerVersion, processorType: "token_v2_processor" }), se({ aptosConfig: this.config, ...e10 });
  }
  async getAccountTransactionsCount(e10) {
    return await i5({ config: this.config, minimumLedgerVersion: e10.minimumLedgerVersion, processorType: "account_transactions_processor" }), ce({ aptosConfig: this.config, ...e10 });
  }
  async getAccountCoinsData(e10) {
    return await i5({ config: this.config, minimumLedgerVersion: e10.minimumLedgerVersion, processorType: "fungible_asset_processor" }), B6({ aptosConfig: this.config, ...e10 });
  }
  async getAccountCoinsCount(e10) {
    return await i5({ config: this.config, minimumLedgerVersion: e10.minimumLedgerVersion, processorType: "fungible_asset_processor" }), ae({ aptosConfig: this.config, ...e10 });
  }
  async getAccountAPTAmount(e10) {
    return this.getAccountCoinAmount({ coinType: o11, ...e10 });
  }
  async getAccountCoinAmount(e10) {
    return await i5({ config: this.config, minimumLedgerVersion: e10.minimumLedgerVersion, processorType: "fungible_asset_processor" }), ie({ aptosConfig: this.config, ...e10 });
  }
  async getAccountOwnedObjects(e10) {
    return await i5({ config: this.config, minimumLedgerVersion: e10.minimumLedgerVersion, processorType: "default_processor" }), de({ aptosConfig: this.config, ...e10 });
  }
  async deriveAccountFromPrivateKey(e10) {
    return ue({ aptosConfig: this.config, ...e10 });
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-NRRADUK4.mjs
var T10 = ["A name must be between 3 and 63 characters long,", "and can only contain lowercase a-z, 0-9, and hyphens.", "A name may not start or end with a hyphen."].join(" ");
function D8(e10) {
  return !(!e10 || e10.length < 3 || e10.length > 63 || !/^[a-z\d][a-z\d-]{1,61}[a-z\d]$/.test(e10));
}
function c13(e10) {
  let [t39, n27, ...o34] = e10.replace(/\.apt$/, "").split(".");
  if (o34.length > 0) throw new Error(`${e10} is invalid. A name can only have two parts, a domain and a subdomain separated by a "."`);
  if (!D8(t39)) throw new Error(`${t39} is not valid. ${T10}`);
  if (n27 && !D8(n27)) throw new Error(`${n27} is not valid. ${T10}`);
  return { domainName: n27 || t39, subdomainName: n27 ? t39 : void 0 };
}
var I4 = ((n27) => (n27[n27.Independent = 0] = "Independent", n27[n27.FollowsDomain = 1] = "FollowsDomain", n27))(I4 || {});
function E8(e10) {
  if (!e10) return false;
  let t39 = new Date(e10.domain_expiration_timestamp).getTime() < Date.now(), n27 = new Date(e10.expiration_timestamp).getTime() < Date.now();
  return e10.subdomain && t39 ? false : e10.subdomain && e10.subdomain_expiration_policy === 1 ? true : !n27;
}
var O4 = "0x585fc9f0f0c54183b039ffc770ca282ebd87307916c215a3e692f2f8e4305e82";
var v5 = { testnet: "0x5f8fd2347449685cf41d4db97926ec3a096eaf381332be4f1318ad4d16a8497c", mainnet: "0x867ed1f6bf916171b1de3ee92849b8978b7d1b9e0a8cc982a3d19d535dfd9c0c", local: O4, custom: null, devnet: null };
function d20(e10) {
  let t39 = v5[e10.network];
  if (!t39) throw new Error(`The ANS contract is not deployed to ${e10.network}`);
  return t39;
}
var b9 = (e10) => {
  if (e10 && typeof e10 == "object" && "vec" in e10 && Array.isArray(e10.vec)) return e10.vec[0];
};
async function F5(e10) {
  let { aptosConfig: t39, name: n27 } = e10, o34 = d20(t39), { domainName: r30, subdomainName: s14 } = c13(n27), i49 = await F4({ aptosConfig: t39, payload: { function: `${o34}::router::get_owner_addr`, functionArguments: [r30, s14] } }), a26 = b9(i49[0]);
  return a26 ? d7.from(a26) : void 0;
}
async function Y4(e10) {
  let { aptosConfig: t39, expiration: n27, name: o34, sender: r30, targetAddress: s14, toAddress: i49, options: a26, transferable: u17 } = e10, p16 = d20(t39), { domainName: y14, subdomainName: N6 } = c13(o34), x11 = n27.policy === "subdomain:independent" || n27.policy === "subdomain:follow-domain";
  if (N6 && !x11) throw new Error("Subdomains must have an expiration policy of either 'subdomain:independent' or 'subdomain:follow-domain'");
  if (x11 && !N6) throw new Error(`Policy is set to ${n27.policy} but no subdomain was provided`);
  if (n27.policy === "domain") {
    let h19 = n27.years ?? 1;
    if (h19 !== 1) throw new Error("For now, names can only be registered for 1 year at a time");
    let G7 = h19 * 31536e3;
    return await h14({ aptosConfig: t39, sender: r30.accountAddress.toString(), data: { function: `${p16}::router::register_domain`, functionArguments: [y14, G7, s14, i49] }, options: a26 });
  }
  if (!N6) throw new Error(`${n27.policy} requires a subdomain to be provided.`);
  let _8 = await P5({ aptosConfig: t39, name: y14 });
  if (!_8) throw new Error("The domain does not exist");
  let S9 = n27.policy === "subdomain:independent" ? n27.expirationDate : _8;
  if (S9 > _8) throw new Error("The subdomain expiration time cannot be greater than the domain expiration time");
  return await h14({ aptosConfig: t39, sender: r30.accountAddress.toString(), data: { function: `${p16}::router::register_subdomain`, functionArguments: [y14, N6, Math.round(S9 / 1e3), n27.policy === "subdomain:follow-domain" ? 1 : 0, !!u17, s14, i49] }, options: a26 });
}
async function P5(e10) {
  let { aptosConfig: t39, name: n27 } = e10, o34 = d20(t39), { domainName: r30, subdomainName: s14 } = c13(n27);
  try {
    let i49 = await F4({ aptosConfig: t39, payload: { function: `${o34}::router::get_expiration`, functionArguments: [r30, s14] } });
    return Number(i49[0]) * 1e3;
  } catch {
    return;
  }
}
async function K3(e10) {
  let { aptosConfig: t39, address: n27 } = e10, o34 = d20(t39), r30 = await F4({ aptosConfig: t39, payload: { function: `${o34}::router::get_primary_name`, functionArguments: [d7.from(n27).toString()] } }), s14 = b9(r30[1]), i49 = b9(r30[0]);
  if (s14) return [i49, s14].filter(Boolean).join(".");
}
async function W7(e10) {
  let { aptosConfig: t39, sender: n27, name: o34, options: r30 } = e10, s14 = d20(t39);
  if (!o34) return await h14({ aptosConfig: t39, sender: n27.accountAddress.toString(), data: { function: `${s14}::router::clear_primary_name`, functionArguments: [] }, options: r30 });
  let { domainName: i49, subdomainName: a26 } = c13(o34);
  return await h14({ aptosConfig: t39, sender: n27.accountAddress.toString(), data: { function: `${s14}::router::set_primary_name`, functionArguments: [i49, a26] }, options: r30 });
}
async function H2(e10) {
  let { aptosConfig: t39, name: n27 } = e10, o34 = d20(t39), { domainName: r30, subdomainName: s14 } = c13(n27), i49 = await F4({ aptosConfig: t39, payload: { function: `${o34}::router::get_target_addr`, functionArguments: [r30, s14] } }), a26 = b9(i49[0]);
  return a26 ? d7.from(a26) : void 0;
}
async function J(e10) {
  let { aptosConfig: t39, sender: n27, name: o34, address: r30, options: s14 } = e10, i49 = d20(t39), { domainName: a26, subdomainName: u17 } = c13(o34);
  return await h14({ aptosConfig: t39, sender: n27.accountAddress.toString(), data: { function: `${i49}::router::set_target_addr`, functionArguments: [a26, u17, r30] }, options: s14 });
}
async function X2(e10) {
  let { aptosConfig: t39, name: n27 } = e10, { domainName: o34, subdomainName: r30 = "" } = c13(n27), a26 = (await a4({ aptosConfig: t39, query: { query: G, variables: { where_condition: { domain: { _eq: o34 }, subdomain: { _eq: r30 } }, limit: 1 } }, originMethod: "getName" })).current_aptos_names[0];
  return a26 && (a26 = l16(a26)), E8(a26) ? a26 : void 0;
}
async function Z3(e10) {
  var _a;
  let { aptosConfig: t39, options: n27, accountAddress: o34 } = e10, r30 = await C5({ aptosConfig: t39 });
  return (await a4({ aptosConfig: t39, originMethod: "getAccountNames", query: { query: G, variables: { limit: n27 == null ? void 0 : n27.limit, offset: n27 == null ? void 0 : n27.offset, order_by: n27 == null ? void 0 : n27.orderBy, where_condition: { ...((_a = e10.options) == null ? void 0 : _a.where) ?? {}, owner_address: { _eq: o34.toString() }, expiration_timestamp: { _gte: r30 } } } } })).current_aptos_names.map(l16);
}
async function ee2(e10) {
  var _a;
  let { aptosConfig: t39, options: n27, accountAddress: o34 } = e10, r30 = await C5({ aptosConfig: t39 });
  return (await a4({ aptosConfig: t39, originMethod: "getAccountDomains", query: { query: G, variables: { limit: n27 == null ? void 0 : n27.limit, offset: n27 == null ? void 0 : n27.offset, order_by: n27 == null ? void 0 : n27.orderBy, where_condition: { ...((_a = e10.options) == null ? void 0 : _a.where) ?? {}, owner_address: { _eq: o34.toString() }, expiration_timestamp: { _gte: r30 }, subdomain: { _eq: "" } } } } })).current_aptos_names.map(l16);
}
async function ne2(e10) {
  var _a;
  let { aptosConfig: t39, options: n27, accountAddress: o34 } = e10, r30 = await C5({ aptosConfig: t39 });
  return (await a4({ aptosConfig: t39, originMethod: "getAccountSubdomains", query: { query: G, variables: { limit: n27 == null ? void 0 : n27.limit, offset: n27 == null ? void 0 : n27.offset, order_by: n27 == null ? void 0 : n27.orderBy, where_condition: { ...((_a = e10.options) == null ? void 0 : _a.where) ?? {}, owner_address: { _eq: o34.toString() }, expiration_timestamp: { _gte: r30 }, subdomain: { _neq: "" } } } } })).current_aptos_names.map(l16);
}
async function te2(e10) {
  var _a;
  let { aptosConfig: t39, options: n27, domain: o34 } = e10;
  return (await a4({ aptosConfig: t39, originMethod: "getDomainSubdomains", query: { query: G, variables: { limit: n27 == null ? void 0 : n27.limit, offset: n27 == null ? void 0 : n27.offset, order_by: n27 == null ? void 0 : n27.orderBy, where_condition: { ...((_a = e10.options) == null ? void 0 : _a.where) ?? {}, domain: { _eq: o34 }, subdomain: { _neq: "" } } } } })).current_aptos_names.map(l16).filter(E8);
}
async function C5(e10) {
  let { aptosConfig: t39 } = e10, n27 = d20(t39), [o34] = await F4({ aptosConfig: t39, payload: { function: `${n27}::config::reregistration_grace_sec`, functionArguments: [] } }), r30 = o34 / 60 / 60 / 24, s14 = () => /* @__PURE__ */ new Date();
  return new Date(s14().setDate(s14().getDate() - r30)).toISOString();
}
async function oe2(e10) {
  let { aptosConfig: t39, sender: n27, name: o34, years: r30 = 1, options: s14 } = e10, i49 = d20(t39), a26 = r30 * 31536e3, { domainName: u17, subdomainName: p16 } = c13(o34);
  if (p16) throw new Error("Subdomains cannot be renewed");
  if (r30 !== 1) throw new Error("Currently, only 1 year renewals are supported");
  return await h14({ aptosConfig: t39, sender: n27.accountAddress.toString(), data: { function: `${i49}::router::renew_domain`, functionArguments: [u17, a26] }, options: s14 });
}
function l16(e10) {
  return { ...e10, expiration_timestamp: new Date(e10.expiration_timestamp).getTime() };
}

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-PO33LVUF.mjs
var A15 = class {
  constructor(n27) {
    this.config = n27;
  }
  async getOwnerAddress(n27) {
    return F5({ aptosConfig: this.config, ...n27 });
  }
  async getExpiration(n27) {
    return P5({ aptosConfig: this.config, ...n27 });
  }
  async getTargetAddress(n27) {
    return H2({ aptosConfig: this.config, ...n27 });
  }
  async setTargetAddress(n27) {
    return J({ aptosConfig: this.config, ...n27 });
  }
  async getPrimaryName(n27) {
    return K3({ aptosConfig: this.config, ...n27 });
  }
  async setPrimaryName(n27) {
    return W7({ aptosConfig: this.config, ...n27 });
  }
  async registerName(n27) {
    return Y4({ aptosConfig: this.config, ...n27 });
  }
  async renewDomain(n27) {
    return oe2({ aptosConfig: this.config, ...n27 });
  }
  async getName(n27) {
    return X2({ aptosConfig: this.config, ...n27 });
  }
  async getAccountNames(n27) {
    return Z3({ aptosConfig: this.config, ...n27 });
  }
  async getAccountDomains(n27) {
    return ee2({ aptosConfig: this.config, ...n27 });
  }
  async getAccountSubdomains(n27) {
    return ne2({ aptosConfig: this.config, ...n27 });
  }
  async getDomainSubdomains(n27) {
    return te2({ aptosConfig: this.config, ...n27 });
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-NMD45OTM.mjs
var l17 = class {
  constructor(e10) {
    this.network = (e10 == null ? void 0 : e10.network) ?? "devnet", this.fullnode = e10 == null ? void 0 : e10.fullnode, this.faucet = e10 == null ? void 0 : e10.faucet, this.pepper = e10 == null ? void 0 : e10.pepper, this.prover = e10 == null ? void 0 : e10.prover, this.indexer = e10 == null ? void 0 : e10.indexer, this.client = (e10 == null ? void 0 : e10.client) ?? { provider: aptosClient }, this.clientConfig = (e10 == null ? void 0 : e10.clientConfig) ?? {}, this.fullnodeConfig = (e10 == null ? void 0 : e10.fullnodeConfig) ?? {}, this.indexerConfig = (e10 == null ? void 0 : e10.indexerConfig) ?? {}, this.faucetConfig = (e10 == null ? void 0 : e10.faucetConfig) ?? {};
  }
  getRequestUrl(e10) {
    switch (e10) {
      case "Fullnode":
        if (this.fullnode !== void 0) return this.fullnode;
        if (this.network === "custom") throw new Error("Please provide a custom full node url");
        return o29[this.network];
      case "Faucet":
        if (this.faucet !== void 0) return this.faucet;
        if (this.network === "custom") throw new Error("Please provide a custom faucet url");
        return p11[this.network];
      case "Indexer":
        if (this.indexer !== void 0) return this.indexer;
        if (this.network === "custom") throw new Error("Please provide a custom indexer url");
        return s12[this.network];
      case "Pepper":
        if (this.pepper !== void 0) return this.pepper;
        if (this.network === "custom") throw new Error("Please provide a custom pepper service url");
        return a21[this.network];
      case "Prover":
        if (this.prover !== void 0) return this.prover;
        if (this.network === "custom") throw new Error("Please provide a custom prover service url");
        return n24[this.network];
      default:
        throw Error(`apiType ${e10} is not supported`);
    }
  }
  isPepperServiceRequest(e10) {
    return a21[this.network] === e10;
  }
  isProverServiceRequest(e10) {
    return n24[this.network] === e10;
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-KEN2VRIM.mjs
var u14 = { typeParameters: [{ constraints: [] }], parameters: [new S2(), new p4()] };
async function y10(e10) {
  let { aptosConfig: i49, sender: s14, recipient: c16, amount: p16, coinType: a26, options: m17 } = e10;
  return h14({ aptosConfig: i49, sender: s14, data: { function: "0x1::aptos_account::transfer_coins", typeArguments: [a26 ?? o11], functionArguments: [c16, p16], abi: u14 }, options: m17 });
}

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-7AIKM3UF.mjs
var t37 = class {
  constructor(n27) {
    this.config = n27;
  }
  async transferCoinTransaction(n27) {
    return y10({ aptosConfig: this.config, ...n27 });
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-CTJX4CUF.mjs
var C6 = { BOOLEAN: "bool", U8: "u8", U16: "u16", U32: "u32", U64: "u64", U128: "u128", U256: "u256", ADDRESS: "address", STRING: "0x1::string::String", ARRAY: "vector<u8>" };
var l18 = "0x4::token::Token";
async function It(t39) {
  let { aptosConfig: o34, digitalAssetAddress: n27 } = t39, e10 = { token_data_id: { _eq: d7.from(n27).toStringLong() } };
  return (await a4({ aptosConfig: o34, query: { query: D2, variables: { where_condition: e10 } }, originMethod: "getDigitalAssetData" })).current_token_datas_v2[0];
}
async function Pt(t39) {
  let { aptosConfig: o34, digitalAssetAddress: n27 } = t39, e10 = { token_data_id: { _eq: d7.from(n27).toStringLong() }, amount: { _gt: 0 } };
  return (await a4({ aptosConfig: o34, query: { query: x2, variables: { where_condition: e10 } }, originMethod: "getCurrentDigitalAssetOwnership" })).current_token_ownerships_v2[0];
}
async function bt(t39) {
  let { aptosConfig: o34, ownerAddress: n27, options: e10 } = t39, r30 = { owner_address: { _eq: d7.from(n27).toStringLong() }, amount: { _gt: 0 } }, s14 = { query: x2, variables: { where_condition: r30, offset: e10 == null ? void 0 : e10.offset, limit: e10 == null ? void 0 : e10.limit, order_by: e10 == null ? void 0 : e10.orderBy } };
  return (await a4({ aptosConfig: o34, query: s14, originMethod: "getOwnedDigitalAssets" })).current_token_ownerships_v2;
}
async function St(t39) {
  let { aptosConfig: o34, digitalAssetAddress: n27, options: e10 } = t39, r30 = { token_data_id: { _eq: d7.from(n27).toStringLong() } }, s14 = { query: Q, variables: { where_condition: r30, offset: e10 == null ? void 0 : e10.offset, limit: e10 == null ? void 0 : e10.limit, order_by: e10 == null ? void 0 : e10.orderBy } };
  return (await a4({ aptosConfig: o34, query: s14, originMethod: "getDigitalAssetActivity" })).token_activities_v2;
}
var F6 = { typeParameters: [], parameters: [new b3(E3()), new p4(), new b3(E3()), new b3(E3()), new c5(), new c5(), new c5(), new c5(), new c5(), new c5(), new c5(), new c5(), new c5(), new p4(), new p4()] };
async function Dt(t39) {
  let { aptosConfig: o34, options: n27, creator: e10 } = t39;
  return h14({ aptosConfig: o34, sender: e10.accountAddress, data: { function: "0x4::aptos_token::create_collection", functionArguments: [new a8(t39.description), new y6(t39.maxSupply ?? _2), new a8(t39.name), new a8(t39.uri), new d9(t39.mutableDescription ?? true), new d9(t39.mutableRoyalty ?? true), new d9(t39.mutableURI ?? true), new d9(t39.mutableTokenDescription ?? true), new d9(t39.mutableTokenName ?? true), new d9(t39.mutableTokenProperties ?? true), new d9(t39.mutableTokenURI ?? true), new d9(t39.tokensBurnableByCreator ?? true), new d9(t39.tokensFreezableByCreator ?? true), new y6(t39.royaltyNumerator ?? 0), new y6(t39.royaltyDenominator ?? 1)], abi: F6 }, options: n27 });
}
async function v6(t39) {
  let { aptosConfig: o34, options: n27 } = t39, e10 = n27 == null ? void 0 : n27.where;
  (n27 == null ? void 0 : n27.tokenStandard) && (e10.token_standard = { _eq: (n27 == null ? void 0 : n27.tokenStandard) ?? "v2" });
  let r30 = { query: T2, variables: { where_condition: e10, offset: n27 == null ? void 0 : n27.offset, limit: n27 == null ? void 0 : n27.limit } };
  return (await a4({ aptosConfig: o34, query: r30, originMethod: "getCollectionData" })).current_collections_v2[0];
}
async function ht(t39) {
  let { aptosConfig: o34, creatorAddress: n27, collectionName: e10, options: r30 } = t39, s14 = d7.from(n27), a26 = { collection_name: { _eq: e10 }, creator_address: { _eq: s14.toStringLong() } };
  return (r30 == null ? void 0 : r30.tokenStandard) && (a26.token_standard = { _eq: (r30 == null ? void 0 : r30.tokenStandard) ?? "v2" }), v6({ aptosConfig: o34, options: { ...r30, where: a26 } });
}
async function vt(t39) {
  let { aptosConfig: o34, creatorAddress: n27, options: e10 } = t39, s14 = { creator_address: { _eq: d7.from(n27).toStringLong() } };
  return (e10 == null ? void 0 : e10.tokenStandard) && (s14.token_standard = { _eq: (e10 == null ? void 0 : e10.tokenStandard) ?? "v2" }), v6({ aptosConfig: o34, options: { ...e10, where: s14 } });
}
async function xt(t39) {
  let { aptosConfig: o34, collectionId: n27, options: e10 } = t39, s14 = { collection_id: { _eq: d7.from(n27).toStringLong() } };
  return (e10 == null ? void 0 : e10.tokenStandard) && (s14.token_standard = { _eq: (e10 == null ? void 0 : e10.tokenStandard) ?? "v2" }), v6({ aptosConfig: o34, options: { ...e10, where: s14 } });
}
async function Gt(t39) {
  let { creatorAddress: o34, collectionName: n27, options: e10, aptosConfig: r30 } = t39, s14 = d7.from(o34), a26 = { collection_name: { _eq: n27 }, creator_address: { _eq: s14.toStringLong() } };
  return (e10 == null ? void 0 : e10.tokenStandard) && (a26.token_standard = { _eq: (e10 == null ? void 0 : e10.tokenStandard) ?? "v2" }), (await v6({ aptosConfig: r30, options: { where: a26 } })).collection_id;
}
var N4 = { typeParameters: [], parameters: [new b3(E3()), new b3(E3()), new b3(E3()), new b3(E3()), new y5(new b3(E3())), new y5(new b3(E3())), new y5(y5.u8())] };
async function Bt(t39) {
  let { aptosConfig: o34, options: n27, creator: e10, collection: r30, description: s14, name: a26, uri: m17, propertyKeys: g11, propertyTypes: P8, propertyValues: I7 } = t39, b12 = P8 == null ? void 0 : P8.map((S9) => C6[S9]);
  return h14({ aptosConfig: o34, sender: e10.accountAddress, data: { function: "0x4::aptos_token::mint", functionArguments: [new a8(r30), new a8(s14), new a8(a26), new a8(m17), t15.MoveString(g11 ?? []), t15.MoveString(b12 ?? []), K4(I7 ?? [], b12 ?? [])], abi: N4 }, options: n27 });
}
var Q3 = { typeParameters: [{ constraints: ["key"] }], parameters: [new b3(j3(new h5(0))), new S2()] };
async function Et(t39) {
  let { aptosConfig: o34, sender: n27, digitalAssetAddress: e10, recipient: r30, digitalAssetType: s14, options: a26 } = t39;
  return h14({ aptosConfig: o34, sender: n27.accountAddress, data: { function: "0x1::object::transfer", typeArguments: [s14 ?? l18], functionArguments: [d7.from(e10), d7.from(r30)], abi: Q3 }, options: a26 });
}
var Y5 = { typeParameters: [], parameters: [new b3(E3()), new b3(E3()), new b3(E3()), new b3(E3()), new y5(new b3(E3())), new y5(new b3(E3())), new y5(y5.u8()), new S2()] };
async function Ot(t39) {
  let { aptosConfig: o34, account: n27, collection: e10, description: r30, name: s14, uri: a26, recipient: m17, propertyKeys: g11, propertyTypes: P8, propertyValues: I7, options: b12 } = t39;
  if ((g11 == null ? void 0 : g11.length) !== (I7 == null ? void 0 : I7.length)) throw new Error("Property keys and property values counts do not match");
  if ((P8 == null ? void 0 : P8.length) !== (I7 == null ? void 0 : I7.length)) throw new Error("Property types and property values counts do not match");
  let S9 = P8 == null ? void 0 : P8.map((U13) => C6[U13]);
  return h14({ aptosConfig: o34, sender: n27.accountAddress, data: { function: "0x4::aptos_token::mint_soul_bound", functionArguments: [e10, r30, s14, a26, t15.MoveString(g11 ?? []), t15.MoveString(S9 ?? []), K4(I7 ?? [], S9 ?? []), m17], abi: Y5 }, options: b12 });
}
var L6 = { typeParameters: [{ constraints: ["key"] }], parameters: [new b3(j3(new h5(0)))] };
async function qt(t39) {
  let { aptosConfig: o34, creator: n27, digitalAssetAddress: e10, digitalAssetType: r30, options: s14 } = t39;
  return h14({ aptosConfig: o34, sender: n27.accountAddress, data: { function: "0x4::aptos_token::burn", typeArguments: [r30 ?? l18], functionArguments: [d7.from(e10)], abi: L6 }, options: s14 });
}
var z7 = { typeParameters: [{ constraints: ["key"] }], parameters: [new b3(j3(new h5(0)))] };
async function Vt(t39) {
  let { aptosConfig: o34, creator: n27, digitalAssetAddress: e10, digitalAssetType: r30, options: s14 } = t39;
  return h14({ aptosConfig: o34, sender: n27.accountAddress, data: { function: "0x4::aptos_token::freeze_transfer", typeArguments: [r30 ?? l18], functionArguments: [e10], abi: z7 }, options: s14 });
}
var j6 = { typeParameters: [{ constraints: ["key"] }], parameters: [new b3(j3(new h5(0)))] };
async function Rt(t39) {
  let { aptosConfig: o34, creator: n27, digitalAssetAddress: e10, digitalAssetType: r30, options: s14 } = t39;
  return h14({ aptosConfig: o34, sender: n27.accountAddress, data: { function: "0x4::aptos_token::unfreeze_transfer", typeArguments: [r30 ?? l18], functionArguments: [e10], abi: j6 }, options: s14 });
}
var W8 = { typeParameters: [{ constraints: ["key"] }], parameters: [new b3(j3(new h5(0))), new b3(E3())] };
async function Mt(t39) {
  let { aptosConfig: o34, creator: n27, description: e10, digitalAssetAddress: r30, digitalAssetType: s14, options: a26 } = t39;
  return h14({ aptosConfig: o34, sender: n27.accountAddress, data: { function: "0x4::aptos_token::set_description", typeArguments: [s14 ?? l18], functionArguments: [d7.from(r30), new a8(e10)], abi: W8 }, options: a26 });
}
var X3 = { typeParameters: [{ constraints: ["key"] }], parameters: [new b3(j3(new h5(0))), new b3(E3())] };
async function Kt(t39) {
  let { aptosConfig: o34, creator: n27, name: e10, digitalAssetAddress: r30, digitalAssetType: s14, options: a26 } = t39;
  return h14({ aptosConfig: o34, sender: n27.accountAddress, data: { function: "0x4::aptos_token::set_name", typeArguments: [s14 ?? l18], functionArguments: [d7.from(r30), new a8(e10)], abi: X3 }, options: a26 });
}
var H3 = { typeParameters: [{ constraints: ["key"] }], parameters: [new b3(j3(new h5(0))), new b3(E3())] };
async function Ut(t39) {
  let { aptosConfig: o34, creator: n27, uri: e10, digitalAssetAddress: r30, digitalAssetType: s14, options: a26 } = t39;
  return h14({ aptosConfig: o34, sender: n27.accountAddress, data: { function: "0x4::aptos_token::set_uri", typeArguments: [s14 ?? l18], functionArguments: [d7.from(r30), new a8(e10)], abi: H3 }, options: a26 });
}
var J2 = { typeParameters: [{ constraints: ["key"] }], parameters: [new b3(j3(new h5(0))), new b3(E3()), new b3(E3()), y5.u8()] };
async function Ft(t39) {
  let { aptosConfig: o34, creator: n27, propertyKey: e10, propertyType: r30, propertyValue: s14, digitalAssetAddress: a26, digitalAssetType: m17, options: g11 } = t39;
  return h14({ aptosConfig: o34, sender: n27.accountAddress, data: { function: "0x4::aptos_token::add_property", typeArguments: [m17 ?? l18], functionArguments: [d7.from(a26), new a8(e10), new a8(C6[r30]), t15.U8(B8(s14, C6[r30]))], abi: J2 }, options: g11 });
}
var Z4 = { typeParameters: [{ constraints: ["key"] }], parameters: [new b3(j3(new h5(0))), new b3(E3())] };
async function Nt(t39) {
  let { aptosConfig: o34, creator: n27, propertyKey: e10, digitalAssetAddress: r30, digitalAssetType: s14, options: a26 } = t39;
  return h14({ aptosConfig: o34, sender: n27.accountAddress, data: { function: "0x4::aptos_token::remove_property", typeArguments: [s14 ?? l18], functionArguments: [d7.from(r30), new a8(e10)], abi: Z4 }, options: a26 });
}
var $6 = { typeParameters: [{ constraints: ["key"] }], parameters: [new b3(j3(new h5(0))), new b3(E3()), new b3(E3()), y5.u8()] };
async function Qt(t39) {
  let { aptosConfig: o34, creator: n27, propertyKey: e10, propertyType: r30, propertyValue: s14, digitalAssetAddress: a26, digitalAssetType: m17, options: g11 } = t39;
  return h14({ aptosConfig: o34, sender: n27.accountAddress, data: { function: "0x4::aptos_token::update_property", typeArguments: [m17 ?? l18], functionArguments: [d7.from(a26), new a8(e10), new a8(C6[r30]), B8(s14, C6[r30])], abi: $6 }, options: g11 });
}
var tt = { typeParameters: [{ constraints: ["key"] }, { constraints: [] }], parameters: [new b3(j3(new h5(0))), new b3(E3()), new h5(1)] };
async function Yt(t39) {
  let { aptosConfig: o34, creator: n27, propertyKey: e10, propertyType: r30, propertyValue: s14, digitalAssetAddress: a26, digitalAssetType: m17, options: g11 } = t39;
  return h14({ aptosConfig: o34, sender: n27.accountAddress, data: { function: "0x4::aptos_token::add_typed_property", typeArguments: [m17 ?? l18, C6[r30]], functionArguments: [d7.from(a26), new a8(e10), s14], abi: tt }, options: g11 });
}
var et = { typeParameters: [{ constraints: ["key"] }, { constraints: [] }], parameters: [new b3(j3(new h5(0))), new b3(E3()), new h5(1)] };
async function Lt(t39) {
  let { aptosConfig: o34, creator: n27, propertyKey: e10, propertyType: r30, propertyValue: s14, digitalAssetAddress: a26, digitalAssetType: m17, options: g11 } = t39;
  return h14({ aptosConfig: o34, sender: n27.accountAddress, data: { function: "0x4::aptos_token::update_typed_property", typeArguments: [m17 ?? l18, C6[r30]], functionArguments: [d7.from(a26), new a8(e10), s14], abi: et }, options: g11 });
}
function K4(t39, o34) {
  let n27 = new Array();
  return o34.forEach((e10, r30) => {
    n27.push(B8(t39[r30], e10));
  }), n27;
}
function B8(t39, o34) {
  let n27 = j4(o34);
  return U10(t39, n27, 0, []).bcsToBytes();
}

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-QE5OL6KN.mjs
var L7 = class {
  constructor(t39) {
    this.config = t39;
  }
  async getCollectionData(t39) {
    await i5({ config: this.config, minimumLedgerVersion: t39.minimumLedgerVersion, processorType: "token_v2_processor" });
    let { creatorAddress: N6, collectionName: _8, options: n27 } = t39, w5 = d7.from(N6), r30 = { collection_name: { _eq: _8 }, creator_address: { _eq: w5.toStringLong() } };
    return (n27 == null ? void 0 : n27.tokenStandard) && (r30.token_standard = { _eq: (n27 == null ? void 0 : n27.tokenStandard) ?? "v2" }), v6({ aptosConfig: this.config, options: { where: r30 } });
  }
  async getCollectionDataByCreatorAddressAndCollectionName(t39) {
    return await i5({ config: this.config, minimumLedgerVersion: t39.minimumLedgerVersion, processorType: "token_v2_processor" }), ht({ aptosConfig: this.config, ...t39 });
  }
  async getCollectionDataByCreatorAddress(t39) {
    return await i5({ config: this.config, minimumLedgerVersion: t39.minimumLedgerVersion, processorType: "token_v2_processor" }), vt({ aptosConfig: this.config, ...t39 });
  }
  async getCollectionDataByCollectionId(t39) {
    return await i5({ config: this.config, minimumLedgerVersion: t39.minimumLedgerVersion, processorType: "token_v2_processor" }), xt({ aptosConfig: this.config, ...t39 });
  }
  async getCollectionId(t39) {
    return await i5({ config: this.config, minimumLedgerVersion: t39.minimumLedgerVersion, processorType: "token_v2_processor" }), Gt({ aptosConfig: this.config, ...t39 });
  }
  async getDigitalAssetData(t39) {
    return await i5({ config: this.config, minimumLedgerVersion: t39.minimumLedgerVersion, processorType: "token_v2_processor" }), It({ aptosConfig: this.config, ...t39 });
  }
  async getCurrentDigitalAssetOwnership(t39) {
    return await i5({ config: this.config, minimumLedgerVersion: t39.minimumLedgerVersion, processorType: "token_v2_processor" }), Pt({ aptosConfig: this.config, ...t39 });
  }
  async getOwnedDigitalAssets(t39) {
    return await i5({ config: this.config, minimumLedgerVersion: t39.minimumLedgerVersion, processorType: "token_v2_processor" }), bt({ aptosConfig: this.config, ...t39 });
  }
  async getDigitalAssetActivity(t39) {
    return await i5({ config: this.config, minimumLedgerVersion: t39.minimumLedgerVersion, processorType: "token_v2_processor" }), St({ aptosConfig: this.config, ...t39 });
  }
  async createCollectionTransaction(t39) {
    return Dt({ aptosConfig: this.config, ...t39 });
  }
  async mintDigitalAssetTransaction(t39) {
    return Bt({ aptosConfig: this.config, ...t39 });
  }
  async transferDigitalAssetTransaction(t39) {
    return Et({ aptosConfig: this.config, ...t39 });
  }
  async mintSoulBoundTransaction(t39) {
    return Ot({ aptosConfig: this.config, ...t39 });
  }
  async burnDigitalAssetTransaction(t39) {
    return qt({ aptosConfig: this.config, ...t39 });
  }
  async freezeDigitalAssetTransaferTransaction(t39) {
    return Vt({ aptosConfig: this.config, ...t39 });
  }
  async unfreezeDigitalAssetTransaferTransaction(t39) {
    return Rt({ aptosConfig: this.config, ...t39 });
  }
  async setDigitalAssetDescriptionTransaction(t39) {
    return Mt({ aptosConfig: this.config, ...t39 });
  }
  async setDigitalAssetNameTransaction(t39) {
    return Kt({ aptosConfig: this.config, ...t39 });
  }
  async setDigitalAssetURITransaction(t39) {
    return Ut({ aptosConfig: this.config, ...t39 });
  }
  async addDigitalAssetPropertyTransaction(t39) {
    return Ft({ aptosConfig: this.config, ...t39 });
  }
  async removeDigitalAssetPropertyTransaction(t39) {
    return Nt({ aptosConfig: this.config, ...t39 });
  }
  async updateDigitalAssetPropertyTransaction(t39) {
    return Qt({ aptosConfig: this.config, ...t39 });
  }
  async addDigitalAssetTypedPropertyTransaction(t39) {
    return Yt({ aptosConfig: this.config, ...t39 });
  }
  async updateDigitalAssetTypedPropertyTransaction(t39) {
    return Lt({ aptosConfig: this.config, ...t39 });
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-7Y3MRBG6.mjs
var t38 = class {
  constructor(n27) {
    this.config = new l17(n27), this.account = new l15(this.config), this.ans = new A15(this.config), this.coin = new t37(this.config), this.digitalAsset = new L7(this.config), this.event = new i45(this.config), this.faucet = new i46(this.config), this.fungibleAsset = new a24(this.config), this.general = new p14(this.config), this.staking = new t36(this.config), this.transaction = new h15(this.config), this.table = new a6(this.config), this.keyless = new i47(this.config), this.object = new t35(this.config);
  }
};
function e9(b12, n27, w5) {
  Object.getOwnPropertyNames(n27.prototype).forEach((i49) => {
    let o34 = Object.getOwnPropertyDescriptor(n27.prototype, i49);
    o34 && (o34.value = function(...j7) {
      return this[w5][i49](...j7);
    }, Object.defineProperty(b12.prototype, i49, o34));
  });
}
e9(t38, l15, "account");
e9(t38, A15, "ans");
e9(t38, t37, "coin");
e9(t38, L7, "digitalAsset");
e9(t38, i45, "event");
e9(t38, i46, "faucet");
e9(t38, a24, "fungibleAsset");
e9(t38, p14, "general");
e9(t38, t36, "staking");
e9(t38, h15, "transaction");
e9(t38, a6, "table");
e9(t38, i47, "keyless");
e9(t38, t35, "object");

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-THRXIXIO.mjs
var g9 = ((e10) => (e10.JSON = "application/json", e10.BCS = "application/x-bcs", e10.BCS_SIGNED_TRANSACTION = "application/x.aptos.signed_transaction+bcs", e10.BCS_VIEW_FUNCTION = "application/x.aptos.view_function+bcs", e10))(g9 || {});
var y11 = ((t39) => (t39[t39.Bool = 0] = "Bool", t39[t39.U8 = 1] = "U8", t39[t39.U64 = 2] = "U64", t39[t39.U128 = 3] = "U128", t39[t39.Address = 4] = "Address", t39[t39.Signer = 5] = "Signer", t39[t39.Vector = 6] = "Vector", t39[t39.Struct = 7] = "Struct", t39[t39.U16 = 8] = "U16", t39[t39.U32 = 9] = "U32", t39[t39.U256 = 10] = "U256", t39[t39.Reference = 254] = "Reference", t39[t39.Generic = 255] = "Generic", t39))(y11 || {});
var u15 = ((o34) => (o34[o34.U8 = 0] = "U8", o34[o34.U64 = 1] = "U64", o34[o34.U128 = 2] = "U128", o34[o34.Address = 3] = "Address", o34[o34.U8Vector = 4] = "U8Vector", o34[o34.Bool = 5] = "Bool", o34[o34.U16 = 6] = "U16", o34[o34.U32 = 7] = "U32", o34[o34.U256 = 8] = "U256", o34))(u15 || {});
var d21 = ((s14) => (s14[s14.Script = 0] = "Script", s14[s14.EntryFunction = 2] = "EntryFunction", s14[s14.Multisig = 3] = "Multisig", s14))(d21 || {});
var c14 = ((i49) => (i49[i49.MultiAgentTransaction = 0] = "MultiAgentTransaction", i49[i49.FeePayerTransaction = 1] = "FeePayerTransaction", i49))(c14 || {});
var l19 = ((r30) => (r30[r30.Ed25519 = 0] = "Ed25519", r30[r30.MultiEd25519 = 1] = "MultiEd25519", r30[r30.MultiAgent = 2] = "MultiAgent", r30[r30.FeePayer = 3] = "FeePayer", r30[r30.SingleSender = 4] = "SingleSender", r30))(l19 || {});
var _7 = ((e10) => (e10[e10.Ed25519 = 0] = "Ed25519", e10[e10.MultiEd25519 = 1] = "MultiEd25519", e10[e10.SingleKey = 2] = "SingleKey", e10[e10.MultiKey = 3] = "MultiKey", e10))(_7 || {});
var x10 = ((s14) => (s14[s14.Ed25519 = 0] = "Ed25519", s14[s14.Secp256k1 = 1] = "Secp256k1", s14[s14.Keyless = 3] = "Keyless", s14))(x10 || {});
var h17 = ((s14) => (s14[s14.Ed25519 = 0] = "Ed25519", s14[s14.Secp256k1 = 1] = "Secp256k1", s14[s14.Keyless = 3] = "Keyless", s14))(h17 || {});
var v7 = ((p16) => (p16[p16.Ed25519 = 0] = "Ed25519", p16))(v7 || {});
var M4 = ((p16) => (p16[p16.Ed25519 = 0] = "Ed25519", p16))(M4 || {});
var m16 = ((p16) => (p16[p16.ZkProof = 0] = "ZkProof", p16))(m16 || {});
var R6 = ((p16) => (p16[p16.Groth16 = 0] = "Groth16", p16))(R6 || {});
var b10 = ((a26) => (a26.Pending = "pending_transaction", a26.User = "user_transaction", a26.Genesis = "genesis_transaction", a26.BlockMetadata = "block_metadata_transaction", a26.StateCheckpoint = "state_checkpoint_transaction", a26.Validator = "validator_transaction", a26.BlockEpilogue = "block_epilogue_transaction", a26))(b10 || {});
var k5 = ((s14) => (s14.PRIVATE = "private", s14.PUBLIC = "public", s14.FRIEND = "friend", s14))(k5 || {});
var S7 = ((e10) => (e10.STORE = "store", e10.DROP = "drop", e10.KEY = "key", e10.COPY = "copy", e10))(S7 || {});
var f16 = ((i49) => (i49.VALIDATOR = "validator", i49.FULL_NODE = "full_node", i49))(f16 || {});
var C7 = ((e10) => (e10[e10.Ed25519 = 0] = "Ed25519", e10[e10.MultiEd25519 = 1] = "MultiEd25519", e10[e10.SingleKey = 2] = "SingleKey", e10[e10.MultiKey = 3] = "MultiKey", e10))(C7 || {});
var T11 = ((i49) => (i49[i49.Ed25519 = 0] = "Ed25519", i49[i49.Secp256k1Ecdsa = 2] = "Secp256k1Ecdsa", i49))(T11 || {});
var E9 = ((r30) => (r30[r30.DeriveAuid = 251] = "DeriveAuid", r30[r30.DeriveObjectAddressFromObject = 252] = "DeriveObjectAddressFromObject", r30[r30.DeriveObjectAddressFromGuid = 253] = "DeriveObjectAddressFromGuid", r30[r30.DeriveObjectAddressFromSeed = 254] = "DeriveObjectAddressFromSeed", r30[r30.DeriveResourceAccountAddress = 255] = "DeriveResourceAccountAddress", r30))(E9 || {});

// node_modules/graphql-request/build/legacy/classes/ClientError.js
var ClientError = class _ClientError extends Error {
  constructor(response, request2) {
    const message = `${_ClientError.extractMessage(response)}: ${JSON.stringify({
      response,
      request: request2
    })}`;
    super(message);
    __publicField(this, "response");
    __publicField(this, "request");
    Object.setPrototypeOf(this, _ClientError.prototype);
    this.response = response;
    this.request = request2;
    if (typeof Error.captureStackTrace === `function`) {
      Error.captureStackTrace(this, _ClientError);
    }
  }
  static extractMessage(response) {
    var _a, _b;
    return ((_b = (_a = response.errors) == null ? void 0 : _a[0]) == null ? void 0 : _b.message) ?? `GraphQL Error (Code: ${String(response.status)})`;
  }
};

// node_modules/graphql-request/build/lib/prelude.js
var uppercase = (str) => str.toUpperCase();
var callOrIdentity = (value) => {
  return typeof value === `function` ? value() : value;
};
var zip = (a26, b12) => a26.map((k7, i49) => [k7, b12[i49]]);
var HeadersInitToPlainObject = (headers) => {
  let oHeaders = {};
  if (headers instanceof Headers) {
    oHeaders = HeadersInstanceToPlainObject(headers);
  } else if (Array.isArray(headers)) {
    headers.forEach(([name, value]) => {
      if (name && value !== void 0) {
        oHeaders[name] = value;
      }
    });
  } else if (headers) {
    oHeaders = headers;
  }
  return oHeaders;
};
var HeadersInstanceToPlainObject = (headers) => {
  const o34 = {};
  headers.forEach((v8, k7) => {
    o34[k7] = v8;
  });
  return o34;
};
var tryCatch = (fn4) => {
  try {
    const result = fn4();
    if (isPromiseLikeValue(result)) {
      return result.catch((error) => {
        return errorFromMaybeError(error);
      });
    }
    return result;
  } catch (error) {
    return errorFromMaybeError(error);
  }
};
var errorFromMaybeError = (maybeError) => {
  if (maybeError instanceof Error)
    return maybeError;
  return new Error(String(maybeError));
};
var isPromiseLikeValue = (value) => {
  return typeof value === `object` && value !== null && `then` in value && typeof value.then === `function` && `catch` in value && typeof value.catch === `function` && `finally` in value && typeof value.finally === `function`;
};
var casesExhausted = (value) => {
  throw new Error(`Unhandled case: ${String(value)}`);
};
var isPlainObject = (value) => {
  return typeof value === `object` && value !== null && !Array.isArray(value);
};

// node_modules/graphql-request/build/legacy/functions/batchRequests.js
var parseBatchRequestArgs = (documentsOrOptions, requestHeaders) => {
  return documentsOrOptions.documents ? documentsOrOptions : {
    documents: documentsOrOptions,
    requestHeaders,
    signal: void 0
  };
};

// node_modules/graphql-request/build/legacy/functions/rawRequest.js
var parseRawRequestArgs = (queryOrOptions, variables, requestHeaders) => {
  return queryOrOptions.query ? queryOrOptions : {
    query: queryOrOptions,
    variables,
    requestHeaders,
    signal: void 0
  };
};

// node_modules/graphql/version.mjs
var versionInfo = Object.freeze({
  major: 16,
  minor: 9,
  patch: 0,
  preReleaseTag: null
});

// node_modules/graphql/jsutils/devAssert.mjs
function devAssert(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}

// node_modules/graphql/jsutils/isObjectLike.mjs
function isObjectLike(value) {
  return typeof value == "object" && value !== null;
}

// node_modules/graphql/jsutils/invariant.mjs
function invariant(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(
      message != null ? message : "Unexpected invariant triggered."
    );
  }
}

// node_modules/graphql/language/location.mjs
var LineRegExp = /\r\n|[\n\r]/g;
function getLocation(source, position) {
  let lastLineStart = 0;
  let line = 1;
  for (const match of source.body.matchAll(LineRegExp)) {
    typeof match.index === "number" || invariant(false);
    if (match.index >= position) {
      break;
    }
    lastLineStart = match.index + match[0].length;
    line += 1;
  }
  return {
    line,
    column: position + 1 - lastLineStart
  };
}

// node_modules/graphql/language/printLocation.mjs
function printLocation(location) {
  return printSourceLocation(
    location.source,
    getLocation(location.source, location.start)
  );
}
function printSourceLocation(source, sourceLocation) {
  const firstLineColumnOffset = source.locationOffset.column - 1;
  const body = "".padStart(firstLineColumnOffset) + source.body;
  const lineIndex = sourceLocation.line - 1;
  const lineOffset = source.locationOffset.line - 1;
  const lineNum = sourceLocation.line + lineOffset;
  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  const columnNum = sourceLocation.column + columnOffset;
  const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
  const lines = body.split(/\r\n|[\n\r]/g);
  const locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    const subLineIndex = Math.floor(columnNum / 80);
    const subLineColumnNum = columnNum % 80;
    const subLines = [];
    for (let i49 = 0; i49 < locationLine.length; i49 += 80) {
      subLines.push(locationLine.slice(i49, i49 + 80));
    }
    return locationStr + printPrefixedLines([
      [`${lineNum} |`, subLines[0]],
      ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
      ["|", "^".padStart(subLineColumnNum)],
      ["|", subLines[subLineIndex + 1]]
    ]);
  }
  return locationStr + printPrefixedLines([
    // Lines specified like this: ["prefix", "string"],
    [`${lineNum - 1} |`, lines[lineIndex - 1]],
    [`${lineNum} |`, locationLine],
    ["|", "^".padStart(columnNum)],
    [`${lineNum + 1} |`, lines[lineIndex + 1]]
  ]);
}
function printPrefixedLines(lines) {
  const existingLines = lines.filter(([_8, line]) => line !== void 0);
  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
  return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
}

// node_modules/graphql/error/GraphQLError.mjs
function toNormalizedOptions(args) {
  const firstArg = args[0];
  if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
    return {
      nodes: firstArg,
      source: args[1],
      positions: args[2],
      path: args[3],
      originalError: args[4],
      extensions: args[5]
    };
  }
  return firstArg;
}
var GraphQLError = class _GraphQLError extends Error {
  /**
   * An array of `{ line, column }` locations within the source GraphQL document
   * which correspond to this error.
   *
   * Errors during validation often contain multiple locations, for example to
   * point out two things with the same name. Errors during execution include a
   * single location, the field which produced the error.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array describing the JSON-path into the execution response which
   * corresponds to this error. Only included for errors during execution.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array of GraphQL AST Nodes corresponding to this error.
   */
  /**
   * The source GraphQL document for the first location of this error.
   *
   * Note that if this Error represents more than one node, the source may not
   * represent nodes after the first node.
   */
  /**
   * An array of character offsets within the source GraphQL document
   * which correspond to this error.
   */
  /**
   * The original error thrown from a field resolver during execution.
   */
  /**
   * Extension fields to add to the formatted error.
   */
  /**
   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
   */
  constructor(message, ...rawArgs) {
    var _this$nodes, _nodeLocations$, _ref;
    const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
    super(message);
    this.name = "GraphQLError";
    this.path = path !== null && path !== void 0 ? path : void 0;
    this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
    this.nodes = undefinedIfEmpty(
      Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
    );
    const nodeLocations = undefinedIfEmpty(
      (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null)
    );
    this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
    this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
    this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
    const originalExtensions = isObjectLike(
      originalError === null || originalError === void 0 ? void 0 : originalError.extensions
    ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
    this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
    Object.defineProperties(this, {
      message: {
        writable: true,
        enumerable: true
      },
      name: {
        enumerable: false
      },
      nodes: {
        enumerable: false
      },
      source: {
        enumerable: false
      },
      positions: {
        enumerable: false
      },
      originalError: {
        enumerable: false
      }
    });
    if (originalError !== null && originalError !== void 0 && originalError.stack) {
      Object.defineProperty(this, "stack", {
        value: originalError.stack,
        writable: true,
        configurable: true
      });
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _GraphQLError);
    } else {
      Object.defineProperty(this, "stack", {
        value: Error().stack,
        writable: true,
        configurable: true
      });
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let output = this.message;
    if (this.nodes) {
      for (const node of this.nodes) {
        if (node.loc) {
          output += "\n\n" + printLocation(node.loc);
        }
      }
    } else if (this.source && this.locations) {
      for (const location of this.locations) {
        output += "\n\n" + printSourceLocation(this.source, location);
      }
    }
    return output;
  }
  toJSON() {
    const formattedError = {
      message: this.message
    };
    if (this.locations != null) {
      formattedError.locations = this.locations;
    }
    if (this.path != null) {
      formattedError.path = this.path;
    }
    if (this.extensions != null && Object.keys(this.extensions).length > 0) {
      formattedError.extensions = this.extensions;
    }
    return formattedError;
  }
};
function undefinedIfEmpty(array) {
  return array === void 0 || array.length === 0 ? void 0 : array;
}

// node_modules/graphql/error/syntaxError.mjs
function syntaxError(source, position, description) {
  return new GraphQLError(`Syntax Error: ${description}`, {
    source,
    positions: [position]
  });
}

// node_modules/graphql/language/ast.mjs
var Location = class {
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The Token at which this Node begins.
   */
  /**
   * The Token at which this Node ends.
   */
  /**
   * The Source document the AST represents.
   */
  constructor(startToken, endToken, source) {
    this.start = startToken.start;
    this.end = endToken.end;
    this.startToken = startToken;
    this.endToken = endToken;
    this.source = source;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
};
var Token = class {
  /**
   * The kind of Token.
   */
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The 1-indexed line number on which this Token appears.
   */
  /**
   * The 1-indexed column number at which this Token begins.
   */
  /**
   * For non-punctuation tokens, represents the interpreted value of the token.
   *
   * Note: is undefined for punctuation tokens, but typed as string for
   * convenience in the parser.
   */
  /**
   * Tokens exist as nodes in a double-linked-list amongst all tokens
   * including ignored tokens. <SOF> is always the first node and <EOF>
   * the last.
   */
  constructor(kind, start, end, line, column, value) {
    this.kind = kind;
    this.start = start;
    this.end = end;
    this.line = line;
    this.column = column;
    this.value = value;
    this.prev = null;
    this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
};
var QueryDocumentKeys = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are deprecated and will removed in v17.0.0
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
};
var kindValues = new Set(Object.keys(QueryDocumentKeys));
function isNode(maybeNode) {
  const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
  return typeof maybeKind === "string" && kindValues.has(maybeKind);
}
var OperationTypeNode;
(function(OperationTypeNode2) {
  OperationTypeNode2["QUERY"] = "query";
  OperationTypeNode2["MUTATION"] = "mutation";
  OperationTypeNode2["SUBSCRIPTION"] = "subscription";
})(OperationTypeNode || (OperationTypeNode = {}));

// node_modules/graphql/language/directiveLocation.mjs
var DirectiveLocation;
(function(DirectiveLocation2) {
  DirectiveLocation2["QUERY"] = "QUERY";
  DirectiveLocation2["MUTATION"] = "MUTATION";
  DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
  DirectiveLocation2["FIELD"] = "FIELD";
  DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
  DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
  DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
  DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
  DirectiveLocation2["SCHEMA"] = "SCHEMA";
  DirectiveLocation2["SCALAR"] = "SCALAR";
  DirectiveLocation2["OBJECT"] = "OBJECT";
  DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
  DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
  DirectiveLocation2["INTERFACE"] = "INTERFACE";
  DirectiveLocation2["UNION"] = "UNION";
  DirectiveLocation2["ENUM"] = "ENUM";
  DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
  DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
  DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
})(DirectiveLocation || (DirectiveLocation = {}));

// node_modules/graphql/language/kinds.mjs
var Kind;
(function(Kind2) {
  Kind2["NAME"] = "Name";
  Kind2["DOCUMENT"] = "Document";
  Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
  Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
  Kind2["SELECTION_SET"] = "SelectionSet";
  Kind2["FIELD"] = "Field";
  Kind2["ARGUMENT"] = "Argument";
  Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
  Kind2["INLINE_FRAGMENT"] = "InlineFragment";
  Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
  Kind2["VARIABLE"] = "Variable";
  Kind2["INT"] = "IntValue";
  Kind2["FLOAT"] = "FloatValue";
  Kind2["STRING"] = "StringValue";
  Kind2["BOOLEAN"] = "BooleanValue";
  Kind2["NULL"] = "NullValue";
  Kind2["ENUM"] = "EnumValue";
  Kind2["LIST"] = "ListValue";
  Kind2["OBJECT"] = "ObjectValue";
  Kind2["OBJECT_FIELD"] = "ObjectField";
  Kind2["DIRECTIVE"] = "Directive";
  Kind2["NAMED_TYPE"] = "NamedType";
  Kind2["LIST_TYPE"] = "ListType";
  Kind2["NON_NULL_TYPE"] = "NonNullType";
  Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
  Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
  Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
  Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
  Kind2["FIELD_DEFINITION"] = "FieldDefinition";
  Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
  Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
  Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
  Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
  Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
  Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
  Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
  Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
  Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
  Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
  Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
  Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
  Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
  Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
})(Kind || (Kind = {}));

// node_modules/graphql/language/characterClasses.mjs
function isWhiteSpace(code) {
  return code === 9 || code === 32;
}
function isDigit(code) {
  return code >= 48 && code <= 57;
}
function isLetter(code) {
  return code >= 97 && code <= 122 || // A-Z
  code >= 65 && code <= 90;
}
function isNameStart(code) {
  return isLetter(code) || code === 95;
}
function isNameContinue(code) {
  return isLetter(code) || isDigit(code) || code === 95;
}

// node_modules/graphql/language/blockString.mjs
function dedentBlockStringLines(lines) {
  var _firstNonEmptyLine2;
  let commonIndent = Number.MAX_SAFE_INTEGER;
  let firstNonEmptyLine = null;
  let lastNonEmptyLine = -1;
  for (let i49 = 0; i49 < lines.length; ++i49) {
    var _firstNonEmptyLine;
    const line = lines[i49];
    const indent2 = leadingWhitespace(line);
    if (indent2 === line.length) {
      continue;
    }
    firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i49;
    lastNonEmptyLine = i49;
    if (i49 !== 0 && indent2 < commonIndent) {
      commonIndent = indent2;
    }
  }
  return lines.map((line, i49) => i49 === 0 ? line : line.slice(commonIndent)).slice(
    (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
    lastNonEmptyLine + 1
  );
}
function leadingWhitespace(str) {
  let i49 = 0;
  while (i49 < str.length && isWhiteSpace(str.charCodeAt(i49))) {
    ++i49;
  }
  return i49;
}
function printBlockString(value, options) {
  const escapedValue = value.replace(/"""/g, '\\"""');
  const lines = escapedValue.split(/\r\n|[\n\r]/g);
  const isSingleLine = lines.length === 1;
  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace(line.charCodeAt(0)));
  const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
  const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
  const hasTrailingSlash = value.endsWith("\\");
  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
  const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && // add leading and trailing new lines only if it improves readability
  (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
  let result = "";
  const skipLeadingNewLine = isSingleLine && isWhiteSpace(value.charCodeAt(0));
  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
    result += "\n";
  }
  result += escapedValue;
  if (printAsMultipleLines || forceTrailingNewline) {
    result += "\n";
  }
  return '"""' + result + '"""';
}

// node_modules/graphql/language/tokenKind.mjs
var TokenKind;
(function(TokenKind2) {
  TokenKind2["SOF"] = "<SOF>";
  TokenKind2["EOF"] = "<EOF>";
  TokenKind2["BANG"] = "!";
  TokenKind2["DOLLAR"] = "$";
  TokenKind2["AMP"] = "&";
  TokenKind2["PAREN_L"] = "(";
  TokenKind2["PAREN_R"] = ")";
  TokenKind2["SPREAD"] = "...";
  TokenKind2["COLON"] = ":";
  TokenKind2["EQUALS"] = "=";
  TokenKind2["AT"] = "@";
  TokenKind2["BRACKET_L"] = "[";
  TokenKind2["BRACKET_R"] = "]";
  TokenKind2["BRACE_L"] = "{";
  TokenKind2["PIPE"] = "|";
  TokenKind2["BRACE_R"] = "}";
  TokenKind2["NAME"] = "Name";
  TokenKind2["INT"] = "Int";
  TokenKind2["FLOAT"] = "Float";
  TokenKind2["STRING"] = "String";
  TokenKind2["BLOCK_STRING"] = "BlockString";
  TokenKind2["COMMENT"] = "Comment";
})(TokenKind || (TokenKind = {}));

// node_modules/graphql/language/lexer.mjs
var Lexer = class {
  /**
   * The previously focused non-ignored token.
   */
  /**
   * The currently focused non-ignored token.
   */
  /**
   * The (1-indexed) line containing the current token.
   */
  /**
   * The character offset at which the current line begins.
   */
  constructor(source) {
    const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);
    this.source = source;
    this.lastToken = startOfFileToken;
    this.token = startOfFileToken;
    this.line = 1;
    this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  /**
   * Advances the token stream to the next non-ignored token.
   */
  advance() {
    this.lastToken = this.token;
    const token = this.token = this.lookahead();
    return token;
  }
  /**
   * Looks ahead and returns the next non-ignored token, but does not change
   * the state of Lexer.
   */
  lookahead() {
    let token = this.token;
    if (token.kind !== TokenKind.EOF) {
      do {
        if (token.next) {
          token = token.next;
        } else {
          const nextToken = readNextToken(this, token.end);
          token.next = nextToken;
          nextToken.prev = token;
          token = nextToken;
        }
      } while (token.kind === TokenKind.COMMENT);
    }
    return token;
  }
};
function isPunctuatorTokenKind(kind) {
  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
}
function isUnicodeScalarValue(code) {
  return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
}
function isSupplementaryCodePoint(body, location) {
  return isLeadingSurrogate(body.charCodeAt(location)) && isTrailingSurrogate(body.charCodeAt(location + 1));
}
function isLeadingSurrogate(code) {
  return code >= 55296 && code <= 56319;
}
function isTrailingSurrogate(code) {
  return code >= 56320 && code <= 57343;
}
function printCodePointAt(lexer, location) {
  const code = lexer.source.body.codePointAt(location);
  if (code === void 0) {
    return TokenKind.EOF;
  } else if (code >= 32 && code <= 126) {
    const char = String.fromCodePoint(code);
    return char === '"' ? `'"'` : `"${char}"`;
  }
  return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
}
function createToken(lexer, kind, start, end, value) {
  const line = lexer.line;
  const col = 1 + start - lexer.lineStart;
  return new Token(kind, start, end, line, col, value);
}
function readNextToken(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    switch (code) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++position;
        continue;
      case 10:
        ++position;
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 13:
        if (body.charCodeAt(position + 1) === 10) {
          position += 2;
        } else {
          ++position;
        }
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 35:
        return readComment(lexer, position);
      case 33:
        return createToken(lexer, TokenKind.BANG, position, position + 1);
      case 36:
        return createToken(lexer, TokenKind.DOLLAR, position, position + 1);
      case 38:
        return createToken(lexer, TokenKind.AMP, position, position + 1);
      case 40:
        return createToken(lexer, TokenKind.PAREN_L, position, position + 1);
      case 41:
        return createToken(lexer, TokenKind.PAREN_R, position, position + 1);
      case 46:
        if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
          return createToken(lexer, TokenKind.SPREAD, position, position + 3);
        }
        break;
      case 58:
        return createToken(lexer, TokenKind.COLON, position, position + 1);
      case 61:
        return createToken(lexer, TokenKind.EQUALS, position, position + 1);
      case 64:
        return createToken(lexer, TokenKind.AT, position, position + 1);
      case 91:
        return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);
      case 93:
        return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);
      case 123:
        return createToken(lexer, TokenKind.BRACE_L, position, position + 1);
      case 124:
        return createToken(lexer, TokenKind.PIPE, position, position + 1);
      case 125:
        return createToken(lexer, TokenKind.BRACE_R, position, position + 1);
      case 34:
        if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
          return readBlockString(lexer, position);
        }
        return readString(lexer, position);
    }
    if (isDigit(code) || code === 45) {
      return readNumber(lexer, position, code);
    }
    if (isNameStart(code)) {
      return readName(lexer, position);
    }
    throw syntaxError(
      lexer.source,
      position,
      code === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`
    );
  }
  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);
}
function readComment(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      break;
    }
  }
  return createToken(
    lexer,
    TokenKind.COMMENT,
    start,
    position,
    body.slice(start + 1, position)
  );
}
function readNumber(lexer, start, firstCode) {
  const body = lexer.source.body;
  let position = start;
  let code = firstCode;
  let isFloat = false;
  if (code === 45) {
    code = body.charCodeAt(++position);
  }
  if (code === 48) {
    code = body.charCodeAt(++position);
    if (isDigit(code)) {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid number, unexpected digit after 0: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  } else {
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46) {
    isFloat = true;
    code = body.charCodeAt(++position);
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 69 || code === 101) {
    isFloat = true;
    code = body.charCodeAt(++position);
    if (code === 43 || code === 45) {
      code = body.charCodeAt(++position);
    }
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46 || isNameStart(code)) {
    throw syntaxError(
      lexer.source,
      position,
      `Invalid number, expected digit but got: ${printCodePointAt(
        lexer,
        position
      )}.`
    );
  }
  return createToken(
    lexer,
    isFloat ? TokenKind.FLOAT : TokenKind.INT,
    start,
    position,
    body.slice(start, position)
  );
}
function readDigits(lexer, start, firstCode) {
  if (!isDigit(firstCode)) {
    throw syntaxError(
      lexer.source,
      start,
      `Invalid number, expected digit but got: ${printCodePointAt(
        lexer,
        start
      )}.`
    );
  }
  const body = lexer.source.body;
  let position = start + 1;
  while (isDigit(body.charCodeAt(position))) {
    ++position;
  }
  return position;
}
function readString(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  let chunkStart = position;
  let value = "";
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34) {
      value += body.slice(chunkStart, position);
      return createToken(lexer, TokenKind.STRING, start, position + 1, value);
    }
    if (code === 92) {
      value += body.slice(chunkStart, position);
      const escape2 = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
      value += escape2.value;
      position += escape2.size;
      chunkStart = position;
      continue;
    }
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid character within String: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
}
function readEscapedUnicodeVariableWidth(lexer, position) {
  const body = lexer.source.body;
  let point = 0;
  let size = 3;
  while (size < 12) {
    const code = body.charCodeAt(position + size++);
    if (code === 125) {
      if (size < 5 || !isUnicodeScalarValue(point)) {
        break;
      }
      return {
        value: String.fromCodePoint(point),
        size
      };
    }
    point = point << 4 | readHexDigit(code);
    if (point < 0) {
      break;
    }
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid Unicode escape sequence: "${body.slice(
      position,
      position + size
    )}".`
  );
}
function readEscapedUnicodeFixedWidth(lexer, position) {
  const body = lexer.source.body;
  const code = read16BitHexCode(body, position + 2);
  if (isUnicodeScalarValue(code)) {
    return {
      value: String.fromCodePoint(code),
      size: 6
    };
  }
  if (isLeadingSurrogate(code)) {
    if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
      const trailingCode = read16BitHexCode(body, position + 8);
      if (isTrailingSurrogate(trailingCode)) {
        return {
          value: String.fromCodePoint(code, trailingCode),
          size: 12
        };
      }
    }
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`
  );
}
function read16BitHexCode(body, position) {
  return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
}
function readHexDigit(code) {
  return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
}
function readEscapedCharacter(lexer, position) {
  const body = lexer.source.body;
  const code = body.charCodeAt(position + 1);
  switch (code) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: "\n",
        size: 2
      };
    case 114:
      return {
        value: "\r",
        size: 2
      };
    case 116:
      return {
        value: "	",
        size: 2
      };
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid character escape sequence: "${body.slice(
      position,
      position + 2
    )}".`
  );
}
function readBlockString(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let lineStart = lexer.lineStart;
  let position = start + 3;
  let chunkStart = position;
  let currentLine = "";
  const blockLines = [];
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      const token = createToken(
        lexer,
        TokenKind.BLOCK_STRING,
        start,
        position + 3,
        // Return a string of the lines joined with U+000A.
        dedentBlockStringLines(blockLines).join("\n")
      );
      lexer.line += blockLines.length - 1;
      lexer.lineStart = lineStart;
      return token;
    }
    if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
      currentLine += body.slice(chunkStart, position);
      chunkStart = position + 1;
      position += 4;
      continue;
    }
    if (code === 10 || code === 13) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      if (code === 13 && body.charCodeAt(position + 1) === 10) {
        position += 2;
      } else {
        ++position;
      }
      currentLine = "";
      chunkStart = position;
      lineStart = position;
      continue;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid character within String: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
}
function readName(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (isNameContinue(code)) {
      ++position;
    } else {
      break;
    }
  }
  return createToken(
    lexer,
    TokenKind.NAME,
    start,
    position,
    body.slice(start, position)
  );
}

// node_modules/graphql/jsutils/inspect.mjs
var MAX_ARRAY_LENGTH = 10;
var MAX_RECURSIVE_DEPTH = 2;
function inspect(value) {
  return formatValue(value, []);
}
function formatValue(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue(value, seenValues);
    default:
      return String(value);
  }
}
function formatObjectValue(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }
  return formatObject(value, seenValues);
}
function isJSONable(value) {
  return typeof value.toJSON === "function";
}
function formatObject(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object) + "]";
  }
  const properties = entries.map(
    ([key, value]) => key + ": " + formatValue(value, seenValues)
  );
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = Math.min(MAX_ARRAY_LENGTH, array.length);
  const remaining = array.length - len;
  const items = [];
  for (let i49 = 0; i49 < len; ++i49) {
    items.push(formatValue(array[i49], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
}
function getObjectTag(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name = object.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
}

// node_modules/graphql/jsutils/instanceOf.mjs
var isProduction = globalThis.process && // eslint-disable-next-line no-undef
false;
var instanceOf = (
  /* c8 ignore next 6 */
  // FIXME: https://github.com/graphql/graphql-js/issues/2317
  isProduction ? function instanceOf2(value, constructor) {
    return value instanceof constructor;
  } : function instanceOf3(value, constructor) {
    if (value instanceof constructor) {
      return true;
    }
    if (typeof value === "object" && value !== null) {
      var _value$constructor;
      const className = constructor.prototype[Symbol.toStringTag];
      const valueClassName = (
        // We still need to support constructor's name to detect conflicts with older versions of this library.
        Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name
      );
      if (className === valueClassName) {
        const stringifiedValue = inspect(value);
        throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
      }
    }
    return false;
  }
);

// node_modules/graphql/language/source.mjs
var Source = class {
  constructor(body, name = "GraphQL request", locationOffset = {
    line: 1,
    column: 1
  }) {
    typeof body === "string" || devAssert(false, `Body must be a string. Received: ${inspect(body)}.`);
    this.body = body;
    this.name = name;
    this.locationOffset = locationOffset;
    this.locationOffset.line > 0 || devAssert(
      false,
      "line in locationOffset is 1-indexed and must be positive."
    );
    this.locationOffset.column > 0 || devAssert(
      false,
      "column in locationOffset is 1-indexed and must be positive."
    );
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
};
function isSource(source) {
  return instanceOf(source, Source);
}

// node_modules/graphql/language/parser.mjs
function parse(source, options) {
  const parser = new Parser(source, options);
  return parser.parseDocument();
}
var Parser = class {
  constructor(source, options = {}) {
    const sourceObj = isSource(source) ? source : new Source(source);
    this._lexer = new Lexer(sourceObj);
    this._options = options;
    this._tokenCounter = 0;
  }
  /**
   * Converts a name lex token into a name parse node.
   */
  parseName() {
    const token = this.expectToken(TokenKind.NAME);
    return this.node(token, {
      kind: Kind.NAME,
      value: token.value
    });
  }
  // Implements the parsing rules in the Document section.
  /**
   * Document : Definition+
   */
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: Kind.DOCUMENT,
      definitions: this.many(
        TokenKind.SOF,
        this.parseDefinition,
        TokenKind.EOF
      )
    });
  }
  /**
   * Definition :
   *   - ExecutableDefinition
   *   - TypeSystemDefinition
   *   - TypeSystemExtension
   *
   * ExecutableDefinition :
   *   - OperationDefinition
   *   - FragmentDefinition
   *
   * TypeSystemDefinition :
   *   - SchemaDefinition
   *   - TypeDefinition
   *   - DirectiveDefinition
   *
   * TypeDefinition :
   *   - ScalarTypeDefinition
   *   - ObjectTypeDefinition
   *   - InterfaceTypeDefinition
   *   - UnionTypeDefinition
   *   - EnumTypeDefinition
   *   - InputObjectTypeDefinition
   */
  parseDefinition() {
    if (this.peek(TokenKind.BRACE_L)) {
      return this.parseOperationDefinition();
    }
    const hasDescription = this.peekDescription();
    const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
      if (hasDescription) {
        throw syntaxError(
          this._lexer.source,
          this._lexer.token.start,
          "Unexpected description, descriptions are supported only on type definitions."
        );
      }
      switch (keywordToken.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  // Implements the parsing rules in the Operations section.
  /**
   * OperationDefinition :
   *  - SelectionSet
   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
   */
  parseOperationDefinition() {
    const start = this._lexer.token;
    if (this.peek(TokenKind.BRACE_L)) {
      return this.node(start, {
        kind: Kind.OPERATION_DEFINITION,
        operation: OperationTypeNode.QUERY,
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      });
    }
    const operation = this.parseOperationType();
    let name;
    if (this.peek(TokenKind.NAME)) {
      name = this.parseName();
    }
    return this.node(start, {
      kind: Kind.OPERATION_DEFINITION,
      operation,
      name,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * OperationType : one of query mutation subscription
   */
  parseOperationType() {
    const operationToken = this.expectToken(TokenKind.NAME);
    switch (operationToken.value) {
      case "query":
        return OperationTypeNode.QUERY;
      case "mutation":
        return OperationTypeNode.MUTATION;
      case "subscription":
        return OperationTypeNode.SUBSCRIPTION;
    }
    throw this.unexpected(operationToken);
  }
  /**
   * VariableDefinitions : ( VariableDefinition+ )
   */
  parseVariableDefinitions() {
    return this.optionalMany(
      TokenKind.PAREN_L,
      this.parseVariableDefinition,
      TokenKind.PAREN_R
    );
  }
  /**
   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
   */
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: Kind.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
      directives: this.parseConstDirectives()
    });
  }
  /**
   * Variable : $ Name
   */
  parseVariable() {
    const start = this._lexer.token;
    this.expectToken(TokenKind.DOLLAR);
    return this.node(start, {
      kind: Kind.VARIABLE,
      name: this.parseName()
    });
  }
  /**
   * ```
   * SelectionSet : { Selection+ }
   * ```
   */
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: Kind.SELECTION_SET,
      selections: this.many(
        TokenKind.BRACE_L,
        this.parseSelection,
        TokenKind.BRACE_R
      )
    });
  }
  /**
   * Selection :
   *   - Field
   *   - FragmentSpread
   *   - InlineFragment
   */
  parseSelection() {
    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
  }
  /**
   * Field : Alias? Name Arguments? Directives? SelectionSet?
   *
   * Alias : Name :
   */
  parseField() {
    const start = this._lexer.token;
    const nameOrAlias = this.parseName();
    let alias;
    let name;
    if (this.expectOptionalToken(TokenKind.COLON)) {
      alias = nameOrAlias;
      name = this.parseName();
    } else {
      name = nameOrAlias;
    }
    return this.node(start, {
      kind: Kind.FIELD,
      alias,
      name,
      arguments: this.parseArguments(false),
      directives: this.parseDirectives(false),
      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
    });
  }
  /**
   * Arguments[Const] : ( Argument[?Const]+ )
   */
  parseArguments(isConst) {
    const item = isConst ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
  }
  /**
   * Argument[Const] : Name : Value[?Const]
   */
  parseArgument(isConst = false) {
    const start = this._lexer.token;
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start, {
      kind: Kind.ARGUMENT,
      name,
      value: this.parseValueLiteral(isConst)
    });
  }
  parseConstArgument() {
    return this.parseArgument(true);
  }
  // Implements the parsing rules in the Fragments section.
  /**
   * Corresponds to both FragmentSpread and InlineFragment in the spec.
   *
   * FragmentSpread : ... FragmentName Directives?
   *
   * InlineFragment : ... TypeCondition? Directives? SelectionSet
   */
  parseFragment() {
    const start = this._lexer.token;
    this.expectToken(TokenKind.SPREAD);
    const hasTypeCondition = this.expectOptionalKeyword("on");
    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
      return this.node(start, {
        kind: Kind.FRAGMENT_SPREAD,
        name: this.parseFragmentName(),
        directives: this.parseDirectives(false)
      });
    }
    return this.node(start, {
      kind: Kind.INLINE_FRAGMENT,
      typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentDefinition :
   *   - fragment FragmentName on TypeCondition Directives? SelectionSet
   *
   * TypeCondition : NamedType
   */
  parseFragmentDefinition() {
    const start = this._lexer.token;
    this.expectKeyword("fragment");
    if (this._options.allowLegacyFragmentVariables === true) {
      return this.node(start, {
        kind: Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        variableDefinitions: this.parseVariableDefinitions(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    return this.node(start, {
      kind: Kind.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentName : Name but not `on`
   */
  parseFragmentName() {
    if (this._lexer.token.value === "on") {
      throw this.unexpected();
    }
    return this.parseName();
  }
  // Implements the parsing rules in the Values section.
  /**
   * Value[Const] :
   *   - [~Const] Variable
   *   - IntValue
   *   - FloatValue
   *   - StringValue
   *   - BooleanValue
   *   - NullValue
   *   - EnumValue
   *   - ListValue[?Const]
   *   - ObjectValue[?Const]
   *
   * BooleanValue : one of `true` `false`
   *
   * NullValue : `null`
   *
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseValueLiteral(isConst) {
    const token = this._lexer.token;
    switch (token.kind) {
      case TokenKind.BRACKET_L:
        return this.parseList(isConst);
      case TokenKind.BRACE_L:
        return this.parseObject(isConst);
      case TokenKind.INT:
        this.advanceLexer();
        return this.node(token, {
          kind: Kind.INT,
          value: token.value
        });
      case TokenKind.FLOAT:
        this.advanceLexer();
        return this.node(token, {
          kind: Kind.FLOAT,
          value: token.value
        });
      case TokenKind.STRING:
      case TokenKind.BLOCK_STRING:
        return this.parseStringLiteral();
      case TokenKind.NAME:
        this.advanceLexer();
        switch (token.value) {
          case "true":
            return this.node(token, {
              kind: Kind.BOOLEAN,
              value: true
            });
          case "false":
            return this.node(token, {
              kind: Kind.BOOLEAN,
              value: false
            });
          case "null":
            return this.node(token, {
              kind: Kind.NULL
            });
          default:
            return this.node(token, {
              kind: Kind.ENUM,
              value: token.value
            });
        }
      case TokenKind.DOLLAR:
        if (isConst) {
          this.expectToken(TokenKind.DOLLAR);
          if (this._lexer.token.kind === TokenKind.NAME) {
            const varName = this._lexer.token.value;
            throw syntaxError(
              this._lexer.source,
              token.start,
              `Unexpected variable "$${varName}" in constant value.`
            );
          } else {
            throw this.unexpected(token);
          }
        }
        return this.parseVariable();
      default:
        throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(true);
  }
  parseStringLiteral() {
    const token = this._lexer.token;
    this.advanceLexer();
    return this.node(token, {
      kind: Kind.STRING,
      value: token.value,
      block: token.kind === TokenKind.BLOCK_STRING
    });
  }
  /**
   * ListValue[Const] :
   *   - [ ]
   *   - [ Value[?Const]+ ]
   */
  parseList(isConst) {
    const item = () => this.parseValueLiteral(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.LIST,
      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)
    });
  }
  /**
   * ```
   * ObjectValue[Const] :
   *   - { }
   *   - { ObjectField[?Const]+ }
   * ```
   */
  parseObject(isConst) {
    const item = () => this.parseObjectField(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.OBJECT,
      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)
    });
  }
  /**
   * ObjectField[Const] : Name : Value[?Const]
   */
  parseObjectField(isConst) {
    const start = this._lexer.token;
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start, {
      kind: Kind.OBJECT_FIELD,
      name,
      value: this.parseValueLiteral(isConst)
    });
  }
  // Implements the parsing rules in the Directives section.
  /**
   * Directives[Const] : Directive[?Const]+
   */
  parseDirectives(isConst) {
    const directives = [];
    while (this.peek(TokenKind.AT)) {
      directives.push(this.parseDirective(isConst));
    }
    return directives;
  }
  parseConstDirectives() {
    return this.parseDirectives(true);
  }
  /**
   * ```
   * Directive[Const] : @ Name Arguments[?Const]?
   * ```
   */
  parseDirective(isConst) {
    const start = this._lexer.token;
    this.expectToken(TokenKind.AT);
    return this.node(start, {
      kind: Kind.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(isConst)
    });
  }
  // Implements the parsing rules in the Types section.
  /**
   * Type :
   *   - NamedType
   *   - ListType
   *   - NonNullType
   */
  parseTypeReference() {
    const start = this._lexer.token;
    let type;
    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
      const innerType = this.parseTypeReference();
      this.expectToken(TokenKind.BRACKET_R);
      type = this.node(start, {
        kind: Kind.LIST_TYPE,
        type: innerType
      });
    } else {
      type = this.parseNamedType();
    }
    if (this.expectOptionalToken(TokenKind.BANG)) {
      return this.node(start, {
        kind: Kind.NON_NULL_TYPE,
        type
      });
    }
    return type;
  }
  /**
   * NamedType : Name
   */
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: Kind.NAMED_TYPE,
      name: this.parseName()
    });
  }
  // Implements the parsing rules in the Type Definition section.
  peekDescription() {
    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
  }
  /**
   * Description : StringValue
   */
  parseDescription() {
    if (this.peekDescription()) {
      return this.parseStringLiteral();
    }
  }
  /**
   * ```
   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
   * ```
   */
  parseSchemaDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("schema");
    const directives = this.parseConstDirectives();
    const operationTypes = this.many(
      TokenKind.BRACE_L,
      this.parseOperationTypeDefinition,
      TokenKind.BRACE_R
    );
    return this.node(start, {
      kind: Kind.SCHEMA_DEFINITION,
      description,
      directives,
      operationTypes
    });
  }
  /**
   * OperationTypeDefinition : OperationType : NamedType
   */
  parseOperationTypeDefinition() {
    const start = this._lexer.token;
    const operation = this.parseOperationType();
    this.expectToken(TokenKind.COLON);
    const type = this.parseNamedType();
    return this.node(start, {
      kind: Kind.OPERATION_TYPE_DEFINITION,
      operation,
      type
    });
  }
  /**
   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
   */
  parseScalarTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("scalar");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.SCALAR_TYPE_DEFINITION,
      description,
      name,
      directives
    });
  }
  /**
   * ObjectTypeDefinition :
   *   Description?
   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
   */
  parseObjectTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("type");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start, {
      kind: Kind.OBJECT_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * ImplementsInterfaces :
   *   - implements `&`? NamedType
   *   - ImplementsInterfaces & NamedType
   */
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword("implements") ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];
  }
  /**
   * ```
   * FieldsDefinition : { FieldDefinition+ }
   * ```
   */
  parseFieldsDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseFieldDefinition,
      TokenKind.BRACE_R
    );
  }
  /**
   * FieldDefinition :
   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
   */
  parseFieldDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseName();
    const args = this.parseArgumentDefs();
    this.expectToken(TokenKind.COLON);
    const type = this.parseTypeReference();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.FIELD_DEFINITION,
      description,
      name,
      arguments: args,
      type,
      directives
    });
  }
  /**
   * ArgumentsDefinition : ( InputValueDefinition+ )
   */
  parseArgumentDefs() {
    return this.optionalMany(
      TokenKind.PAREN_L,
      this.parseInputValueDef,
      TokenKind.PAREN_R
    );
  }
  /**
   * InputValueDefinition :
   *   - Description? Name : Type DefaultValue? Directives[Const]?
   */
  parseInputValueDef() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    const type = this.parseTypeReference();
    let defaultValue;
    if (this.expectOptionalToken(TokenKind.EQUALS)) {
      defaultValue = this.parseConstValueLiteral();
    }
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.INPUT_VALUE_DEFINITION,
      description,
      name,
      type,
      defaultValue,
      directives
    });
  }
  /**
   * InterfaceTypeDefinition :
   *   - Description? interface Name Directives[Const]? FieldsDefinition?
   */
  parseInterfaceTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("interface");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start, {
      kind: Kind.INTERFACE_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * UnionTypeDefinition :
   *   - Description? union Name Directives[Const]? UnionMemberTypes?
   */
  parseUnionTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("union");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const types = this.parseUnionMemberTypes();
    return this.node(start, {
      kind: Kind.UNION_TYPE_DEFINITION,
      description,
      name,
      directives,
      types
    });
  }
  /**
   * UnionMemberTypes :
   *   - = `|`? NamedType
   *   - UnionMemberTypes | NamedType
   */
  parseUnionMemberTypes() {
    return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
  }
  /**
   * EnumTypeDefinition :
   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
   */
  parseEnumTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("enum");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const values = this.parseEnumValuesDefinition();
    return this.node(start, {
      kind: Kind.ENUM_TYPE_DEFINITION,
      description,
      name,
      directives,
      values
    });
  }
  /**
   * ```
   * EnumValuesDefinition : { EnumValueDefinition+ }
   * ```
   */
  parseEnumValuesDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseEnumValueDefinition,
      TokenKind.BRACE_R
    );
  }
  /**
   * EnumValueDefinition : Description? EnumValue Directives[Const]?
   */
  parseEnumValueDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseEnumValueName();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.ENUM_VALUE_DEFINITION,
      description,
      name,
      directives
    });
  }
  /**
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseEnumValueName() {
    if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
      throw syntaxError(
        this._lexer.source,
        this._lexer.token.start,
        `${getTokenDesc(
          this._lexer.token
        )} is reserved and cannot be used for an enum value.`
      );
    }
    return this.parseName();
  }
  /**
   * InputObjectTypeDefinition :
   *   - Description? input Name Directives[Const]? InputFieldsDefinition?
   */
  parseInputObjectTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("input");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    return this.node(start, {
      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
      description,
      name,
      directives,
      fields
    });
  }
  /**
   * ```
   * InputFieldsDefinition : { InputValueDefinition+ }
   * ```
   */
  parseInputFieldsDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseInputValueDef,
      TokenKind.BRACE_R
    );
  }
  /**
   * TypeSystemExtension :
   *   - SchemaExtension
   *   - TypeExtension
   *
   * TypeExtension :
   *   - ScalarTypeExtension
   *   - ObjectTypeExtension
   *   - InterfaceTypeExtension
   *   - UnionTypeExtension
   *   - EnumTypeExtension
   *   - InputObjectTypeDefinition
   */
  parseTypeSystemExtension() {
    const keywordToken = this._lexer.lookahead();
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  /**
   * ```
   * SchemaExtension :
   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
   *  - extend schema Directives[Const]
   * ```
   */
  parseSchemaExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("schema");
    const directives = this.parseConstDirectives();
    const operationTypes = this.optionalMany(
      TokenKind.BRACE_L,
      this.parseOperationTypeDefinition,
      TokenKind.BRACE_R
    );
    if (directives.length === 0 && operationTypes.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.SCHEMA_EXTENSION,
      directives,
      operationTypes
    });
  }
  /**
   * ScalarTypeExtension :
   *   - extend scalar Name Directives[Const]
   */
  parseScalarTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("scalar");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    if (directives.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.SCALAR_TYPE_EXTENSION,
      name,
      directives
    });
  }
  /**
   * ObjectTypeExtension :
   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend type Name ImplementsInterfaces? Directives[Const]
   *  - extend type Name ImplementsInterfaces
   */
  parseObjectTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("type");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.OBJECT_TYPE_EXTENSION,
      name,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * InterfaceTypeExtension :
   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend interface Name ImplementsInterfaces? Directives[Const]
   *  - extend interface Name ImplementsInterfaces
   */
  parseInterfaceTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("interface");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.INTERFACE_TYPE_EXTENSION,
      name,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * UnionTypeExtension :
   *   - extend union Name Directives[Const]? UnionMemberTypes
   *   - extend union Name Directives[Const]
   */
  parseUnionTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("union");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const types = this.parseUnionMemberTypes();
    if (directives.length === 0 && types.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.UNION_TYPE_EXTENSION,
      name,
      directives,
      types
    });
  }
  /**
   * EnumTypeExtension :
   *   - extend enum Name Directives[Const]? EnumValuesDefinition
   *   - extend enum Name Directives[Const]
   */
  parseEnumTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("enum");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const values = this.parseEnumValuesDefinition();
    if (directives.length === 0 && values.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.ENUM_TYPE_EXTENSION,
      name,
      directives,
      values
    });
  }
  /**
   * InputObjectTypeExtension :
   *   - extend input Name Directives[Const]? InputFieldsDefinition
   *   - extend input Name Directives[Const]
   */
  parseInputObjectTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("input");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    if (directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
      name,
      directives,
      fields
    });
  }
  /**
   * ```
   * DirectiveDefinition :
   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
   * ```
   */
  parseDirectiveDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("directive");
    this.expectToken(TokenKind.AT);
    const name = this.parseName();
    const args = this.parseArgumentDefs();
    const repeatable = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    const locations = this.parseDirectiveLocations();
    return this.node(start, {
      kind: Kind.DIRECTIVE_DEFINITION,
      description,
      name,
      arguments: args,
      repeatable,
      locations
    });
  }
  /**
   * DirectiveLocations :
   *   - `|`? DirectiveLocation
   *   - DirectiveLocations | DirectiveLocation
   */
  parseDirectiveLocations() {
    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
  }
  /*
   * DirectiveLocation :
   *   - ExecutableDirectiveLocation
   *   - TypeSystemDirectiveLocation
   *
   * ExecutableDirectiveLocation : one of
   *   `QUERY`
   *   `MUTATION`
   *   `SUBSCRIPTION`
   *   `FIELD`
   *   `FRAGMENT_DEFINITION`
   *   `FRAGMENT_SPREAD`
   *   `INLINE_FRAGMENT`
   *
   * TypeSystemDirectiveLocation : one of
   *   `SCHEMA`
   *   `SCALAR`
   *   `OBJECT`
   *   `FIELD_DEFINITION`
   *   `ARGUMENT_DEFINITION`
   *   `INTERFACE`
   *   `UNION`
   *   `ENUM`
   *   `ENUM_VALUE`
   *   `INPUT_OBJECT`
   *   `INPUT_FIELD_DEFINITION`
   */
  parseDirectiveLocation() {
    const start = this._lexer.token;
    const name = this.parseName();
    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {
      return name;
    }
    throw this.unexpected(start);
  }
  // Core parsing utility functions
  /**
   * Returns a node that, if configured to do so, sets a "loc" field as a
   * location object, used to identify the place in the source that created a
   * given parsed object.
   */
  node(startToken, node) {
    if (this._options.noLocation !== true) {
      node.loc = new Location(
        startToken,
        this._lexer.lastToken,
        this._lexer.source
      );
    }
    return node;
  }
  /**
   * Determines if the next token is of a given kind
   */
  peek(kind) {
    return this._lexer.token.kind === kind;
  }
  /**
   * If the next token is of the given kind, return that token after advancing the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectToken(kind) {
    const token = this._lexer.token;
    if (token.kind === kind) {
      this.advanceLexer();
      return token;
    }
    throw syntaxError(
      this._lexer.source,
      token.start,
      `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`
    );
  }
  /**
   * If the next token is of the given kind, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalToken(kind) {
    const token = this._lexer.token;
    if (token.kind === kind) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  /**
   * If the next token is a given keyword, advance the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectKeyword(value) {
    const token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this.advanceLexer();
    } else {
      throw syntaxError(
        this._lexer.source,
        token.start,
        `Expected "${value}", found ${getTokenDesc(token)}.`
      );
    }
  }
  /**
   * If the next token is a given keyword, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalKeyword(value) {
    const token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  /**
   * Helper function for creating an error when an unexpected lexed token is encountered.
   */
  unexpected(atToken) {
    const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
    return syntaxError(
      this._lexer.source,
      token.start,
      `Unexpected ${getTokenDesc(token)}.`
    );
  }
  /**
   * Returns a possibly empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  any(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    while (!this.expectOptionalToken(closeKind)) {
      nodes.push(parseFn.call(this));
    }
    return nodes;
  }
  /**
   * Returns a list of parse nodes, determined by the parseFn.
   * It can be empty only if open token is missing otherwise it will always return non-empty list
   * that begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  optionalMany(openKind, parseFn, closeKind) {
    if (this.expectOptionalToken(openKind)) {
      const nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));
      return nodes;
    }
    return [];
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  many(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (!this.expectOptionalToken(closeKind));
    return nodes;
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
   * Advances the parser to the next lex token after last item in the list.
   */
  delimitedMany(delimiterKind, parseFn) {
    this.expectOptionalToken(delimiterKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (this.expectOptionalToken(delimiterKind));
    return nodes;
  }
  advanceLexer() {
    const { maxTokens } = this._options;
    const token = this._lexer.advance();
    if (maxTokens !== void 0 && token.kind !== TokenKind.EOF) {
      ++this._tokenCounter;
      if (this._tokenCounter > maxTokens) {
        throw syntaxError(
          this._lexer.source,
          token.start,
          `Document contains more that ${maxTokens} tokens. Parsing aborted.`
        );
      }
    }
  }
};
function getTokenDesc(token) {
  const value = token.value;
  return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : "");
}
function getTokenKindDesc(kind) {
  return isPunctuatorTokenKind(kind) ? `"${kind}"` : kind;
}

// node_modules/graphql/jsutils/didYouMean.mjs
var MAX_SUGGESTIONS = 5;
function didYouMean(firstArg, secondArg) {
  const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [void 0, firstArg];
  let message = " Did you mean ";
  if (subMessage) {
    message += subMessage + " ";
  }
  const suggestions = suggestionsArg.map((x11) => `"${x11}"`);
  switch (suggestions.length) {
    case 0:
      return "";
    case 1:
      return message + suggestions[0] + "?";
    case 2:
      return message + suggestions[0] + " or " + suggestions[1] + "?";
  }
  const selected = suggestions.slice(0, MAX_SUGGESTIONS);
  const lastItem = selected.pop();
  return message + selected.join(", ") + ", or " + lastItem + "?";
}

// node_modules/graphql/jsutils/identityFunc.mjs
function identityFunc(x11) {
  return x11;
}

// node_modules/graphql/jsutils/keyMap.mjs
function keyMap(list, keyFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = item;
  }
  return result;
}

// node_modules/graphql/jsutils/keyValMap.mjs
function keyValMap(list, keyFn, valFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = valFn(item);
  }
  return result;
}

// node_modules/graphql/jsutils/mapValue.mjs
function mapValue(map, fn4) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const key of Object.keys(map)) {
    result[key] = fn4(map[key], key);
  }
  return result;
}

// node_modules/graphql/jsutils/naturalCompare.mjs
function naturalCompare(aStr, bStr) {
  let aIndex = 0;
  let bIndex = 0;
  while (aIndex < aStr.length && bIndex < bStr.length) {
    let aChar = aStr.charCodeAt(aIndex);
    let bChar = bStr.charCodeAt(bIndex);
    if (isDigit2(aChar) && isDigit2(bChar)) {
      let aNum = 0;
      do {
        ++aIndex;
        aNum = aNum * 10 + aChar - DIGIT_0;
        aChar = aStr.charCodeAt(aIndex);
      } while (isDigit2(aChar) && aNum > 0);
      let bNum = 0;
      do {
        ++bIndex;
        bNum = bNum * 10 + bChar - DIGIT_0;
        bChar = bStr.charCodeAt(bIndex);
      } while (isDigit2(bChar) && bNum > 0);
      if (aNum < bNum) {
        return -1;
      }
      if (aNum > bNum) {
        return 1;
      }
    } else {
      if (aChar < bChar) {
        return -1;
      }
      if (aChar > bChar) {
        return 1;
      }
      ++aIndex;
      ++bIndex;
    }
  }
  return aStr.length - bStr.length;
}
var DIGIT_0 = 48;
var DIGIT_9 = 57;
function isDigit2(code) {
  return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
}

// node_modules/graphql/jsutils/suggestionList.mjs
function suggestionList(input, options) {
  const optionsByDistance = /* @__PURE__ */ Object.create(null);
  const lexicalDistance = new LexicalDistance(input);
  const threshold = Math.floor(input.length * 0.4) + 1;
  for (const option of options) {
    const distance = lexicalDistance.measure(option, threshold);
    if (distance !== void 0) {
      optionsByDistance[option] = distance;
    }
  }
  return Object.keys(optionsByDistance).sort((a26, b12) => {
    const distanceDiff = optionsByDistance[a26] - optionsByDistance[b12];
    return distanceDiff !== 0 ? distanceDiff : naturalCompare(a26, b12);
  });
}
var LexicalDistance = class {
  constructor(input) {
    this._input = input;
    this._inputLowerCase = input.toLowerCase();
    this._inputArray = stringToArray(this._inputLowerCase);
    this._rows = [
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0)
    ];
  }
  measure(option, threshold) {
    if (this._input === option) {
      return 0;
    }
    const optionLowerCase = option.toLowerCase();
    if (this._inputLowerCase === optionLowerCase) {
      return 1;
    }
    let a26 = stringToArray(optionLowerCase);
    let b12 = this._inputArray;
    if (a26.length < b12.length) {
      const tmp = a26;
      a26 = b12;
      b12 = tmp;
    }
    const aLength = a26.length;
    const bLength = b12.length;
    if (aLength - bLength > threshold) {
      return void 0;
    }
    const rows = this._rows;
    for (let j7 = 0; j7 <= bLength; j7++) {
      rows[0][j7] = j7;
    }
    for (let i49 = 1; i49 <= aLength; i49++) {
      const upRow = rows[(i49 - 1) % 3];
      const currentRow = rows[i49 % 3];
      let smallestCell = currentRow[0] = i49;
      for (let j7 = 1; j7 <= bLength; j7++) {
        const cost = a26[i49 - 1] === b12[j7 - 1] ? 0 : 1;
        let currentCell = Math.min(
          upRow[j7] + 1,
          // delete
          currentRow[j7 - 1] + 1,
          // insert
          upRow[j7 - 1] + cost
          // substitute
        );
        if (i49 > 1 && j7 > 1 && a26[i49 - 1] === b12[j7 - 2] && a26[i49 - 2] === b12[j7 - 1]) {
          const doubleDiagonalCell = rows[(i49 - 2) % 3][j7 - 2];
          currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
        }
        if (currentCell < smallestCell) {
          smallestCell = currentCell;
        }
        currentRow[j7] = currentCell;
      }
      if (smallestCell > threshold) {
        return void 0;
      }
    }
    const distance = rows[aLength % 3][bLength];
    return distance <= threshold ? distance : void 0;
  }
};
function stringToArray(str) {
  const strLength = str.length;
  const array = new Array(strLength);
  for (let i49 = 0; i49 < strLength; ++i49) {
    array[i49] = str.charCodeAt(i49);
  }
  return array;
}

// node_modules/graphql/jsutils/toObjMap.mjs
function toObjMap(obj) {
  if (obj == null) {
    return /* @__PURE__ */ Object.create(null);
  }
  if (Object.getPrototypeOf(obj) === null) {
    return obj;
  }
  const map = /* @__PURE__ */ Object.create(null);
  for (const [key, value] of Object.entries(obj)) {
    map[key] = value;
  }
  return map;
}

// node_modules/graphql/language/printString.mjs
function printString(str) {
  return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
}
var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function escapedReplacer(str) {
  return escapeSequences[str.charCodeAt(0)];
}
var escapeSequences = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
];

// node_modules/graphql/language/visitor.mjs
var BREAK = Object.freeze({});
function visit(root, visitor, visitorKeys = QueryDocumentKeys) {
  const enterLeaveMap = /* @__PURE__ */ new Map();
  for (const kind of Object.values(Kind)) {
    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
  }
  let stack = void 0;
  let inArray = Array.isArray(root);
  let keys = [root];
  let index = -1;
  let edits = [];
  let node = root;
  let key = void 0;
  let parent = void 0;
  const path = [];
  const ancestors = [];
  do {
    index++;
    const isLeaving = index === keys.length;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? void 0 : path[path.length - 1];
      node = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node = node.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === null) {
              node.splice(arrayKey, 1);
              editOffset++;
            } else {
              node[arrayKey] = editValue;
            }
          }
        } else {
          node = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(node)
          );
          for (const [editKey, editValue] of edits) {
            node[editKey] = editValue;
          }
        }
      }
      index = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent) {
      key = inArray ? index : keys[index];
      node = parent[key];
      if (node === null || node === void 0) {
        continue;
      }
      path.push(key);
    }
    let result;
    if (!Array.isArray(node)) {
      var _enterLeaveMap$get, _enterLeaveMap$get2;
      isNode(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);
      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
      result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);
      if (result === BREAK) {
        break;
      }
      if (result === false) {
        if (!isLeaving) {
          path.pop();
          continue;
        }
      } else if (result !== void 0) {
        edits.push([key, result]);
        if (!isLeaving) {
          if (isNode(result)) {
            node = result;
          } else {
            path.pop();
            continue;
          }
        }
      }
    }
    if (result === void 0 && isEdited) {
      edits.push([key, node]);
    }
    if (isLeaving) {
      path.pop();
    } else {
      var _node$kind;
      stack = {
        inArray,
        index,
        keys,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
      index = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root;
}
function getEnterLeaveForKind(visitor, kind) {
  const kindVisitor = visitor[kind];
  if (typeof kindVisitor === "object") {
    return kindVisitor;
  } else if (typeof kindVisitor === "function") {
    return {
      enter: kindVisitor,
      leave: void 0
    };
  }
  return {
    enter: visitor.enter,
    leave: visitor.leave
  };
}

// node_modules/graphql/language/printer.mjs
function print(ast) {
  return visit(ast, printDocASTReducer);
}
var MAX_LINE_LENGTH = 80;
var printDocASTReducer = {
  Name: {
    leave: (node) => node.value
  },
  Variable: {
    leave: (node) => "$" + node.name
  },
  // Document
  Document: {
    leave: (node) => join(node.definitions, "\n\n")
  },
  OperationDefinition: {
    leave(node) {
      const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
      const prefix = join(
        [
          node.operation,
          join([node.name, varDefs]),
          join(node.directives, " ")
        ],
        " "
      );
      return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "))
  },
  SelectionSet: {
    leave: ({ selections }) => block(selections)
  },
  Field: {
    leave({ alias, name, arguments: args, directives, selectionSet }) {
      const prefix = wrap("", alias, ": ") + name;
      let argsLine = prefix + wrap("(", join(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
      }
      return join([argsLine, join(directives, " "), selectionSet], " ");
    }
  },
  Argument: {
    leave: ({ name, value }) => name + ": " + value
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name, directives }) => "..." + name + wrap(" ", join(directives, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition, directives, selectionSet }) => join(
      [
        "...",
        wrap("on ", typeCondition),
        join(directives, " "),
        selectionSet
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (
      // or removed in the future.
      `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
    )
  },
  // Value
  IntValue: {
    leave: ({ value }) => value
  },
  FloatValue: {
    leave: ({ value }) => value
  },
  StringValue: {
    leave: ({ value, block: isBlockString }) => isBlockString ? printBlockString(value) : printString(value)
  },
  BooleanValue: {
    leave: ({ value }) => value ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value }) => value
  },
  ListValue: {
    leave: ({ values }) => "[" + join(values, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields }) => "{" + join(fields, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name, value }) => name + ": " + value
  },
  // Directive
  Directive: {
    leave: ({ name, arguments: args }) => "@" + name + wrap("(", join(args, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name }) => name
  },
  ListType: {
    leave: ({ type }) => "[" + type + "]"
  },
  NonNullType: {
    leave: ({ type }) => type + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description, directives, operationTypes }) => wrap("", description, "\n") + join(["schema", join(directives, " "), block(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type }) => operation + ": " + type
  },
  ScalarTypeDefinition: {
    leave: ({ description, name, directives }) => wrap("", description, "\n") + join(["scalar", name, join(directives, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join(
      [
        "type",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description, name, arguments: args, type, directives }) => wrap("", description, "\n") + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "))
  },
  InputValueDefinition: {
    leave: ({ description, name, type, defaultValue, directives }) => wrap("", description, "\n") + join(
      [name + ": " + type, wrap("= ", defaultValue), join(directives, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join(
      [
        "interface",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description, name, directives, types }) => wrap("", description, "\n") + join(
      ["union", name, join(directives, " "), wrap("= ", join(types, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description, name, directives, values }) => wrap("", description, "\n") + join(["enum", name, join(directives, " "), block(values)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description, name, directives }) => wrap("", description, "\n") + join([name, join(directives, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description, name, directives, fields }) => wrap("", description, "\n") + join(["input", name, join(directives, " "), block(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description, name, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives, operationTypes }) => join(
      ["extend schema", join(directives, " "), block(operationTypes)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join(
      [
        "extend type",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join(
      [
        "extend interface",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name, directives, types }) => join(
      [
        "extend union",
        name,
        join(directives, " "),
        wrap("= ", join(types, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " ")
  }
};
function join(maybeArray, separator = "") {
  var _maybeArray$filter$jo;
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x11) => x11).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
}
function block(array) {
  return wrap("{\n", indent(join(array, "\n")), "\n}");
}
function wrap(start, maybeString, end = "") {
  return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
}
function indent(str) {
  return wrap("  ", str.replace(/\n/g, "\n  "));
}
function hasMultilineItems(maybeArray) {
  var _maybeArray$some;
  return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
}

// node_modules/graphql/utilities/valueFromASTUntyped.mjs
function valueFromASTUntyped(valueNode, variables) {
  switch (valueNode.kind) {
    case Kind.NULL:
      return null;
    case Kind.INT:
      return parseInt(valueNode.value, 10);
    case Kind.FLOAT:
      return parseFloat(valueNode.value);
    case Kind.STRING:
    case Kind.ENUM:
    case Kind.BOOLEAN:
      return valueNode.value;
    case Kind.LIST:
      return valueNode.values.map(
        (node) => valueFromASTUntyped(node, variables)
      );
    case Kind.OBJECT:
      return keyValMap(
        valueNode.fields,
        (field) => field.name.value,
        (field) => valueFromASTUntyped(field.value, variables)
      );
    case Kind.VARIABLE:
      return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
  }
}

// node_modules/graphql/type/assertName.mjs
function assertName(name) {
  name != null || devAssert(false, "Must provide name.");
  typeof name === "string" || devAssert(false, "Expected name to be a string.");
  if (name.length === 0) {
    throw new GraphQLError("Expected name to be a non-empty string.");
  }
  for (let i49 = 1; i49 < name.length; ++i49) {
    if (!isNameContinue(name.charCodeAt(i49))) {
      throw new GraphQLError(
        `Names must only contain [_a-zA-Z0-9] but "${name}" does not.`
      );
    }
  }
  if (!isNameStart(name.charCodeAt(0))) {
    throw new GraphQLError(
      `Names must start with [_a-zA-Z] but "${name}" does not.`
    );
  }
  return name;
}
function assertEnumValueName(name) {
  if (name === "true" || name === "false" || name === "null") {
    throw new GraphQLError(`Enum values cannot be named: ${name}`);
  }
  return assertName(name);
}

// node_modules/graphql/type/definition.mjs
function isType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);
}
function isScalarType(type) {
  return instanceOf(type, GraphQLScalarType);
}
function isObjectType(type) {
  return instanceOf(type, GraphQLObjectType);
}
function isInterfaceType(type) {
  return instanceOf(type, GraphQLInterfaceType);
}
function isUnionType(type) {
  return instanceOf(type, GraphQLUnionType);
}
function isEnumType(type) {
  return instanceOf(type, GraphQLEnumType);
}
function isInputObjectType(type) {
  return instanceOf(type, GraphQLInputObjectType);
}
function isListType(type) {
  return instanceOf(type, GraphQLList);
}
function isNonNullType(type) {
  return instanceOf(type, GraphQLNonNull);
}
function isInputType(type) {
  return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);
}
function isLeafType(type) {
  return isScalarType(type) || isEnumType(type);
}
function isCompositeType(type) {
  return isObjectType(type) || isInterfaceType(type) || isUnionType(type);
}
function isAbstractType(type) {
  return isInterfaceType(type) || isUnionType(type);
}
var GraphQLList = class {
  constructor(ofType) {
    isType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL type.`);
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLList";
  }
  toString() {
    return "[" + String(this.ofType) + "]";
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLNonNull = class {
  constructor(ofType) {
    isNullableType(ofType) || devAssert(
      false,
      `Expected ${inspect(ofType)} to be a GraphQL nullable type.`
    );
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLNonNull";
  }
  toString() {
    return String(this.ofType) + "!";
  }
  toJSON() {
    return this.toString();
  }
};
function isWrappingType(type) {
  return isListType(type) || isNonNullType(type);
}
function isNullableType(type) {
  return isType(type) && !isNonNullType(type);
}
function getNullableType(type) {
  if (type) {
    return isNonNullType(type) ? type.ofType : type;
  }
}
function getNamedType(type) {
  if (type) {
    let unwrappedType = type;
    while (isWrappingType(unwrappedType)) {
      unwrappedType = unwrappedType.ofType;
    }
    return unwrappedType;
  }
}
function resolveReadonlyArrayThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
function resolveObjMapThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
var GraphQLScalarType = class {
  constructor(config) {
    var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
    const parseValue2 = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : identityFunc;
    this.name = assertName(config.name);
    this.description = config.description;
    this.specifiedByURL = config.specifiedByURL;
    this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : identityFunc;
    this.parseValue = parseValue2;
    this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node, variables) => parseValue2(valueFromASTUntyped(node, variables));
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
    config.specifiedByURL == null || typeof config.specifiedByURL === "string" || devAssert(
      false,
      `${this.name} must provide "specifiedByURL" as a string, but got: ${inspect(config.specifiedByURL)}.`
    );
    config.serialize == null || typeof config.serialize === "function" || devAssert(
      false,
      `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`
    );
    if (config.parseLiteral) {
      typeof config.parseValue === "function" && typeof config.parseLiteral === "function" || devAssert(
        false,
        `${this.name} must provide both "parseValue" and "parseLiteral" functions.`
      );
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLScalarType";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      specifiedByURL: this.specifiedByURL,
      serialize: this.serialize,
      parseValue: this.parseValue,
      parseLiteral: this.parseLiteral,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLObjectType = class {
  constructor(config) {
    var _config$extensionASTN2;
    this.name = assertName(config.name);
    this.description = config.description;
    this.isTypeOf = config.isTypeOf;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN2 = config.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];
    this._fields = () => defineFieldMap(config);
    this._interfaces = () => defineInterfaces(config);
    config.isTypeOf == null || typeof config.isTypeOf === "function" || devAssert(
      false,
      `${this.name} must provide "isTypeOf" as a function, but got: ${inspect(config.isTypeOf)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      isTypeOf: this.isTypeOf,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineInterfaces(config) {
  var _config$interfaces;
  const interfaces = resolveReadonlyArrayThunk(
    (_config$interfaces = config.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []
  );
  Array.isArray(interfaces) || devAssert(
    false,
    `${config.name} interfaces must be an Array or a function which returns an Array.`
  );
  return interfaces;
}
function defineFieldMap(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(
    false,
    `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
  );
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    var _fieldConfig$args;
    isPlainObj(fieldConfig) || devAssert(
      false,
      `${config.name}.${fieldName} field config must be an object.`
    );
    fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || devAssert(
      false,
      `${config.name}.${fieldName} field resolver must be a function if provided, but got: ${inspect(fieldConfig.resolve)}.`
    );
    const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
    isPlainObj(argsConfig) || devAssert(
      false,
      `${config.name}.${fieldName} args must be an object with argument names as keys.`
    );
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      args: defineArguments(argsConfig),
      resolve: fieldConfig.resolve,
      subscribe: fieldConfig.subscribe,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function defineArguments(config) {
  return Object.entries(config).map(([argName, argConfig]) => ({
    name: assertName(argName),
    description: argConfig.description,
    type: argConfig.type,
    defaultValue: argConfig.defaultValue,
    deprecationReason: argConfig.deprecationReason,
    extensions: toObjMap(argConfig.extensions),
    astNode: argConfig.astNode
  }));
}
function isPlainObj(obj) {
  return isObjectLike(obj) && !Array.isArray(obj);
}
function fieldsToFieldsConfig(fields) {
  return mapValue(fields, (field) => ({
    description: field.description,
    type: field.type,
    args: argsToArgsConfig(field.args),
    resolve: field.resolve,
    subscribe: field.subscribe,
    deprecationReason: field.deprecationReason,
    extensions: field.extensions,
    astNode: field.astNode
  }));
}
function argsToArgsConfig(args) {
  return keyValMap(
    args,
    (arg) => arg.name,
    (arg) => ({
      description: arg.description,
      type: arg.type,
      defaultValue: arg.defaultValue,
      deprecationReason: arg.deprecationReason,
      extensions: arg.extensions,
      astNode: arg.astNode
    })
  );
}
function isRequiredArgument(arg) {
  return isNonNullType(arg.type) && arg.defaultValue === void 0;
}
var GraphQLInterfaceType = class {
  constructor(config) {
    var _config$extensionASTN3;
    this.name = assertName(config.name);
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN3 = config.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];
    this._fields = defineFieldMap.bind(void 0, config);
    this._interfaces = defineInterfaces.bind(void 0, config);
    config.resolveType == null || typeof config.resolveType === "function" || devAssert(
      false,
      `${this.name} must provide "resolveType" as a function, but got: ${inspect(config.resolveType)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInterfaceType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLUnionType = class {
  constructor(config) {
    var _config$extensionASTN4;
    this.name = assertName(config.name);
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN4 = config.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];
    this._types = defineTypes.bind(void 0, config);
    config.resolveType == null || typeof config.resolveType === "function" || devAssert(
      false,
      `${this.name} must provide "resolveType" as a function, but got: ${inspect(config.resolveType)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLUnionType";
  }
  getTypes() {
    if (typeof this._types === "function") {
      this._types = this._types();
    }
    return this._types;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      types: this.getTypes(),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineTypes(config) {
  const types = resolveReadonlyArrayThunk(config.types);
  Array.isArray(types) || devAssert(
    false,
    `Must provide Array of types or a function which returns such an array for Union ${config.name}.`
  );
  return types;
}
var GraphQLEnumType = class {
  /* <T> */
  constructor(config) {
    var _config$extensionASTN5;
    this.name = assertName(config.name);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN5 = config.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];
    this._values = typeof config.values === "function" ? config.values : defineEnumValues(this.name, config.values);
    this._valueLookup = null;
    this._nameLookup = null;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLEnumType";
  }
  getValues() {
    if (typeof this._values === "function") {
      this._values = defineEnumValues(this.name, this._values());
    }
    return this._values;
  }
  getValue(name) {
    if (this._nameLookup === null) {
      this._nameLookup = keyMap(this.getValues(), (value) => value.name);
    }
    return this._nameLookup[name];
  }
  serialize(outputValue) {
    if (this._valueLookup === null) {
      this._valueLookup = new Map(
        this.getValues().map((enumValue2) => [enumValue2.value, enumValue2])
      );
    }
    const enumValue = this._valueLookup.get(outputValue);
    if (enumValue === void 0) {
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent value: ${inspect(outputValue)}`
      );
    }
    return enumValue.name;
  }
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      const valueStr = inspect(inputValue);
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr)
      );
    }
    const enumValue = this.getValue(inputValue);
    if (enumValue == null) {
      throw new GraphQLError(
        `Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue)
      );
    }
    return enumValue.value;
  }
  parseLiteral(valueNode, _variables) {
    if (valueNode.kind !== Kind.ENUM) {
      const valueStr = print(valueNode);
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr),
        {
          nodes: valueNode
        }
      );
    }
    const enumValue = this.getValue(valueNode.value);
    if (enumValue == null) {
      const valueStr = print(valueNode);
      throw new GraphQLError(
        `Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr),
        {
          nodes: valueNode
        }
      );
    }
    return enumValue.value;
  }
  toConfig() {
    const values = keyValMap(
      this.getValues(),
      (value) => value.name,
      (value) => ({
        description: value.description,
        value: value.value,
        deprecationReason: value.deprecationReason,
        extensions: value.extensions,
        astNode: value.astNode
      })
    );
    return {
      name: this.name,
      description: this.description,
      values,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function didYouMeanEnumValue(enumType, unknownValueStr) {
  const allNames = enumType.getValues().map((value) => value.name);
  const suggestedValues = suggestionList(unknownValueStr, allNames);
  return didYouMean("the enum value", suggestedValues);
}
function defineEnumValues(typeName, valueMap) {
  isPlainObj(valueMap) || devAssert(
    false,
    `${typeName} values must be an object with value names as keys.`
  );
  return Object.entries(valueMap).map(([valueName, valueConfig]) => {
    isPlainObj(valueConfig) || devAssert(
      false,
      `${typeName}.${valueName} must refer to an object with a "value" key representing an internal value but got: ${inspect(valueConfig)}.`
    );
    return {
      name: assertEnumValueName(valueName),
      description: valueConfig.description,
      value: valueConfig.value !== void 0 ? valueConfig.value : valueName,
      deprecationReason: valueConfig.deprecationReason,
      extensions: toObjMap(valueConfig.extensions),
      astNode: valueConfig.astNode
    };
  });
}
var GraphQLInputObjectType = class {
  constructor(config) {
    var _config$extensionASTN6, _config$isOneOf;
    this.name = assertName(config.name);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN6 = config.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];
    this.isOneOf = (_config$isOneOf = config.isOneOf) !== null && _config$isOneOf !== void 0 ? _config$isOneOf : false;
    this._fields = defineInputFieldMap.bind(void 0, config);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInputObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  toConfig() {
    const fields = mapValue(this.getFields(), (field) => ({
      description: field.description,
      type: field.type,
      defaultValue: field.defaultValue,
      deprecationReason: field.deprecationReason,
      extensions: field.extensions,
      astNode: field.astNode
    }));
    return {
      name: this.name,
      description: this.description,
      fields,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes,
      isOneOf: this.isOneOf
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineInputFieldMap(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(
    false,
    `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
  );
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    !("resolve" in fieldConfig) || devAssert(
      false,
      `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`
    );
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      defaultValue: fieldConfig.defaultValue,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function isRequiredInputField(field) {
  return isNonNullType(field.type) && field.defaultValue === void 0;
}

// node_modules/graphql/utilities/typeComparators.mjs
function isTypeSubTypeOf(schema, maybeSubType, superType) {
  if (maybeSubType === superType) {
    return true;
  }
  if (isNonNullType(superType)) {
    if (isNonNullType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isNonNullType(maybeSubType)) {
    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
  }
  if (isListType(superType)) {
    if (isListType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isListType(maybeSubType)) {
    return false;
  }
  return isAbstractType(superType) && (isInterfaceType(maybeSubType) || isObjectType(maybeSubType)) && schema.isSubType(superType, maybeSubType);
}
function doTypesOverlap(schema, typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isAbstractType(typeA)) {
    if (isAbstractType(typeB)) {
      return schema.getPossibleTypes(typeA).some((type) => schema.isSubType(typeB, type));
    }
    return schema.isSubType(typeA, typeB);
  }
  if (isAbstractType(typeB)) {
    return schema.isSubType(typeB, typeA);
  }
  return false;
}

// node_modules/graphql/type/scalars.mjs
var GRAPHQL_MAX_INT = 2147483647;
var GRAPHQL_MIN_INT = -2147483648;
var GraphQLInt = new GraphQLScalarType({
  name: "Int",
  description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (typeof num !== "number" || !Number.isInteger(num)) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${inspect(coercedValue)}`
      );
    }
    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        "Int cannot represent non 32-bit signed integer value: " + inspect(coercedValue)
      );
    }
    return num;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${inspect(inputValue)}`
      );
    }
    if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        `Int cannot represent non 32-bit signed integer value: ${inputValue}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${print(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    const num = parseInt(valueNode.value, 10);
    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        `Int cannot represent non 32-bit signed integer value: ${valueNode.value}`,
        {
          nodes: valueNode
        }
      );
    }
    return num;
  }
});
var GraphQLFloat = new GraphQLScalarType({
  name: "Float",
  description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (typeof num !== "number" || !Number.isFinite(num)) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${inspect(coercedValue)}`
      );
    }
    return num;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.FLOAT && valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${print(valueNode)}`,
        valueNode
      );
    }
    return parseFloat(valueNode.value);
  }
});
var GraphQLString = new GraphQLScalarType({
  name: "String",
  description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (typeof coercedValue === "boolean") {
      return coercedValue ? "true" : "false";
    }
    if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
      return coercedValue.toString();
    }
    throw new GraphQLError(
      `String cannot represent value: ${inspect(outputValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      throw new GraphQLError(
        `String cannot represent a non string value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING) {
      throw new GraphQLError(
        `String cannot represent a non string value: ${print(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var GraphQLBoolean = new GraphQLScalarType({
  name: "Boolean",
  description: "The `Boolean` scalar type represents `true` or `false`.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue;
    }
    if (Number.isFinite(coercedValue)) {
      return coercedValue !== 0;
    }
    throw new GraphQLError(
      `Boolean cannot represent a non boolean value: ${inspect(coercedValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "boolean") {
      throw new GraphQLError(
        `Boolean cannot represent a non boolean value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.BOOLEAN) {
      throw new GraphQLError(
        `Boolean cannot represent a non boolean value: ${print(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var GraphQLID = new GraphQLScalarType({
  name: "ID",
  description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (Number.isInteger(coercedValue)) {
      return String(coercedValue);
    }
    throw new GraphQLError(
      `ID cannot represent value: ${inspect(outputValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue === "string") {
      return inputValue;
    }
    if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
      return inputValue.toString();
    }
    throw new GraphQLError(`ID cannot represent value: ${inspect(inputValue)}`);
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING && valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        "ID cannot represent a non-string and non-integer value: " + print(valueNode),
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var specifiedScalarTypes = Object.freeze([
  GraphQLString,
  GraphQLInt,
  GraphQLFloat,
  GraphQLBoolean,
  GraphQLID
]);
function serializeObject(outputValue) {
  if (isObjectLike(outputValue)) {
    if (typeof outputValue.valueOf === "function") {
      const valueOfResult = outputValue.valueOf();
      if (!isObjectLike(valueOfResult)) {
        return valueOfResult;
      }
    }
    if (typeof outputValue.toJSON === "function") {
      return outputValue.toJSON();
    }
  }
  return outputValue;
}

// node_modules/graphql/type/directives.mjs
var GraphQLDirective = class {
  constructor(config) {
    var _config$isRepeatable, _config$args;
    this.name = assertName(config.name);
    this.description = config.description;
    this.locations = config.locations;
    this.isRepeatable = (_config$isRepeatable = config.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    Array.isArray(config.locations) || devAssert(false, `@${config.name} locations must be an Array.`);
    const args = (_config$args = config.args) !== null && _config$args !== void 0 ? _config$args : {};
    isObjectLike(args) && !Array.isArray(args) || devAssert(
      false,
      `@${config.name} args must be an object with argument names as keys.`
    );
    this.args = defineArguments(args);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLDirective";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      locations: this.locations,
      args: argsToArgsConfig(this.args),
      isRepeatable: this.isRepeatable,
      extensions: this.extensions,
      astNode: this.astNode
    };
  }
  toString() {
    return "@" + this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLIncludeDirective = new GraphQLDirective({
  name: "include",
  description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Included when true."
    }
  }
});
var GraphQLSkipDirective = new GraphQLDirective({
  name: "skip",
  description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Skipped when true."
    }
  }
});
var DEFAULT_DEPRECATION_REASON = "No longer supported";
var GraphQLDeprecatedDirective = new GraphQLDirective({
  name: "deprecated",
  description: "Marks an element of a GraphQL schema as no longer supported.",
  locations: [
    DirectiveLocation.FIELD_DEFINITION,
    DirectiveLocation.ARGUMENT_DEFINITION,
    DirectiveLocation.INPUT_FIELD_DEFINITION,
    DirectiveLocation.ENUM_VALUE
  ],
  args: {
    reason: {
      type: GraphQLString,
      description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
      defaultValue: DEFAULT_DEPRECATION_REASON
    }
  }
});
var GraphQLSpecifiedByDirective = new GraphQLDirective({
  name: "specifiedBy",
  description: "Exposes a URL that specifies the behavior of this scalar.",
  locations: [DirectiveLocation.SCALAR],
  args: {
    url: {
      type: new GraphQLNonNull(GraphQLString),
      description: "The URL that specifies the behavior of this scalar."
    }
  }
});
var GraphQLOneOfDirective = new GraphQLDirective({
  name: "oneOf",
  description: "Indicates exactly one field must be supplied and this field must not be `null`.",
  locations: [DirectiveLocation.INPUT_OBJECT],
  args: {}
});
var specifiedDirectives = Object.freeze([
  GraphQLIncludeDirective,
  GraphQLSkipDirective,
  GraphQLDeprecatedDirective,
  GraphQLSpecifiedByDirective,
  GraphQLOneOfDirective
]);

// node_modules/graphql/jsutils/isIterableObject.mjs
function isIterableObject(maybeIterable) {
  return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === void 0 ? void 0 : maybeIterable[Symbol.iterator]) === "function";
}

// node_modules/graphql/utilities/astFromValue.mjs
function astFromValue(value, type) {
  if (isNonNullType(type)) {
    const astValue = astFromValue(value, type.ofType);
    if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === Kind.NULL) {
      return null;
    }
    return astValue;
  }
  if (value === null) {
    return {
      kind: Kind.NULL
    };
  }
  if (value === void 0) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (isIterableObject(value)) {
      const valuesNodes = [];
      for (const item of value) {
        const itemNode = astFromValue(item, itemType);
        if (itemNode != null) {
          valuesNodes.push(itemNode);
        }
      }
      return {
        kind: Kind.LIST,
        values: valuesNodes
      };
    }
    return astFromValue(value, itemType);
  }
  if (isInputObjectType(type)) {
    if (!isObjectLike(value)) {
      return null;
    }
    const fieldNodes = [];
    for (const field of Object.values(type.getFields())) {
      const fieldValue = astFromValue(value[field.name], field.type);
      if (fieldValue) {
        fieldNodes.push({
          kind: Kind.OBJECT_FIELD,
          name: {
            kind: Kind.NAME,
            value: field.name
          },
          value: fieldValue
        });
      }
    }
    return {
      kind: Kind.OBJECT,
      fields: fieldNodes
    };
  }
  if (isLeafType(type)) {
    const serialized = type.serialize(value);
    if (serialized == null) {
      return null;
    }
    if (typeof serialized === "boolean") {
      return {
        kind: Kind.BOOLEAN,
        value: serialized
      };
    }
    if (typeof serialized === "number" && Number.isFinite(serialized)) {
      const stringNum = String(serialized);
      return integerStringRegExp.test(stringNum) ? {
        kind: Kind.INT,
        value: stringNum
      } : {
        kind: Kind.FLOAT,
        value: stringNum
      };
    }
    if (typeof serialized === "string") {
      if (isEnumType(type)) {
        return {
          kind: Kind.ENUM,
          value: serialized
        };
      }
      if (type === GraphQLID && integerStringRegExp.test(serialized)) {
        return {
          kind: Kind.INT,
          value: serialized
        };
      }
      return {
        kind: Kind.STRING,
        value: serialized
      };
    }
    throw new TypeError(`Cannot convert value to AST: ${inspect(serialized)}.`);
  }
  invariant(false, "Unexpected input type: " + inspect(type));
}
var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;

// node_modules/graphql/type/introspection.mjs
var __Schema = new GraphQLObjectType({
  name: "__Schema",
  description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
  fields: () => ({
    description: {
      type: GraphQLString,
      resolve: (schema) => schema.description
    },
    types: {
      description: "A list of all types supported by this server.",
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Type))),
      resolve(schema) {
        return Object.values(schema.getTypeMap());
      }
    },
    queryType: {
      description: "The type that query operations will be rooted at.",
      type: new GraphQLNonNull(__Type),
      resolve: (schema) => schema.getQueryType()
    },
    mutationType: {
      description: "If this server supports mutation, the type that mutation operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getMutationType()
    },
    subscriptionType: {
      description: "If this server support subscription, the type that subscription operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getSubscriptionType()
    },
    directives: {
      description: "A list of all directives supported by this server.",
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__Directive))
      ),
      resolve: (schema) => schema.getDirectives()
    }
  })
});
var __Directive = new GraphQLObjectType({
  name: "__Directive",
  description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (directive) => directive.name
    },
    description: {
      type: GraphQLString,
      resolve: (directive) => directive.description
    },
    isRepeatable: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (directive) => directive.isRepeatable
    },
    locations: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__DirectiveLocation))
      ),
      resolve: (directive) => directive.locations
    },
    args: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__InputValue))
      ),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    }
  })
});
var __DirectiveLocation = new GraphQLEnumType({
  name: "__DirectiveLocation",
  description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
  values: {
    QUERY: {
      value: DirectiveLocation.QUERY,
      description: "Location adjacent to a query operation."
    },
    MUTATION: {
      value: DirectiveLocation.MUTATION,
      description: "Location adjacent to a mutation operation."
    },
    SUBSCRIPTION: {
      value: DirectiveLocation.SUBSCRIPTION,
      description: "Location adjacent to a subscription operation."
    },
    FIELD: {
      value: DirectiveLocation.FIELD,
      description: "Location adjacent to a field."
    },
    FRAGMENT_DEFINITION: {
      value: DirectiveLocation.FRAGMENT_DEFINITION,
      description: "Location adjacent to a fragment definition."
    },
    FRAGMENT_SPREAD: {
      value: DirectiveLocation.FRAGMENT_SPREAD,
      description: "Location adjacent to a fragment spread."
    },
    INLINE_FRAGMENT: {
      value: DirectiveLocation.INLINE_FRAGMENT,
      description: "Location adjacent to an inline fragment."
    },
    VARIABLE_DEFINITION: {
      value: DirectiveLocation.VARIABLE_DEFINITION,
      description: "Location adjacent to a variable definition."
    },
    SCHEMA: {
      value: DirectiveLocation.SCHEMA,
      description: "Location adjacent to a schema definition."
    },
    SCALAR: {
      value: DirectiveLocation.SCALAR,
      description: "Location adjacent to a scalar definition."
    },
    OBJECT: {
      value: DirectiveLocation.OBJECT,
      description: "Location adjacent to an object type definition."
    },
    FIELD_DEFINITION: {
      value: DirectiveLocation.FIELD_DEFINITION,
      description: "Location adjacent to a field definition."
    },
    ARGUMENT_DEFINITION: {
      value: DirectiveLocation.ARGUMENT_DEFINITION,
      description: "Location adjacent to an argument definition."
    },
    INTERFACE: {
      value: DirectiveLocation.INTERFACE,
      description: "Location adjacent to an interface definition."
    },
    UNION: {
      value: DirectiveLocation.UNION,
      description: "Location adjacent to a union definition."
    },
    ENUM: {
      value: DirectiveLocation.ENUM,
      description: "Location adjacent to an enum definition."
    },
    ENUM_VALUE: {
      value: DirectiveLocation.ENUM_VALUE,
      description: "Location adjacent to an enum value definition."
    },
    INPUT_OBJECT: {
      value: DirectiveLocation.INPUT_OBJECT,
      description: "Location adjacent to an input object type definition."
    },
    INPUT_FIELD_DEFINITION: {
      value: DirectiveLocation.INPUT_FIELD_DEFINITION,
      description: "Location adjacent to an input object field definition."
    }
  }
});
var __Type = new GraphQLObjectType({
  name: "__Type",
  description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
  fields: () => ({
    kind: {
      type: new GraphQLNonNull(__TypeKind),
      resolve(type) {
        if (isScalarType(type)) {
          return TypeKind.SCALAR;
        }
        if (isObjectType(type)) {
          return TypeKind.OBJECT;
        }
        if (isInterfaceType(type)) {
          return TypeKind.INTERFACE;
        }
        if (isUnionType(type)) {
          return TypeKind.UNION;
        }
        if (isEnumType(type)) {
          return TypeKind.ENUM;
        }
        if (isInputObjectType(type)) {
          return TypeKind.INPUT_OBJECT;
        }
        if (isListType(type)) {
          return TypeKind.LIST;
        }
        if (isNonNullType(type)) {
          return TypeKind.NON_NULL;
        }
        invariant(false, `Unexpected type: "${inspect(type)}".`);
      }
    },
    name: {
      type: GraphQLString,
      resolve: (type) => "name" in type ? type.name : void 0
    },
    description: {
      type: GraphQLString,
      resolve: (type) => (
        /* c8 ignore next */
        "description" in type ? type.description : void 0
      )
    },
    specifiedByURL: {
      type: GraphQLString,
      resolve: (obj) => "specifiedByURL" in obj ? obj.specifiedByURL : void 0
    },
    fields: {
      type: new GraphQLList(new GraphQLNonNull(__Field)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type, { includeDeprecated }) {
        if (isObjectType(type) || isInterfaceType(type)) {
          const fields = Object.values(type.getFields());
          return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);
        }
      }
    },
    interfaces: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type) {
        if (isObjectType(type) || isInterfaceType(type)) {
          return type.getInterfaces();
        }
      }
    },
    possibleTypes: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type, _args, _context, { schema }) {
        if (isAbstractType(type)) {
          return schema.getPossibleTypes(type);
        }
      }
    },
    enumValues: {
      type: new GraphQLList(new GraphQLNonNull(__EnumValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type, { includeDeprecated }) {
        if (isEnumType(type)) {
          const values = type.getValues();
          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
        }
      }
    },
    inputFields: {
      type: new GraphQLList(new GraphQLNonNull(__InputValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type, { includeDeprecated }) {
        if (isInputObjectType(type)) {
          const values = Object.values(type.getFields());
          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
        }
      }
    },
    ofType: {
      type: __Type,
      resolve: (type) => "ofType" in type ? type.ofType : void 0
    },
    isOneOf: {
      type: GraphQLBoolean,
      resolve: (type) => {
        if (isInputObjectType(type)) {
          return type.isOneOf;
        }
      }
    }
  })
});
var __Field = new GraphQLObjectType({
  name: "__Field",
  description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (field) => field.name
    },
    description: {
      type: GraphQLString,
      resolve: (field) => field.description
    },
    args: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__InputValue))
      ),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (field) => field.type
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (field) => field.deprecationReason
    }
  })
});
var __InputValue = new GraphQLObjectType({
  name: "__InputValue",
  description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (inputValue) => inputValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (inputValue) => inputValue.description
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (inputValue) => inputValue.type
    },
    defaultValue: {
      type: GraphQLString,
      description: "A GraphQL-formatted string representing the default value for this input value.",
      resolve(inputValue) {
        const { type, defaultValue } = inputValue;
        const valueAST = astFromValue(defaultValue, type);
        return valueAST ? print(valueAST) : null;
      }
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (obj) => obj.deprecationReason
    }
  })
});
var __EnumValue = new GraphQLObjectType({
  name: "__EnumValue",
  description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (enumValue) => enumValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.description
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (enumValue) => enumValue.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.deprecationReason
    }
  })
});
var TypeKind;
(function(TypeKind2) {
  TypeKind2["SCALAR"] = "SCALAR";
  TypeKind2["OBJECT"] = "OBJECT";
  TypeKind2["INTERFACE"] = "INTERFACE";
  TypeKind2["UNION"] = "UNION";
  TypeKind2["ENUM"] = "ENUM";
  TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
  TypeKind2["LIST"] = "LIST";
  TypeKind2["NON_NULL"] = "NON_NULL";
})(TypeKind || (TypeKind = {}));
var __TypeKind = new GraphQLEnumType({
  name: "__TypeKind",
  description: "An enum describing what kind of type a given `__Type` is.",
  values: {
    SCALAR: {
      value: TypeKind.SCALAR,
      description: "Indicates this type is a scalar."
    },
    OBJECT: {
      value: TypeKind.OBJECT,
      description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
    },
    INTERFACE: {
      value: TypeKind.INTERFACE,
      description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
    },
    UNION: {
      value: TypeKind.UNION,
      description: "Indicates this type is a union. `possibleTypes` is a valid field."
    },
    ENUM: {
      value: TypeKind.ENUM,
      description: "Indicates this type is an enum. `enumValues` is a valid field."
    },
    INPUT_OBJECT: {
      value: TypeKind.INPUT_OBJECT,
      description: "Indicates this type is an input object. `inputFields` is a valid field."
    },
    LIST: {
      value: TypeKind.LIST,
      description: "Indicates this type is a list. `ofType` is a valid field."
    },
    NON_NULL: {
      value: TypeKind.NON_NULL,
      description: "Indicates this type is a non-null. `ofType` is a valid field."
    }
  }
});
var SchemaMetaFieldDef = {
  name: "__schema",
  type: new GraphQLNonNull(__Schema),
  description: "Access the current type schema of this server.",
  args: [],
  resolve: (_source, _args, _context, { schema }) => schema,
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var TypeMetaFieldDef = {
  name: "__type",
  type: __Type,
  description: "Request the type information of a single type.",
  args: [
    {
      name: "name",
      description: void 0,
      type: new GraphQLNonNull(GraphQLString),
      defaultValue: void 0,
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    }
  ],
  resolve: (_source, { name }, _context, { schema }) => schema.getType(name),
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var TypeNameMetaFieldDef = {
  name: "__typename",
  type: new GraphQLNonNull(GraphQLString),
  description: "The name of the current Object type at runtime.",
  args: [],
  resolve: (_source, _args, _context, { parentType }) => parentType.name,
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var introspectionTypes = Object.freeze([
  __Schema,
  __Directive,
  __DirectiveLocation,
  __Type,
  __Field,
  __InputValue,
  __EnumValue,
  __TypeKind
]);

// node_modules/graphql/utilities/typeFromAST.mjs
function typeFromAST(schema, typeNode) {
  switch (typeNode.kind) {
    case Kind.LIST_TYPE: {
      const innerType = typeFromAST(schema, typeNode.type);
      return innerType && new GraphQLList(innerType);
    }
    case Kind.NON_NULL_TYPE: {
      const innerType = typeFromAST(schema, typeNode.type);
      return innerType && new GraphQLNonNull(innerType);
    }
    case Kind.NAMED_TYPE:
      return schema.getType(typeNode.name.value);
  }
}

// node_modules/graphql/language/predicates.mjs
function isExecutableDefinitionNode(node) {
  return node.kind === Kind.OPERATION_DEFINITION || node.kind === Kind.FRAGMENT_DEFINITION;
}
function isTypeSystemDefinitionNode(node) {
  return node.kind === Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === Kind.DIRECTIVE_DEFINITION;
}
function isTypeDefinitionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_DEFINITION || node.kind === Kind.OBJECT_TYPE_DEFINITION || node.kind === Kind.INTERFACE_TYPE_DEFINITION || node.kind === Kind.UNION_TYPE_DEFINITION || node.kind === Kind.ENUM_TYPE_DEFINITION || node.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION;
}
function isTypeSystemExtensionNode(node) {
  return node.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
}
function isTypeExtensionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_EXTENSION || node.kind === Kind.OBJECT_TYPE_EXTENSION || node.kind === Kind.INTERFACE_TYPE_EXTENSION || node.kind === Kind.UNION_TYPE_EXTENSION || node.kind === Kind.ENUM_TYPE_EXTENSION || node.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION;
}

// node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs
function ExecutableDefinitionsRule(context) {
  return {
    Document(node) {
      for (const definition of node.definitions) {
        if (!isExecutableDefinitionNode(definition)) {
          const defName = definition.kind === Kind.SCHEMA_DEFINITION || definition.kind === Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition.name.value + '"';
          context.reportError(
            new GraphQLError(`The ${defName} definition is not executable.`, {
              nodes: definition
            })
          );
        }
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs
function FieldsOnCorrectTypeRule(context) {
  return {
    Field(node) {
      const type = context.getParentType();
      if (type) {
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          const schema = context.getSchema();
          const fieldName = node.name.value;
          let suggestion = didYouMean(
            "to use an inline fragment on",
            getSuggestedTypeNames(schema, type, fieldName)
          );
          if (suggestion === "") {
            suggestion = didYouMean(getSuggestedFieldNames(type, fieldName));
          }
          context.reportError(
            new GraphQLError(
              `Cannot query field "${fieldName}" on type "${type.name}".` + suggestion,
              {
                nodes: node
              }
            )
          );
        }
      }
    }
  };
}
function getSuggestedTypeNames(schema, type, fieldName) {
  if (!isAbstractType(type)) {
    return [];
  }
  const suggestedTypes = /* @__PURE__ */ new Set();
  const usageCount = /* @__PURE__ */ Object.create(null);
  for (const possibleType of schema.getPossibleTypes(type)) {
    if (!possibleType.getFields()[fieldName]) {
      continue;
    }
    suggestedTypes.add(possibleType);
    usageCount[possibleType.name] = 1;
    for (const possibleInterface of possibleType.getInterfaces()) {
      var _usageCount$possibleI;
      if (!possibleInterface.getFields()[fieldName]) {
        continue;
      }
      suggestedTypes.add(possibleInterface);
      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
    }
  }
  return [...suggestedTypes].sort((typeA, typeB) => {
    const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
    if (usageCountDiff !== 0) {
      return usageCountDiff;
    }
    if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {
      return -1;
    }
    if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {
      return 1;
    }
    return naturalCompare(typeA.name, typeB.name);
  }).map((x11) => x11.name);
}
function getSuggestedFieldNames(type, fieldName) {
  if (isObjectType(type) || isInterfaceType(type)) {
    const possibleFieldNames = Object.keys(type.getFields());
    return suggestionList(fieldName, possibleFieldNames);
  }
  return [];
}

// node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs
function FragmentsOnCompositeTypesRule(context) {
  return {
    InlineFragment(node) {
      const typeCondition = node.typeCondition;
      if (typeCondition) {
        const type = typeFromAST(context.getSchema(), typeCondition);
        if (type && !isCompositeType(type)) {
          const typeStr = print(typeCondition);
          context.reportError(
            new GraphQLError(
              `Fragment cannot condition on non composite type "${typeStr}".`,
              {
                nodes: typeCondition
              }
            )
          );
        }
      }
    },
    FragmentDefinition(node) {
      const type = typeFromAST(context.getSchema(), node.typeCondition);
      if (type && !isCompositeType(type)) {
        const typeStr = print(node.typeCondition);
        context.reportError(
          new GraphQLError(
            `Fragment "${node.name.value}" cannot condition on non composite type "${typeStr}".`,
            {
              nodes: node.typeCondition
            }
          )
        );
      }
    }
  };
}

// node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs
function KnownArgumentNamesRule(context) {
  return {
    // eslint-disable-next-line new-cap
    ...KnownArgumentNamesOnDirectivesRule(context),
    Argument(argNode) {
      const argDef = context.getArgument();
      const fieldDef = context.getFieldDef();
      const parentType = context.getParentType();
      if (!argDef && fieldDef && parentType) {
        const argName = argNode.name.value;
        const knownArgsNames = fieldDef.args.map((arg) => arg.name);
        const suggestions = suggestionList(argName, knownArgsNames);
        context.reportError(
          new GraphQLError(
            `Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + didYouMean(suggestions),
            {
              nodes: argNode
            }
          )
        );
      }
    }
  };
}
function KnownArgumentNamesOnDirectivesRule(context) {
  const directiveArgs = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
    }
  }
  return {
    Directive(directiveNode) {
      const directiveName = directiveNode.name.value;
      const knownArgs = directiveArgs[directiveName];
      if (directiveNode.arguments && knownArgs) {
        for (const argNode of directiveNode.arguments) {
          const argName = argNode.name.value;
          if (!knownArgs.includes(argName)) {
            const suggestions = suggestionList(argName, knownArgs);
            context.reportError(
              new GraphQLError(
                `Unknown argument "${argName}" on directive "@${directiveName}".` + didYouMean(suggestions),
                {
                  nodes: argNode
                }
              )
            );
          }
        }
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/KnownDirectivesRule.mjs
function KnownDirectivesRule(context) {
  const locationsMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    locationsMap[directive.name] = directive.locations;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      locationsMap[def.name.value] = def.locations.map((name) => name.value);
    }
  }
  return {
    Directive(node, _key, _parent, _path, ancestors) {
      const name = node.name.value;
      const locations = locationsMap[name];
      if (!locations) {
        context.reportError(
          new GraphQLError(`Unknown directive "@${name}".`, {
            nodes: node
          })
        );
        return;
      }
      const candidateLocation = getDirectiveLocationForASTPath(ancestors);
      if (candidateLocation && !locations.includes(candidateLocation)) {
        context.reportError(
          new GraphQLError(
            `Directive "@${name}" may not be used on ${candidateLocation}.`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
function getDirectiveLocationForASTPath(ancestors) {
  const appliedTo = ancestors[ancestors.length - 1];
  "kind" in appliedTo || invariant(false);
  switch (appliedTo.kind) {
    case Kind.OPERATION_DEFINITION:
      return getDirectiveLocationForOperation(appliedTo.operation);
    case Kind.FIELD:
      return DirectiveLocation.FIELD;
    case Kind.FRAGMENT_SPREAD:
      return DirectiveLocation.FRAGMENT_SPREAD;
    case Kind.INLINE_FRAGMENT:
      return DirectiveLocation.INLINE_FRAGMENT;
    case Kind.FRAGMENT_DEFINITION:
      return DirectiveLocation.FRAGMENT_DEFINITION;
    case Kind.VARIABLE_DEFINITION:
      return DirectiveLocation.VARIABLE_DEFINITION;
    case Kind.SCHEMA_DEFINITION:
    case Kind.SCHEMA_EXTENSION:
      return DirectiveLocation.SCHEMA;
    case Kind.SCALAR_TYPE_DEFINITION:
    case Kind.SCALAR_TYPE_EXTENSION:
      return DirectiveLocation.SCALAR;
    case Kind.OBJECT_TYPE_DEFINITION:
    case Kind.OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.OBJECT;
    case Kind.FIELD_DEFINITION:
      return DirectiveLocation.FIELD_DEFINITION;
    case Kind.INTERFACE_TYPE_DEFINITION:
    case Kind.INTERFACE_TYPE_EXTENSION:
      return DirectiveLocation.INTERFACE;
    case Kind.UNION_TYPE_DEFINITION:
    case Kind.UNION_TYPE_EXTENSION:
      return DirectiveLocation.UNION;
    case Kind.ENUM_TYPE_DEFINITION:
    case Kind.ENUM_TYPE_EXTENSION:
      return DirectiveLocation.ENUM;
    case Kind.ENUM_VALUE_DEFINITION:
      return DirectiveLocation.ENUM_VALUE;
    case Kind.INPUT_OBJECT_TYPE_DEFINITION:
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.INPUT_OBJECT;
    case Kind.INPUT_VALUE_DEFINITION: {
      const parentNode = ancestors[ancestors.length - 3];
      "kind" in parentNode || invariant(false);
      return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION ? DirectiveLocation.INPUT_FIELD_DEFINITION : DirectiveLocation.ARGUMENT_DEFINITION;
    }
    default:
      invariant(false, "Unexpected kind: " + inspect(appliedTo.kind));
  }
}
function getDirectiveLocationForOperation(operation) {
  switch (operation) {
    case OperationTypeNode.QUERY:
      return DirectiveLocation.QUERY;
    case OperationTypeNode.MUTATION:
      return DirectiveLocation.MUTATION;
    case OperationTypeNode.SUBSCRIPTION:
      return DirectiveLocation.SUBSCRIPTION;
  }
}

// node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs
function KnownFragmentNamesRule(context) {
  return {
    FragmentSpread(node) {
      const fragmentName = node.name.value;
      const fragment = context.getFragment(fragmentName);
      if (!fragment) {
        context.reportError(
          new GraphQLError(`Unknown fragment "${fragmentName}".`, {
            nodes: node.name
          })
        );
      }
    }
  };
}

// node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs
function KnownTypeNamesRule(context) {
  const schema = context.getSchema();
  const existingTypesMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = true;
    }
  }
  const typeNames = [
    ...Object.keys(existingTypesMap),
    ...Object.keys(definedTypes)
  ];
  return {
    NamedType(node, _1, parent, _22, ancestors) {
      const typeName = node.name.value;
      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
        var _ancestors$;
        const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
        const isSDL = definitionNode != null && isSDLNode(definitionNode);
        if (isSDL && standardTypeNames.includes(typeName)) {
          return;
        }
        const suggestedTypes = suggestionList(
          typeName,
          isSDL ? standardTypeNames.concat(typeNames) : typeNames
        );
        context.reportError(
          new GraphQLError(
            `Unknown type "${typeName}".` + didYouMean(suggestedTypes),
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
var standardTypeNames = [...specifiedScalarTypes, ...introspectionTypes].map(
  (type) => type.name
);
function isSDLNode(value) {
  return "kind" in value && (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value));
}

// node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs
function LoneAnonymousOperationRule(context) {
  let operationCount = 0;
  return {
    Document(node) {
      operationCount = node.definitions.filter(
        (definition) => definition.kind === Kind.OPERATION_DEFINITION
      ).length;
    },
    OperationDefinition(node) {
      if (!node.name && operationCount > 1) {
        context.reportError(
          new GraphQLError(
            "This anonymous operation must be the only defined operation.",
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}

// node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs
function LoneSchemaDefinitionRule(context) {
  var _ref, _ref2, _oldSchema$astNode;
  const oldSchema = context.getSchema();
  const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
  let schemaDefinitionsCount = 0;
  return {
    SchemaDefinition(node) {
      if (alreadyDefined) {
        context.reportError(
          new GraphQLError(
            "Cannot define a new schema within a schema extension.",
            {
              nodes: node
            }
          )
        );
        return;
      }
      if (schemaDefinitionsCount > 0) {
        context.reportError(
          new GraphQLError("Must provide only one schema definition.", {
            nodes: node
          })
        );
      }
      ++schemaDefinitionsCount;
    }
  };
}

// node_modules/graphql/validation/rules/MaxIntrospectionDepthRule.mjs
var MAX_LISTS_DEPTH = 3;
function MaxIntrospectionDepthRule(context) {
  function checkDepth(node, visitedFragments = /* @__PURE__ */ Object.create(null), depth = 0) {
    if (node.kind === Kind.FRAGMENT_SPREAD) {
      const fragmentName = node.name.value;
      if (visitedFragments[fragmentName] === true) {
        return false;
      }
      const fragment = context.getFragment(fragmentName);
      if (!fragment) {
        return false;
      }
      try {
        visitedFragments[fragmentName] = true;
        return checkDepth(fragment, visitedFragments, depth);
      } finally {
        visitedFragments[fragmentName] = void 0;
      }
    }
    if (node.kind === Kind.FIELD && // check all introspection lists
    (node.name.value === "fields" || node.name.value === "interfaces" || node.name.value === "possibleTypes" || node.name.value === "inputFields")) {
      depth++;
      if (depth >= MAX_LISTS_DEPTH) {
        return true;
      }
    }
    if ("selectionSet" in node && node.selectionSet) {
      for (const child of node.selectionSet.selections) {
        if (checkDepth(child, visitedFragments, depth)) {
          return true;
        }
      }
    }
    return false;
  }
  return {
    Field(node) {
      if (node.name.value === "__schema" || node.name.value === "__type") {
        if (checkDepth(node)) {
          context.reportError(
            new GraphQLError("Maximum introspection depth exceeded", {
              nodes: [node]
            })
          );
          return false;
        }
      }
    }
  };
}

// node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs
function NoFragmentCyclesRule(context) {
  const visitedFrags = /* @__PURE__ */ Object.create(null);
  const spreadPath = [];
  const spreadPathIndexByName = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      detectCycleRecursive(node);
      return false;
    }
  };
  function detectCycleRecursive(fragment) {
    if (visitedFrags[fragment.name.value]) {
      return;
    }
    const fragmentName = fragment.name.value;
    visitedFrags[fragmentName] = true;
    const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
    if (spreadNodes.length === 0) {
      return;
    }
    spreadPathIndexByName[fragmentName] = spreadPath.length;
    for (const spreadNode of spreadNodes) {
      const spreadName = spreadNode.name.value;
      const cycleIndex = spreadPathIndexByName[spreadName];
      spreadPath.push(spreadNode);
      if (cycleIndex === void 0) {
        const spreadFragment = context.getFragment(spreadName);
        if (spreadFragment) {
          detectCycleRecursive(spreadFragment);
        }
      } else {
        const cyclePath = spreadPath.slice(cycleIndex);
        const viaPath = cyclePath.slice(0, -1).map((s14) => '"' + s14.name.value + '"').join(", ");
        context.reportError(
          new GraphQLError(
            `Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."),
            {
              nodes: cyclePath
            }
          )
        );
      }
      spreadPath.pop();
    }
    spreadPathIndexByName[fragmentName] = void 0;
  }
}

// node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs
function NoUndefinedVariablesRule(context) {
  let variableNameDefined = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        variableNameDefined = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          const varName = node.name.value;
          if (variableNameDefined[varName] !== true) {
            context.reportError(
              new GraphQLError(
                operation.name ? `Variable "$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "$${varName}" is not defined.`,
                {
                  nodes: [node, operation]
                }
              )
            );
          }
        }
      }
    },
    VariableDefinition(node) {
      variableNameDefined[node.variable.name.value] = true;
    }
  };
}

// node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs
function NoUnusedFragmentsRule(context) {
  const operationDefs = [];
  const fragmentDefs = [];
  return {
    OperationDefinition(node) {
      operationDefs.push(node);
      return false;
    },
    FragmentDefinition(node) {
      fragmentDefs.push(node);
      return false;
    },
    Document: {
      leave() {
        const fragmentNameUsed = /* @__PURE__ */ Object.create(null);
        for (const operation of operationDefs) {
          for (const fragment of context.getRecursivelyReferencedFragments(
            operation
          )) {
            fragmentNameUsed[fragment.name.value] = true;
          }
        }
        for (const fragmentDef of fragmentDefs) {
          const fragName = fragmentDef.name.value;
          if (fragmentNameUsed[fragName] !== true) {
            context.reportError(
              new GraphQLError(`Fragment "${fragName}" is never used.`, {
                nodes: fragmentDef
              })
            );
          }
        }
      }
    }
  };
}

// node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs
function NoUnusedVariablesRule(context) {
  let variableDefs = [];
  return {
    OperationDefinition: {
      enter() {
        variableDefs = [];
      },
      leave(operation) {
        const variableNameUsed = /* @__PURE__ */ Object.create(null);
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          variableNameUsed[node.name.value] = true;
        }
        for (const variableDef of variableDefs) {
          const variableName = variableDef.variable.name.value;
          if (variableNameUsed[variableName] !== true) {
            context.reportError(
              new GraphQLError(
                operation.name ? `Variable "$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "$${variableName}" is never used.`,
                {
                  nodes: variableDef
                }
              )
            );
          }
        }
      }
    },
    VariableDefinition(def) {
      variableDefs.push(def);
    }
  };
}

// node_modules/graphql/utilities/sortValueNode.mjs
function sortValueNode(valueNode) {
  switch (valueNode.kind) {
    case Kind.OBJECT:
      return { ...valueNode, fields: sortFields(valueNode.fields) };
    case Kind.LIST:
      return { ...valueNode, values: valueNode.values.map(sortValueNode) };
    case Kind.INT:
    case Kind.FLOAT:
    case Kind.STRING:
    case Kind.BOOLEAN:
    case Kind.NULL:
    case Kind.ENUM:
    case Kind.VARIABLE:
      return valueNode;
  }
}
function sortFields(fields) {
  return fields.map((fieldNode) => ({
    ...fieldNode,
    value: sortValueNode(fieldNode.value)
  })).sort(
    (fieldA, fieldB) => naturalCompare(fieldA.name.value, fieldB.name.value)
  );
}

// node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs
function reasonMessage(reason) {
  if (Array.isArray(reason)) {
    return reason.map(
      ([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage(subReason)
    ).join(" and ");
  }
  return reason;
}
function OverlappingFieldsCanBeMergedRule(context) {
  const comparedFragmentPairs = new PairSet();
  const cachedFieldsAndFragmentNames = /* @__PURE__ */ new Map();
  return {
    SelectionSet(selectionSet) {
      const conflicts = findConflictsWithinSelectionSet(
        context,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        context.getParentType(),
        selectionSet
      );
      for (const [[responseName, reason], fields1, fields2] of conflicts) {
        const reasonMsg = reasonMessage(reason);
        context.reportError(
          new GraphQLError(
            `Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,
            {
              nodes: fields1.concat(fields2)
            }
          )
        );
      }
    }
  };
}
function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {
  const conflicts = [];
  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType,
    selectionSet
  );
  collectConflictsWithin(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    fieldMap
  );
  if (fragmentNames.length !== 0) {
    for (let i49 = 0; i49 < fragmentNames.length; i49++) {
      collectConflictsBetweenFieldsAndFragment(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        false,
        fieldMap,
        fragmentNames[i49]
      );
      for (let j7 = i49 + 1; j7 < fragmentNames.length; j7++) {
        collectConflictsBetweenFragments(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFragmentPairs,
          false,
          fragmentNames[i49],
          fragmentNames[j7]
        );
      }
    }
  }
  return conflicts;
}
function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
  const fragment = context.getFragment(fragmentName);
  if (!fragment) {
    return;
  }
  const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment
  );
  if (fieldMap === fieldMap2) {
    return;
  }
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap,
    fieldMap2
  );
  for (const referencedFragmentName of referencedFragmentNames) {
    if (comparedFragmentPairs.has(
      referencedFragmentName,
      fragmentName,
      areMutuallyExclusive
    )) {
      continue;
    }
    comparedFragmentPairs.add(
      referencedFragmentName,
      fragmentName,
      areMutuallyExclusive
    );
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap,
      referencedFragmentName
    );
  }
}
function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
  if (fragmentName1 === fragmentName2) {
    return;
  }
  if (comparedFragmentPairs.has(
    fragmentName1,
    fragmentName2,
    areMutuallyExclusive
  )) {
    return;
  }
  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
  const fragment1 = context.getFragment(fragmentName1);
  const fragment2 = context.getFragment(fragmentName2);
  if (!fragment1 || !fragment2) {
    return;
  }
  const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment1
  );
  const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment2
  );
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2
  );
  for (const referencedFragmentName2 of referencedFragmentNames2) {
    collectConflictsBetweenFragments(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fragmentName1,
      referencedFragmentName2
    );
  }
  for (const referencedFragmentName1 of referencedFragmentNames1) {
    collectConflictsBetweenFragments(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      referencedFragmentName1,
      fragmentName2
    );
  }
}
function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
  const conflicts = [];
  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType1,
    selectionSet1
  );
  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType2,
    selectionSet2
  );
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2
  );
  for (const fragmentName2 of fragmentNames2) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap1,
      fragmentName2
    );
  }
  for (const fragmentName1 of fragmentNames1) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap2,
      fragmentName1
    );
  }
  for (const fragmentName1 of fragmentNames1) {
    for (const fragmentName2 of fragmentNames2) {
      collectConflictsBetweenFragments(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fragmentName1,
        fragmentName2
      );
    }
  }
  return conflicts;
}
function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {
  for (const [responseName, fields] of Object.entries(fieldMap)) {
    if (fields.length > 1) {
      for (let i49 = 0; i49 < fields.length; i49++) {
        for (let j7 = i49 + 1; j7 < fields.length; j7++) {
          const conflict = findConflict(
            context,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            false,
            // within one collection is never mutually exclusive
            responseName,
            fields[i49],
            fields[j7]
          );
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
  for (const [responseName, fields1] of Object.entries(fieldMap1)) {
    const fields2 = fieldMap2[responseName];
    if (fields2) {
      for (const field1 of fields1) {
        for (const field2 of fields2) {
          const conflict = findConflict(
            context,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            parentFieldsAreMutuallyExclusive,
            responseName,
            field1,
            field2
          );
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
  const [parentType1, node1, def1] = field1;
  const [parentType2, node2, def2] = field2;
  const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);
  if (!areMutuallyExclusive) {
    const name1 = node1.name.value;
    const name2 = node2.name.value;
    if (name1 !== name2) {
      return [
        [responseName, `"${name1}" and "${name2}" are different fields`],
        [node1],
        [node2]
      ];
    }
    if (!sameArguments(node1, node2)) {
      return [
        [responseName, "they have differing arguments"],
        [node1],
        [node2]
      ];
    }
  }
  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
  const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
  if (type1 && type2 && doTypesConflict(type1, type2)) {
    return [
      [
        responseName,
        `they return conflicting types "${inspect(type1)}" and "${inspect(
          type2
        )}"`
      ],
      [node1],
      [node2]
    ];
  }
  const selectionSet1 = node1.selectionSet;
  const selectionSet2 = node2.selectionSet;
  if (selectionSet1 && selectionSet2) {
    const conflicts = findConflictsBetweenSubSelectionSets(
      context,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      getNamedType(type1),
      selectionSet1,
      getNamedType(type2),
      selectionSet2
    );
    return subfieldConflicts(conflicts, responseName, node1, node2);
  }
}
function sameArguments(node1, node2) {
  const args1 = node1.arguments;
  const args2 = node2.arguments;
  if (args1 === void 0 || args1.length === 0) {
    return args2 === void 0 || args2.length === 0;
  }
  if (args2 === void 0 || args2.length === 0) {
    return false;
  }
  if (args1.length !== args2.length) {
    return false;
  }
  const values2 = new Map(args2.map(({ name, value }) => [name.value, value]));
  return args1.every((arg1) => {
    const value1 = arg1.value;
    const value2 = values2.get(arg1.name.value);
    if (value2 === void 0) {
      return false;
    }
    return stringifyValue(value1) === stringifyValue(value2);
  });
}
function stringifyValue(value) {
  return print(sortValueNode(value));
}
function doTypesConflict(type1, type2) {
  if (isListType(type1)) {
    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isListType(type2)) {
    return true;
  }
  if (isNonNullType(type1)) {
    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isNonNullType(type2)) {
    return true;
  }
  if (isLeafType(type1) || isLeafType(type2)) {
    return type1 !== type2;
  }
  return false;
}
function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
  const cached = cachedFieldsAndFragmentNames.get(selectionSet);
  if (cached) {
    return cached;
  }
  const nodeAndDefs = /* @__PURE__ */ Object.create(null);
  const fragmentNames = /* @__PURE__ */ Object.create(null);
  _collectFieldsAndFragmentNames(
    context,
    parentType,
    selectionSet,
    nodeAndDefs,
    fragmentNames
  );
  const result = [nodeAndDefs, Object.keys(fragmentNames)];
  cachedFieldsAndFragmentNames.set(selectionSet, result);
  return result;
}
function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
  if (cached) {
    return cached;
  }
  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);
  return getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragmentType,
    fragment.selectionSet
  );
}
function _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        const fieldName = selection.name.value;
        let fieldDef;
        if (isObjectType(parentType) || isInterfaceType(parentType)) {
          fieldDef = parentType.getFields()[fieldName];
        }
        const responseName = selection.alias ? selection.alias.value : fieldName;
        if (!nodeAndDefs[responseName]) {
          nodeAndDefs[responseName] = [];
        }
        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
        break;
      }
      case Kind.FRAGMENT_SPREAD:
        fragmentNames[selection.name.value] = true;
        break;
      case Kind.INLINE_FRAGMENT: {
        const typeCondition = selection.typeCondition;
        const inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;
        _collectFieldsAndFragmentNames(
          context,
          inlineFragmentType,
          selection.selectionSet,
          nodeAndDefs,
          fragmentNames
        );
        break;
      }
    }
  }
}
function subfieldConflicts(conflicts, responseName, node1, node2) {
  if (conflicts.length > 0) {
    return [
      [responseName, conflicts.map(([reason]) => reason)],
      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]
    ];
  }
}
var PairSet = class {
  constructor() {
    this._data = /* @__PURE__ */ new Map();
  }
  has(a26, b12, areMutuallyExclusive) {
    var _this$_data$get;
    const [key1, key2] = a26 < b12 ? [a26, b12] : [b12, a26];
    const result = (_this$_data$get = this._data.get(key1)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(key2);
    if (result === void 0) {
      return false;
    }
    return areMutuallyExclusive ? true : areMutuallyExclusive === result;
  }
  add(a26, b12, areMutuallyExclusive) {
    const [key1, key2] = a26 < b12 ? [a26, b12] : [b12, a26];
    const map = this._data.get(key1);
    if (map === void 0) {
      this._data.set(key1, /* @__PURE__ */ new Map([[key2, areMutuallyExclusive]]));
    } else {
      map.set(key2, areMutuallyExclusive);
    }
  }
};

// node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs
function PossibleFragmentSpreadsRule(context) {
  return {
    InlineFragment(node) {
      const fragType = context.getType();
      const parentType = context.getParentType();
      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(
          new GraphQLError(
            `Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node
            }
          )
        );
      }
    },
    FragmentSpread(node) {
      const fragName = node.name.value;
      const fragType = getFragmentType(context, fragName);
      const parentType = context.getParentType();
      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(
          new GraphQLError(
            `Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
function getFragmentType(context, name) {
  const frag = context.getFragment(name);
  if (frag) {
    const type = typeFromAST(context.getSchema(), frag.typeCondition);
    if (isCompositeType(type)) {
      return type;
    }
  }
}

// node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs
function PossibleTypeExtensionsRule(context) {
  const schema = context.getSchema();
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = def;
    }
  }
  return {
    ScalarTypeExtension: checkExtension,
    ObjectTypeExtension: checkExtension,
    InterfaceTypeExtension: checkExtension,
    UnionTypeExtension: checkExtension,
    EnumTypeExtension: checkExtension,
    InputObjectTypeExtension: checkExtension
  };
  function checkExtension(node) {
    const typeName = node.name.value;
    const defNode = definedTypes[typeName];
    const existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);
    let expectedKind;
    if (defNode) {
      expectedKind = defKindToExtKind[defNode.kind];
    } else if (existingType) {
      expectedKind = typeToExtKind(existingType);
    }
    if (expectedKind) {
      if (expectedKind !== node.kind) {
        const kindStr = extensionKindToTypeName(node.kind);
        context.reportError(
          new GraphQLError(`Cannot extend non-${kindStr} type "${typeName}".`, {
            nodes: defNode ? [defNode, node] : node
          })
        );
      }
    } else {
      const allTypeNames = Object.keys({
        ...definedTypes,
        ...schema === null || schema === void 0 ? void 0 : schema.getTypeMap()
      });
      const suggestedTypes = suggestionList(typeName, allTypeNames);
      context.reportError(
        new GraphQLError(
          `Cannot extend type "${typeName}" because it is not defined.` + didYouMean(suggestedTypes),
          {
            nodes: node.name
          }
        )
      );
    }
  }
}
var defKindToExtKind = {
  [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,
  [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,
  [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,
  [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,
  [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,
  [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION
};
function typeToExtKind(type) {
  if (isScalarType(type)) {
    return Kind.SCALAR_TYPE_EXTENSION;
  }
  if (isObjectType(type)) {
    return Kind.OBJECT_TYPE_EXTENSION;
  }
  if (isInterfaceType(type)) {
    return Kind.INTERFACE_TYPE_EXTENSION;
  }
  if (isUnionType(type)) {
    return Kind.UNION_TYPE_EXTENSION;
  }
  if (isEnumType(type)) {
    return Kind.ENUM_TYPE_EXTENSION;
  }
  if (isInputObjectType(type)) {
    return Kind.INPUT_OBJECT_TYPE_EXTENSION;
  }
  invariant(false, "Unexpected type: " + inspect(type));
}
function extensionKindToTypeName(kind) {
  switch (kind) {
    case Kind.SCALAR_TYPE_EXTENSION:
      return "scalar";
    case Kind.OBJECT_TYPE_EXTENSION:
      return "object";
    case Kind.INTERFACE_TYPE_EXTENSION:
      return "interface";
    case Kind.UNION_TYPE_EXTENSION:
      return "union";
    case Kind.ENUM_TYPE_EXTENSION:
      return "enum";
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return "input object";
    default:
      invariant(false, "Unexpected kind: " + inspect(kind));
  }
}

// node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs
function ProvidedRequiredArgumentsRule(context) {
  return {
    // eslint-disable-next-line new-cap
    ...ProvidedRequiredArgumentsOnDirectivesRule(context),
    Field: {
      // Validate on leave to allow for deeper errors to appear first.
      leave(fieldNode) {
        var _fieldNode$arguments;
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          return false;
        }
        const providedArgs = new Set(
          // FIXME: https://github.com/graphql/graphql-js/issues/2203
          /* c8 ignore next */
          (_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === void 0 ? void 0 : _fieldNode$arguments.map((arg) => arg.name.value)
        );
        for (const argDef of fieldDef.args) {
          if (!providedArgs.has(argDef.name) && isRequiredArgument(argDef)) {
            const argTypeStr = inspect(argDef.type);
            context.reportError(
              new GraphQLError(
                `Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`,
                {
                  nodes: fieldNode
                }
              )
            );
          }
        }
      }
    }
  };
}
function ProvidedRequiredArgumentsOnDirectivesRule(context) {
  var _schema$getDirectives;
  const requiredArgsMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = (_schema$getDirectives = schema === null || schema === void 0 ? void 0 : schema.getDirectives()) !== null && _schema$getDirectives !== void 0 ? _schema$getDirectives : specifiedDirectives;
  for (const directive of definedDirectives) {
    requiredArgsMap[directive.name] = keyMap(
      directive.args.filter(isRequiredArgument),
      (arg) => arg.name
    );
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      requiredArgsMap[def.name.value] = keyMap(
        argNodes.filter(isRequiredArgumentNode),
        (arg) => arg.name.value
      );
    }
  }
  return {
    Directive: {
      // Validate on leave to allow for deeper errors to appear first.
      leave(directiveNode) {
        const directiveName = directiveNode.name.value;
        const requiredArgs = requiredArgsMap[directiveName];
        if (requiredArgs) {
          var _directiveNode$argume;
          const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
          const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
          for (const [argName, argDef] of Object.entries(requiredArgs)) {
            if (!argNodeMap.has(argName)) {
              const argType = isType(argDef.type) ? inspect(argDef.type) : print(argDef.type);
              context.reportError(
                new GraphQLError(
                  `Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`,
                  {
                    nodes: directiveNode
                  }
                )
              );
            }
          }
        }
      }
    }
  };
}
function isRequiredArgumentNode(arg) {
  return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;
}

// node_modules/graphql/validation/rules/ScalarLeafsRule.mjs
function ScalarLeafsRule(context) {
  return {
    Field(node) {
      const type = context.getType();
      const selectionSet = node.selectionSet;
      if (type) {
        if (isLeafType(getNamedType(type))) {
          if (selectionSet) {
            const fieldName = node.name.value;
            const typeStr = inspect(type);
            context.reportError(
              new GraphQLError(
                `Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`,
                {
                  nodes: selectionSet
                }
              )
            );
          }
        } else if (!selectionSet) {
          const fieldName = node.name.value;
          const typeStr = inspect(type);
          context.reportError(
            new GraphQLError(
              `Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`,
              {
                nodes: node
              }
            )
          );
        }
      }
    }
  };
}

// node_modules/graphql/utilities/valueFromAST.mjs
function valueFromAST(valueNode, type, variables) {
  if (!valueNode) {
    return;
  }
  if (valueNode.kind === Kind.VARIABLE) {
    const variableName = valueNode.name.value;
    if (variables == null || variables[variableName] === void 0) {
      return;
    }
    const variableValue = variables[variableName];
    if (variableValue === null && isNonNullType(type)) {
      return;
    }
    return variableValue;
  }
  if (isNonNullType(type)) {
    if (valueNode.kind === Kind.NULL) {
      return;
    }
    return valueFromAST(valueNode, type.ofType, variables);
  }
  if (valueNode.kind === Kind.NULL) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (valueNode.kind === Kind.LIST) {
      const coercedValues = [];
      for (const itemNode of valueNode.values) {
        if (isMissingVariable(itemNode, variables)) {
          if (isNonNullType(itemType)) {
            return;
          }
          coercedValues.push(null);
        } else {
          const itemValue = valueFromAST(itemNode, itemType, variables);
          if (itemValue === void 0) {
            return;
          }
          coercedValues.push(itemValue);
        }
      }
      return coercedValues;
    }
    const coercedValue = valueFromAST(valueNode, itemType, variables);
    if (coercedValue === void 0) {
      return;
    }
    return [coercedValue];
  }
  if (isInputObjectType(type)) {
    if (valueNode.kind !== Kind.OBJECT) {
      return;
    }
    const coercedObj = /* @__PURE__ */ Object.create(null);
    const fieldNodes = keyMap(valueNode.fields, (field) => field.name.value);
    for (const field of Object.values(type.getFields())) {
      const fieldNode = fieldNodes[field.name];
      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
        if (field.defaultValue !== void 0) {
          coercedObj[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          return;
        }
        continue;
      }
      const fieldValue = valueFromAST(fieldNode.value, field.type, variables);
      if (fieldValue === void 0) {
        return;
      }
      coercedObj[field.name] = fieldValue;
    }
    if (type.isOneOf) {
      const keys = Object.keys(coercedObj);
      if (keys.length !== 1) {
        return;
      }
      if (coercedObj[keys[0]] === null) {
        return;
      }
    }
    return coercedObj;
  }
  if (isLeafType(type)) {
    let result;
    try {
      result = type.parseLiteral(valueNode, variables);
    } catch (_error) {
      return;
    }
    if (result === void 0) {
      return;
    }
    return result;
  }
  invariant(false, "Unexpected input type: " + inspect(type));
}
function isMissingVariable(valueNode, variables) {
  return valueNode.kind === Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0);
}

// node_modules/graphql/execution/values.mjs
function getArgumentValues(def, node, variableValues) {
  var _node$arguments;
  const coercedValues = {};
  const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
  const argNodeMap = keyMap(argumentNodes, (arg) => arg.name.value);
  for (const argDef of def.args) {
    const name = argDef.name;
    const argType = argDef.type;
    const argumentNode = argNodeMap[name];
    if (!argumentNode) {
      if (argDef.defaultValue !== void 0) {
        coercedValues[name] = argDef.defaultValue;
      } else if (isNonNullType(argType)) {
        throw new GraphQLError(
          `Argument "${name}" of required type "${inspect(argType)}" was not provided.`,
          {
            nodes: node
          }
        );
      }
      continue;
    }
    const valueNode = argumentNode.value;
    let isNull = valueNode.kind === Kind.NULL;
    if (valueNode.kind === Kind.VARIABLE) {
      const variableName = valueNode.name.value;
      if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
        if (argDef.defaultValue !== void 0) {
          coercedValues[name] = argDef.defaultValue;
        } else if (isNonNullType(argType)) {
          throw new GraphQLError(
            `Argument "${name}" of required type "${inspect(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`,
            {
              nodes: valueNode
            }
          );
        }
        continue;
      }
      isNull = variableValues[variableName] == null;
    }
    if (isNull && isNonNullType(argType)) {
      throw new GraphQLError(
        `Argument "${name}" of non-null type "${inspect(argType)}" must not be null.`,
        {
          nodes: valueNode
        }
      );
    }
    const coercedValue = valueFromAST(valueNode, argType, variableValues);
    if (coercedValue === void 0) {
      throw new GraphQLError(
        `Argument "${name}" has invalid value ${print(valueNode)}.`,
        {
          nodes: valueNode
        }
      );
    }
    coercedValues[name] = coercedValue;
  }
  return coercedValues;
}
function getDirectiveValues(directiveDef, node, variableValues) {
  var _node$directives;
  const directiveNode = (_node$directives = node.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find(
    (directive) => directive.name.value === directiveDef.name
  );
  if (directiveNode) {
    return getArgumentValues(directiveDef, directiveNode, variableValues);
  }
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

// node_modules/graphql/execution/collectFields.mjs
function collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {
  const fields = /* @__PURE__ */ new Map();
  collectFieldsImpl(
    schema,
    fragments,
    variableValues,
    runtimeType,
    selectionSet,
    fields,
    /* @__PURE__ */ new Set()
  );
  return fields;
}
function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {
  const subFieldNodes = /* @__PURE__ */ new Map();
  const visitedFragmentNames = /* @__PURE__ */ new Set();
  for (const node of fieldNodes) {
    if (node.selectionSet) {
      collectFieldsImpl(
        schema,
        fragments,
        variableValues,
        returnType,
        node.selectionSet,
        subFieldNodes,
        visitedFragmentNames
      );
    }
  }
  return subFieldNodes;
}
function collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        if (!shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        const name = getFieldEntryKey(selection);
        const fieldList = fields.get(name);
        if (fieldList !== void 0) {
          fieldList.push(selection);
        } else {
          fields.set(name, [selection]);
        }
        break;
      }
      case Kind.INLINE_FRAGMENT: {
        if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
          continue;
        }
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          selection.selectionSet,
          fields,
          visitedFragmentNames
        );
        break;
      }
      case Kind.FRAGMENT_SPREAD: {
        const fragName = selection.name.value;
        if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        visitedFragmentNames.add(fragName);
        const fragment = fragments[fragName];
        if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
          continue;
        }
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          fragment.selectionSet,
          fields,
          visitedFragmentNames
        );
        break;
      }
    }
  }
}
function shouldIncludeNode(variableValues, node) {
  const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);
  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
    return false;
  }
  const include = getDirectiveValues(
    GraphQLIncludeDirective,
    node,
    variableValues
  );
  if ((include === null || include === void 0 ? void 0 : include.if) === false) {
    return false;
  }
  return true;
}
function doesFragmentConditionMatch(schema, fragment, type) {
  const typeConditionNode = fragment.typeCondition;
  if (!typeConditionNode) {
    return true;
  }
  const conditionalType = typeFromAST(schema, typeConditionNode);
  if (conditionalType === type) {
    return true;
  }
  if (isAbstractType(conditionalType)) {
    return schema.isSubType(conditionalType, type);
  }
  return false;
}
function getFieldEntryKey(node) {
  return node.alias ? node.alias.value : node.name.value;
}

// node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs
function SingleFieldSubscriptionsRule(context) {
  return {
    OperationDefinition(node) {
      if (node.operation === "subscription") {
        const schema = context.getSchema();
        const subscriptionType = schema.getSubscriptionType();
        if (subscriptionType) {
          const operationName = node.name ? node.name.value : null;
          const variableValues = /* @__PURE__ */ Object.create(null);
          const document2 = context.getDocument();
          const fragments = /* @__PURE__ */ Object.create(null);
          for (const definition of document2.definitions) {
            if (definition.kind === Kind.FRAGMENT_DEFINITION) {
              fragments[definition.name.value] = definition;
            }
          }
          const fields = collectFields(
            schema,
            fragments,
            variableValues,
            subscriptionType,
            node.selectionSet
          );
          if (fields.size > 1) {
            const fieldSelectionLists = [...fields.values()];
            const extraFieldSelectionLists = fieldSelectionLists.slice(1);
            const extraFieldSelections = extraFieldSelectionLists.flat();
            context.reportError(
              new GraphQLError(
                operationName != null ? `Subscription "${operationName}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.",
                {
                  nodes: extraFieldSelections
                }
              )
            );
          }
          for (const fieldNodes of fields.values()) {
            const field = fieldNodes[0];
            const fieldName = field.name.value;
            if (fieldName.startsWith("__")) {
              context.reportError(
                new GraphQLError(
                  operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.",
                  {
                    nodes: fieldNodes
                  }
                )
              );
            }
          }
        }
      }
    }
  };
}

// node_modules/graphql/jsutils/groupBy.mjs
function groupBy(list, keyFn) {
  const result = /* @__PURE__ */ new Map();
  for (const item of list) {
    const key = keyFn(item);
    const group = result.get(key);
    if (group === void 0) {
      result.set(key, [item]);
    } else {
      group.push(item);
    }
  }
  return result;
}

// node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.mjs
function UniqueArgumentDefinitionNamesRule(context) {
  return {
    DirectiveDefinition(directiveNode) {
      var _directiveNode$argume;
      const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
      return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
    },
    InterfaceTypeDefinition: checkArgUniquenessPerField,
    InterfaceTypeExtension: checkArgUniquenessPerField,
    ObjectTypeDefinition: checkArgUniquenessPerField,
    ObjectTypeExtension: checkArgUniquenessPerField
  };
  function checkArgUniquenessPerField(typeNode) {
    var _typeNode$fields;
    const typeName = typeNode.name.value;
    const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== void 0 ? _typeNode$fields : [];
    for (const fieldDef of fieldNodes) {
      var _fieldDef$arguments;
      const fieldName = fieldDef.name.value;
      const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== void 0 ? _fieldDef$arguments : [];
      checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
    }
    return false;
  }
  function checkArgUniqueness(parentName, argumentNodes) {
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(
          new GraphQLError(
            `Argument "${parentName}(${argName}:)" can only be defined once.`,
            {
              nodes: argNodes.map((node) => node.name)
            }
          )
        );
      }
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs
function UniqueArgumentNamesRule(context) {
  return {
    Field: checkArgUniqueness,
    Directive: checkArgUniqueness
  };
  function checkArgUniqueness(parentNode) {
    var _parentNode$arguments;
    const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== void 0 ? _parentNode$arguments : [];
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(
          new GraphQLError(
            `There can be only one argument named "${argName}".`,
            {
              nodes: argNodes.map((node) => node.name)
            }
          )
        );
      }
    }
  }
}

// node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs
function UniqueDirectiveNamesRule(context) {
  const knownDirectiveNames = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  return {
    DirectiveDefinition(node) {
      const directiveName = node.name.value;
      if (schema !== null && schema !== void 0 && schema.getDirective(directiveName)) {
        context.reportError(
          new GraphQLError(
            `Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`,
            {
              nodes: node.name
            }
          )
        );
        return;
      }
      if (knownDirectiveNames[directiveName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one directive named "@${directiveName}".`,
            {
              nodes: [knownDirectiveNames[directiveName], node.name]
            }
          )
        );
      } else {
        knownDirectiveNames[directiveName] = node.name;
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs
function UniqueDirectivesPerLocationRule(context) {
  const uniqueDirectiveMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      uniqueDirectiveMap[def.name.value] = !def.repeatable;
    }
  }
  const schemaDirectives = /* @__PURE__ */ Object.create(null);
  const typeDirectivesMap = /* @__PURE__ */ Object.create(null);
  return {
    // Many different AST nodes may contain directives. Rather than listing
    // them all, just listen for entering any node, and check to see if it
    // defines any directives.
    enter(node) {
      if (!("directives" in node) || !node.directives) {
        return;
      }
      let seenDirectives;
      if (node.kind === Kind.SCHEMA_DEFINITION || node.kind === Kind.SCHEMA_EXTENSION) {
        seenDirectives = schemaDirectives;
      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {
        const typeName = node.name.value;
        seenDirectives = typeDirectivesMap[typeName];
        if (seenDirectives === void 0) {
          typeDirectivesMap[typeName] = seenDirectives = /* @__PURE__ */ Object.create(null);
        }
      } else {
        seenDirectives = /* @__PURE__ */ Object.create(null);
      }
      for (const directive of node.directives) {
        const directiveName = directive.name.value;
        if (uniqueDirectiveMap[directiveName]) {
          if (seenDirectives[directiveName]) {
            context.reportError(
              new GraphQLError(
                `The directive "@${directiveName}" can only be used once at this location.`,
                {
                  nodes: [seenDirectives[directiveName], directive]
                }
              )
            );
          } else {
            seenDirectives[directiveName] = directive;
          }
        }
      }
    }
  };
}

// node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs
function UniqueEnumValueNamesRule(context) {
  const schema = context.getSchema();
  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownValueNames = /* @__PURE__ */ Object.create(null);
  return {
    EnumTypeDefinition: checkValueUniqueness,
    EnumTypeExtension: checkValueUniqueness
  };
  function checkValueUniqueness(node) {
    var _node$values;
    const typeName = node.name.value;
    if (!knownValueNames[typeName]) {
      knownValueNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
    const valueNames = knownValueNames[typeName];
    for (const valueDef of valueNodes) {
      const valueName = valueDef.name.value;
      const existingType = existingTypeMap[typeName];
      if (isEnumType(existingType) && existingType.getValue(valueName)) {
        context.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: valueDef.name
            }
          )
        );
      } else if (valueNames[valueName]) {
        context.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" can only be defined once.`,
            {
              nodes: [valueNames[valueName], valueDef.name]
            }
          )
        );
      } else {
        valueNames[valueName] = valueDef.name;
      }
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs
function UniqueFieldDefinitionNamesRule(context) {
  const schema = context.getSchema();
  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownFieldNames = /* @__PURE__ */ Object.create(null);
  return {
    InputObjectTypeDefinition: checkFieldUniqueness,
    InputObjectTypeExtension: checkFieldUniqueness,
    InterfaceTypeDefinition: checkFieldUniqueness,
    InterfaceTypeExtension: checkFieldUniqueness,
    ObjectTypeDefinition: checkFieldUniqueness,
    ObjectTypeExtension: checkFieldUniqueness
  };
  function checkFieldUniqueness(node) {
    var _node$fields;
    const typeName = node.name.value;
    if (!knownFieldNames[typeName]) {
      knownFieldNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
    const fieldNames = knownFieldNames[typeName];
    for (const fieldDef of fieldNodes) {
      const fieldName = fieldDef.name.value;
      if (hasField(existingTypeMap[typeName], fieldName)) {
        context.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: fieldDef.name
            }
          )
        );
      } else if (fieldNames[fieldName]) {
        context.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" can only be defined once.`,
            {
              nodes: [fieldNames[fieldName], fieldDef.name]
            }
          )
        );
      } else {
        fieldNames[fieldName] = fieldDef.name;
      }
    }
    return false;
  }
}
function hasField(type, fieldName) {
  if (isObjectType(type) || isInterfaceType(type) || isInputObjectType(type)) {
    return type.getFields()[fieldName] != null;
  }
  return false;
}

// node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs
function UniqueFragmentNamesRule(context) {
  const knownFragmentNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      const fragmentName = node.name.value;
      if (knownFragmentNames[fragmentName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one fragment named "${fragmentName}".`,
            {
              nodes: [knownFragmentNames[fragmentName], node.name]
            }
          )
        );
      } else {
        knownFragmentNames[fragmentName] = node.name;
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs
function UniqueInputFieldNamesRule(context) {
  const knownNameStack = [];
  let knownNames = /* @__PURE__ */ Object.create(null);
  return {
    ObjectValue: {
      enter() {
        knownNameStack.push(knownNames);
        knownNames = /* @__PURE__ */ Object.create(null);
      },
      leave() {
        const prevKnownNames = knownNameStack.pop();
        prevKnownNames || invariant(false);
        knownNames = prevKnownNames;
      }
    },
    ObjectField(node) {
      const fieldName = node.name.value;
      if (knownNames[fieldName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one input field named "${fieldName}".`,
            {
              nodes: [knownNames[fieldName], node.name]
            }
          )
        );
      } else {
        knownNames[fieldName] = node.name;
      }
    }
  };
}

// node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs
function UniqueOperationNamesRule(context) {
  const knownOperationNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition(node) {
      const operationName = node.name;
      if (operationName) {
        if (knownOperationNames[operationName.value]) {
          context.reportError(
            new GraphQLError(
              `There can be only one operation named "${operationName.value}".`,
              {
                nodes: [
                  knownOperationNames[operationName.value],
                  operationName
                ]
              }
            )
          );
        } else {
          knownOperationNames[operationName.value] = operationName;
        }
      }
      return false;
    },
    FragmentDefinition: () => false
  };
}

// node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs
function UniqueOperationTypesRule(context) {
  const schema = context.getSchema();
  const definedOperationTypes = /* @__PURE__ */ Object.create(null);
  const existingOperationTypes = schema ? {
    query: schema.getQueryType(),
    mutation: schema.getMutationType(),
    subscription: schema.getSubscriptionType()
  } : {};
  return {
    SchemaDefinition: checkOperationTypes,
    SchemaExtension: checkOperationTypes
  };
  function checkOperationTypes(node) {
    var _node$operationTypes;
    const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
    for (const operationType of operationTypesNodes) {
      const operation = operationType.operation;
      const alreadyDefinedOperationType = definedOperationTypes[operation];
      if (existingOperationTypes[operation]) {
        context.reportError(
          new GraphQLError(
            `Type for ${operation} already defined in the schema. It cannot be redefined.`,
            {
              nodes: operationType
            }
          )
        );
      } else if (alreadyDefinedOperationType) {
        context.reportError(
          new GraphQLError(
            `There can be only one ${operation} type in schema.`,
            {
              nodes: [alreadyDefinedOperationType, operationType]
            }
          )
        );
      } else {
        definedOperationTypes[operation] = operationType;
      }
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs
function UniqueTypeNamesRule(context) {
  const knownTypeNames = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  return {
    ScalarTypeDefinition: checkTypeName,
    ObjectTypeDefinition: checkTypeName,
    InterfaceTypeDefinition: checkTypeName,
    UnionTypeDefinition: checkTypeName,
    EnumTypeDefinition: checkTypeName,
    InputObjectTypeDefinition: checkTypeName
  };
  function checkTypeName(node) {
    const typeName = node.name.value;
    if (schema !== null && schema !== void 0 && schema.getType(typeName)) {
      context.reportError(
        new GraphQLError(
          `Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`,
          {
            nodes: node.name
          }
        )
      );
      return;
    }
    if (knownTypeNames[typeName]) {
      context.reportError(
        new GraphQLError(`There can be only one type named "${typeName}".`, {
          nodes: [knownTypeNames[typeName], node.name]
        })
      );
    } else {
      knownTypeNames[typeName] = node.name;
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs
function UniqueVariableNamesRule(context) {
  return {
    OperationDefinition(operationNode) {
      var _operationNode$variab;
      const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== void 0 ? _operationNode$variab : [];
      const seenVariableDefinitions = groupBy(
        variableDefinitions,
        (node) => node.variable.name.value
      );
      for (const [variableName, variableNodes] of seenVariableDefinitions) {
        if (variableNodes.length > 1) {
          context.reportError(
            new GraphQLError(
              `There can be only one variable named "$${variableName}".`,
              {
                nodes: variableNodes.map((node) => node.variable.name)
              }
            )
          );
        }
      }
    }
  };
}

// node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs
function ValuesOfCorrectTypeRule(context) {
  let variableDefinitions = {};
  return {
    OperationDefinition: {
      enter() {
        variableDefinitions = {};
      }
    },
    VariableDefinition(definition) {
      variableDefinitions[definition.variable.name.value] = definition;
    },
    ListValue(node) {
      const type = getNullableType(context.getParentInputType());
      if (!isListType(type)) {
        isValidValueNode(context, node);
        return false;
      }
    },
    ObjectValue(node) {
      const type = getNamedType(context.getInputType());
      if (!isInputObjectType(type)) {
        isValidValueNode(context, node);
        return false;
      }
      const fieldNodeMap = keyMap(node.fields, (field) => field.name.value);
      for (const fieldDef of Object.values(type.getFields())) {
        const fieldNode = fieldNodeMap[fieldDef.name];
        if (!fieldNode && isRequiredInputField(fieldDef)) {
          const typeStr = inspect(fieldDef.type);
          context.reportError(
            new GraphQLError(
              `Field "${type.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`,
              {
                nodes: node
              }
            )
          );
        }
      }
      if (type.isOneOf) {
        validateOneOfInputObject(
          context,
          node,
          type,
          fieldNodeMap,
          variableDefinitions
        );
      }
    },
    ObjectField(node) {
      const parentType = getNamedType(context.getParentInputType());
      const fieldType = context.getInputType();
      if (!fieldType && isInputObjectType(parentType)) {
        const suggestions = suggestionList(
          node.name.value,
          Object.keys(parentType.getFields())
        );
        context.reportError(
          new GraphQLError(
            `Field "${node.name.value}" is not defined by type "${parentType.name}".` + didYouMean(suggestions),
            {
              nodes: node
            }
          )
        );
      }
    },
    NullValue(node) {
      const type = context.getInputType();
      if (isNonNullType(type)) {
        context.reportError(
          new GraphQLError(
            `Expected value of type "${inspect(type)}", found ${print(node)}.`,
            {
              nodes: node
            }
          )
        );
      }
    },
    EnumValue: (node) => isValidValueNode(context, node),
    IntValue: (node) => isValidValueNode(context, node),
    FloatValue: (node) => isValidValueNode(context, node),
    StringValue: (node) => isValidValueNode(context, node),
    BooleanValue: (node) => isValidValueNode(context, node)
  };
}
function isValidValueNode(context, node) {
  const locationType = context.getInputType();
  if (!locationType) {
    return;
  }
  const type = getNamedType(locationType);
  if (!isLeafType(type)) {
    const typeStr = inspect(locationType);
    context.reportError(
      new GraphQLError(
        `Expected value of type "${typeStr}", found ${print(node)}.`,
        {
          nodes: node
        }
      )
    );
    return;
  }
  try {
    const parseResult = type.parseLiteral(
      node,
      void 0
      /* variables */
    );
    if (parseResult === void 0) {
      const typeStr = inspect(locationType);
      context.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print(node)}.`,
          {
            nodes: node
          }
        )
      );
    }
  } catch (error) {
    const typeStr = inspect(locationType);
    if (error instanceof GraphQLError) {
      context.reportError(error);
    } else {
      context.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print(node)}; ` + error.message,
          {
            nodes: node,
            originalError: error
          }
        )
      );
    }
  }
}
function validateOneOfInputObject(context, node, type, fieldNodeMap, variableDefinitions) {
  var _fieldNodeMap$keys$;
  const keys = Object.keys(fieldNodeMap);
  const isNotExactlyOneField = keys.length !== 1;
  if (isNotExactlyOneField) {
    context.reportError(
      new GraphQLError(
        `OneOf Input Object "${type.name}" must specify exactly one key.`,
        {
          nodes: [node]
        }
      )
    );
    return;
  }
  const value = (_fieldNodeMap$keys$ = fieldNodeMap[keys[0]]) === null || _fieldNodeMap$keys$ === void 0 ? void 0 : _fieldNodeMap$keys$.value;
  const isNullLiteral = !value || value.kind === Kind.NULL;
  const isVariable = (value === null || value === void 0 ? void 0 : value.kind) === Kind.VARIABLE;
  if (isNullLiteral) {
    context.reportError(
      new GraphQLError(`Field "${type.name}.${keys[0]}" must be non-null.`, {
        nodes: [node]
      })
    );
    return;
  }
  if (isVariable) {
    const variableName = value.name.value;
    const definition = variableDefinitions[variableName];
    const isNullableVariable = definition.type.kind !== Kind.NON_NULL_TYPE;
    if (isNullableVariable) {
      context.reportError(
        new GraphQLError(
          `Variable "${variableName}" must be non-nullable to be used for OneOf Input Object "${type.name}".`,
          {
            nodes: [node]
          }
        )
      );
    }
  }
}

// node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs
function VariablesAreInputTypesRule(context) {
  return {
    VariableDefinition(node) {
      const type = typeFromAST(context.getSchema(), node.type);
      if (type !== void 0 && !isInputType(type)) {
        const variableName = node.variable.name.value;
        const typeName = print(node.type);
        context.reportError(
          new GraphQLError(
            `Variable "$${variableName}" cannot be non-input type "${typeName}".`,
            {
              nodes: node.type
            }
          )
        );
      }
    }
  };
}

// node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs
function VariablesInAllowedPositionRule(context) {
  let varDefMap = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        varDefMap = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node, type, defaultValue } of usages) {
          const varName = node.name.value;
          const varDef = varDefMap[varName];
          if (varDef && type) {
            const schema = context.getSchema();
            const varType = typeFromAST(schema, varDef.type);
            if (varType && !allowedVariableUsage(
              schema,
              varType,
              varDef.defaultValue,
              type,
              defaultValue
            )) {
              const varTypeStr = inspect(varType);
              const typeStr = inspect(type);
              context.reportError(
                new GraphQLError(
                  `Variable "$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`,
                  {
                    nodes: [varDef, node]
                  }
                )
              );
            }
          }
        }
      }
    },
    VariableDefinition(node) {
      varDefMap[node.variable.name.value] = node;
    }
  };
}
function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
  if (isNonNullType(locationType) && !isNonNullType(varType)) {
    const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;
    const hasLocationDefaultValue = locationDefaultValue !== void 0;
    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
      return false;
    }
    const nullableLocationType = locationType.ofType;
    return isTypeSubTypeOf(schema, varType, nullableLocationType);
  }
  return isTypeSubTypeOf(schema, varType, locationType);
}

// node_modules/graphql/validation/specifiedRules.mjs
var recommendedRules = Object.freeze([MaxIntrospectionDepthRule]);
var specifiedRules = Object.freeze([
  ExecutableDefinitionsRule,
  UniqueOperationNamesRule,
  LoneAnonymousOperationRule,
  SingleFieldSubscriptionsRule,
  KnownTypeNamesRule,
  FragmentsOnCompositeTypesRule,
  VariablesAreInputTypesRule,
  ScalarLeafsRule,
  FieldsOnCorrectTypeRule,
  UniqueFragmentNamesRule,
  KnownFragmentNamesRule,
  NoUnusedFragmentsRule,
  PossibleFragmentSpreadsRule,
  NoFragmentCyclesRule,
  UniqueVariableNamesRule,
  NoUndefinedVariablesRule,
  NoUnusedVariablesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  KnownArgumentNamesRule,
  UniqueArgumentNamesRule,
  ValuesOfCorrectTypeRule,
  ProvidedRequiredArgumentsRule,
  VariablesInAllowedPositionRule,
  OverlappingFieldsCanBeMergedRule,
  UniqueInputFieldNamesRule,
  ...recommendedRules
]);
var specifiedSDLRules = Object.freeze([
  LoneSchemaDefinitionRule,
  UniqueOperationTypesRule,
  UniqueTypeNamesRule,
  UniqueEnumValueNamesRule,
  UniqueFieldDefinitionNamesRule,
  UniqueArgumentDefinitionNamesRule,
  UniqueDirectiveNamesRule,
  KnownTypeNamesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  PossibleTypeExtensionsRule,
  KnownArgumentNamesOnDirectivesRule,
  UniqueArgumentNamesRule,
  UniqueInputFieldNamesRule,
  ProvidedRequiredArgumentsOnDirectivesRule
]);

// node_modules/graphql/jsutils/memoize3.mjs
function memoize3(fn4) {
  let cache0;
  return function memoized(a1, a26, a32) {
    if (cache0 === void 0) {
      cache0 = /* @__PURE__ */ new WeakMap();
    }
    let cache1 = cache0.get(a1);
    if (cache1 === void 0) {
      cache1 = /* @__PURE__ */ new WeakMap();
      cache0.set(a1, cache1);
    }
    let cache2 = cache1.get(a26);
    if (cache2 === void 0) {
      cache2 = /* @__PURE__ */ new WeakMap();
      cache1.set(a26, cache2);
    }
    let fnResult = cache2.get(a32);
    if (fnResult === void 0) {
      fnResult = fn4(a1, a26, a32);
      cache2.set(a32, fnResult);
    }
    return fnResult;
  };
}

// node_modules/graphql/execution/execute.mjs
var collectSubfields2 = memoize3(
  (exeContext, returnType, fieldNodes) => collectSubfields(
    exeContext.schema,
    exeContext.fragments,
    exeContext.variableValues,
    returnType,
    fieldNodes
  )
);

// node_modules/graphql/utilities/extendSchema.mjs
var stdTypeMap = keyMap(
  [...specifiedScalarTypes, ...introspectionTypes],
  (type) => type.name
);

// node_modules/graphql/utilities/findBreakingChanges.mjs
var BreakingChangeType;
(function(BreakingChangeType2) {
  BreakingChangeType2["TYPE_REMOVED"] = "TYPE_REMOVED";
  BreakingChangeType2["TYPE_CHANGED_KIND"] = "TYPE_CHANGED_KIND";
  BreakingChangeType2["TYPE_REMOVED_FROM_UNION"] = "TYPE_REMOVED_FROM_UNION";
  BreakingChangeType2["VALUE_REMOVED_FROM_ENUM"] = "VALUE_REMOVED_FROM_ENUM";
  BreakingChangeType2["REQUIRED_INPUT_FIELD_ADDED"] = "REQUIRED_INPUT_FIELD_ADDED";
  BreakingChangeType2["IMPLEMENTED_INTERFACE_REMOVED"] = "IMPLEMENTED_INTERFACE_REMOVED";
  BreakingChangeType2["FIELD_REMOVED"] = "FIELD_REMOVED";
  BreakingChangeType2["FIELD_CHANGED_KIND"] = "FIELD_CHANGED_KIND";
  BreakingChangeType2["REQUIRED_ARG_ADDED"] = "REQUIRED_ARG_ADDED";
  BreakingChangeType2["ARG_REMOVED"] = "ARG_REMOVED";
  BreakingChangeType2["ARG_CHANGED_KIND"] = "ARG_CHANGED_KIND";
  BreakingChangeType2["DIRECTIVE_REMOVED"] = "DIRECTIVE_REMOVED";
  BreakingChangeType2["DIRECTIVE_ARG_REMOVED"] = "DIRECTIVE_ARG_REMOVED";
  BreakingChangeType2["REQUIRED_DIRECTIVE_ARG_ADDED"] = "REQUIRED_DIRECTIVE_ARG_ADDED";
  BreakingChangeType2["DIRECTIVE_REPEATABLE_REMOVED"] = "DIRECTIVE_REPEATABLE_REMOVED";
  BreakingChangeType2["DIRECTIVE_LOCATION_REMOVED"] = "DIRECTIVE_LOCATION_REMOVED";
})(BreakingChangeType || (BreakingChangeType = {}));
var DangerousChangeType;
(function(DangerousChangeType2) {
  DangerousChangeType2["VALUE_ADDED_TO_ENUM"] = "VALUE_ADDED_TO_ENUM";
  DangerousChangeType2["TYPE_ADDED_TO_UNION"] = "TYPE_ADDED_TO_UNION";
  DangerousChangeType2["OPTIONAL_INPUT_FIELD_ADDED"] = "OPTIONAL_INPUT_FIELD_ADDED";
  DangerousChangeType2["OPTIONAL_ARG_ADDED"] = "OPTIONAL_ARG_ADDED";
  DangerousChangeType2["IMPLEMENTED_INTERFACE_ADDED"] = "IMPLEMENTED_INTERFACE_ADDED";
  DangerousChangeType2["ARG_DEFAULT_VALUE_CHANGE"] = "ARG_DEFAULT_VALUE_CHANGE";
})(DangerousChangeType || (DangerousChangeType = {}));

// node_modules/graphql-request/build/lib/http.js
var ACCEPT_HEADER = `Accept`;
var CONTENT_TYPE_HEADER = `Content-Type`;
var CONTENT_TYPE_JSON = `application/json`;
var CONTENT_TYPE_GQL = `application/graphql-response+json`;

// node_modules/graphql-request/build/legacy/lib/graphql.js
var cleanQuery = (str) => str.replace(/([\s,]|#[^\n\r]+)+/g, ` `).trim();
var isGraphQLContentType = (contentType) => {
  const contentTypeLower = contentType.toLowerCase();
  return contentTypeLower.includes(CONTENT_TYPE_GQL) || contentTypeLower.includes(CONTENT_TYPE_JSON);
};
var parseGraphQLExecutionResult = (result) => {
  try {
    if (Array.isArray(result)) {
      return {
        _tag: `Batch`,
        executionResults: result.map(parseExecutionResult)
      };
    } else if (isPlainObject(result)) {
      return {
        _tag: `Single`,
        executionResult: parseExecutionResult(result)
      };
    } else {
      throw new Error(`Invalid execution result: result is not object or array. 
Got:
${String(result)}`);
    }
  } catch (e10) {
    return e10;
  }
};
var parseExecutionResult = (result) => {
  if (typeof result !== `object` || result === null) {
    throw new Error(`Invalid execution result: result is not object`);
  }
  let errors = void 0;
  let data = void 0;
  let extensions = void 0;
  if (`errors` in result) {
    if (!isPlainObject(result.errors) && !Array.isArray(result.errors)) {
      throw new Error(`Invalid execution result: errors is not plain object OR array`);
    }
    errors = result.errors;
  }
  if (`data` in result) {
    if (!isPlainObject(result.data) && result.data !== null) {
      throw new Error(`Invalid execution result: data is not plain object`);
    }
    data = result.data;
  }
  if (`extensions` in result) {
    if (!isPlainObject(result.extensions))
      throw new Error(`Invalid execution result: extensions is not plain object`);
    extensions = result.extensions;
  }
  return {
    data,
    errors,
    extensions
  };
};
var isRequestResultHaveErrors = (result) => result._tag === `Batch` ? result.executionResults.some(isExecutionResultHaveErrors) : isExecutionResultHaveErrors(result.executionResult);
var isExecutionResultHaveErrors = (result) => Array.isArray(result.errors) ? result.errors.length > 0 : Boolean(result.errors);
var isOperationDefinitionNode = (definition) => {
  return typeof definition === `object` && definition !== null && `kind` in definition && definition.kind === Kind.OPERATION_DEFINITION;
};

// node_modules/graphql-request/build/legacy/helpers/analyzeDocument.js
var extractOperationName = (document2) => {
  var _a;
  let operationName = void 0;
  const defs = document2.definitions.filter(isOperationDefinitionNode);
  if (defs.length === 1) {
    operationName = (_a = defs[0].name) == null ? void 0 : _a.value;
  }
  return operationName;
};
var extractIsMutation = (document2) => {
  let isMutation = false;
  const defs = document2.definitions.filter(isOperationDefinitionNode);
  if (defs.length === 1) {
    isMutation = defs[0].operation === OperationTypeNode.MUTATION;
  }
  return isMutation;
};
var analyzeDocument = (document2, excludeOperationName) => {
  const expression = typeof document2 === `string` ? document2 : print(document2);
  let isMutation = false;
  let operationName = void 0;
  if (excludeOperationName) {
    return { expression, isMutation, operationName };
  }
  const docNode = tryCatch(() => typeof document2 === `string` ? parse(document2) : document2);
  if (docNode instanceof Error) {
    return { expression, isMutation, operationName };
  }
  operationName = extractOperationName(docNode);
  isMutation = extractIsMutation(docNode);
  return { expression, operationName, isMutation };
};

// node_modules/graphql-request/build/legacy/helpers/defaultJsonSerializer.js
var defaultJsonSerializer = JSON;

// node_modules/graphql-request/build/legacy/helpers/runRequest.js
var runRequest = async (input) => {
  const config = {
    ...input,
    method: input.request._tag === `Single` ? input.request.document.isMutation ? `POST` : uppercase(input.method ?? `post`) : input.request.hasMutations ? `POST` : uppercase(input.method ?? `post`),
    fetchOptions: {
      ...input.fetchOptions,
      errorPolicy: input.fetchOptions.errorPolicy ?? `none`
    }
  };
  const fetcher = createFetcher(config.method);
  const fetchResponse = await fetcher(config);
  if (!fetchResponse.ok) {
    return new ClientError({ status: fetchResponse.status, headers: fetchResponse.headers }, {
      query: input.request._tag === `Single` ? input.request.document.expression : input.request.query,
      variables: input.request.variables
    });
  }
  const result = await parseResultFromResponse(fetchResponse, input.fetchOptions.jsonSerializer ?? defaultJsonSerializer);
  if (result instanceof Error)
    throw result;
  const clientResponseBase = {
    status: fetchResponse.status,
    headers: fetchResponse.headers
  };
  if (isRequestResultHaveErrors(result) && config.fetchOptions.errorPolicy === `none`) {
    const clientResponse = result._tag === `Batch` ? { ...result.executionResults, ...clientResponseBase } : {
      ...result.executionResult,
      ...clientResponseBase
    };
    return new ClientError(clientResponse, {
      query: input.request._tag === `Single` ? input.request.document.expression : input.request.query,
      variables: input.request.variables
    });
  }
  switch (result._tag) {
    case `Single`:
      return {
        ...clientResponseBase,
        ...executionResultClientResponseFields(config)(result.executionResult)
      };
    case `Batch`:
      return {
        ...clientResponseBase,
        data: result.executionResults.map(executionResultClientResponseFields(config))
      };
    default:
      casesExhausted(result);
  }
};
var executionResultClientResponseFields = ($params) => (executionResult) => {
  return {
    extensions: executionResult.extensions,
    data: executionResult.data,
    errors: $params.fetchOptions.errorPolicy === `all` ? executionResult.errors : void 0
  };
};
var parseResultFromResponse = async (response, jsonSerializer) => {
  const contentType = response.headers.get(CONTENT_TYPE_HEADER);
  const text = await response.text();
  if (contentType && isGraphQLContentType(contentType)) {
    return parseGraphQLExecutionResult(jsonSerializer.parse(text));
  } else {
    return parseGraphQLExecutionResult(text);
  }
};
var createFetcher = (method) => async (params) => {
  const headers = new Headers(params.headers);
  let searchParams = null;
  let body = void 0;
  if (!headers.has(ACCEPT_HEADER)) {
    headers.set(ACCEPT_HEADER, [CONTENT_TYPE_GQL, CONTENT_TYPE_JSON].join(`, `));
  }
  if (method === `POST`) {
    const $jsonSerializer = params.fetchOptions.jsonSerializer ?? defaultJsonSerializer;
    body = $jsonSerializer.stringify(buildBody(params));
    if (typeof body === `string` && !headers.has(CONTENT_TYPE_HEADER)) {
      headers.set(CONTENT_TYPE_HEADER, CONTENT_TYPE_JSON);
    }
  } else {
    searchParams = buildQueryParams(params);
  }
  const init = { method, headers, body, ...params.fetchOptions };
  let url = new URL(params.url);
  let initResolved = init;
  if (params.middleware) {
    const result = await Promise.resolve(params.middleware({
      ...init,
      url: params.url,
      operationName: params.request._tag === `Single` ? params.request.document.operationName : void 0,
      variables: params.request.variables
    }));
    const { url: urlNew, ...initNew } = result;
    url = new URL(urlNew);
    initResolved = initNew;
  }
  if (searchParams) {
    searchParams.forEach((value, name) => {
      url.searchParams.append(name, value);
    });
  }
  const $fetch = params.fetch ?? fetch;
  return await $fetch(url, initResolved);
};
var buildBody = (params) => {
  switch (params.request._tag) {
    case `Single`:
      return {
        query: params.request.document.expression,
        variables: params.request.variables,
        operationName: params.request.document.operationName
      };
    case `Batch`:
      return zip(params.request.query, params.request.variables ?? []).map(([query, variables]) => ({
        query,
        variables
      }));
    default:
      throw casesExhausted(params.request);
  }
};
var buildQueryParams = (params) => {
  var _a;
  const $jsonSerializer = params.fetchOptions.jsonSerializer ?? defaultJsonSerializer;
  const searchParams = new URLSearchParams();
  switch (params.request._tag) {
    case `Single`: {
      searchParams.append(`query`, cleanQuery(params.request.document.expression));
      if (params.request.variables) {
        searchParams.append(`variables`, $jsonSerializer.stringify(params.request.variables));
      }
      if (params.request.document.operationName) {
        searchParams.append(`operationName`, params.request.document.operationName);
      }
      return searchParams;
    }
    case `Batch`: {
      const variablesSerialized = ((_a = params.request.variables) == null ? void 0 : _a.map((v8) => $jsonSerializer.stringify(v8))) ?? [];
      const queriesCleaned = params.request.query.map(cleanQuery);
      const payload = zip(queriesCleaned, variablesSerialized).map(([query, variables]) => ({
        query,
        variables
      }));
      searchParams.append(`query`, $jsonSerializer.stringify(payload));
      return searchParams;
    }
    default:
      throw casesExhausted(params.request);
  }
};

// node_modules/graphql-request/build/legacy/classes/GraphQLClient.js
var GraphQLClient = class {
  constructor(url, requestConfig = {}) {
    __publicField(this, "url");
    __publicField(this, "requestConfig");
    /**
     * Send a GraphQL query to the server.
     */
    __publicField(this, "rawRequest", async (...args) => {
      const [queryOrOptions, variables, requestHeaders] = args;
      const rawRequestOptions = parseRawRequestArgs(queryOrOptions, variables, requestHeaders);
      const { headers, fetch: fetch2 = globalThis.fetch, method = `POST`, requestMiddleware, responseMiddleware, excludeOperationName, ...fetchOptions } = this.requestConfig;
      const { url } = this;
      if (rawRequestOptions.signal !== void 0) {
        fetchOptions.signal = rawRequestOptions.signal;
      }
      const document2 = analyzeDocument(rawRequestOptions.query, excludeOperationName);
      const response = await runRequest({
        url,
        request: {
          _tag: `Single`,
          document: document2,
          variables: rawRequestOptions.variables
        },
        headers: {
          ...HeadersInitToPlainObject(callOrIdentity(headers)),
          ...HeadersInitToPlainObject(rawRequestOptions.requestHeaders)
        },
        fetch: fetch2,
        method,
        fetchOptions,
        middleware: requestMiddleware
      });
      if (responseMiddleware) {
        await responseMiddleware(response, {
          operationName: document2.operationName,
          variables,
          url: this.url
        });
      }
      if (response instanceof Error) {
        throw response;
      }
      return response;
    });
    this.url = url;
    this.requestConfig = requestConfig;
  }
  async request(documentOrOptions, ...variablesAndRequestHeaders) {
    const [variables, requestHeaders] = variablesAndRequestHeaders;
    const requestOptions = parseRequestArgs(documentOrOptions, variables, requestHeaders);
    const { headers, fetch: fetch2 = globalThis.fetch, method = `POST`, requestMiddleware, responseMiddleware, excludeOperationName, ...fetchOptions } = this.requestConfig;
    const { url } = this;
    if (requestOptions.signal !== void 0) {
      fetchOptions.signal = requestOptions.signal;
    }
    const analyzedDocument = analyzeDocument(requestOptions.document, excludeOperationName);
    const response = await runRequest({
      url,
      request: {
        _tag: `Single`,
        document: analyzedDocument,
        variables: requestOptions.variables
      },
      headers: {
        ...HeadersInitToPlainObject(callOrIdentity(headers)),
        ...HeadersInitToPlainObject(requestOptions.requestHeaders)
      },
      fetch: fetch2,
      method,
      fetchOptions,
      middleware: requestMiddleware
    });
    if (responseMiddleware) {
      await responseMiddleware(response, {
        operationName: analyzedDocument.operationName,
        variables: requestOptions.variables,
        url: this.url
      });
    }
    if (response instanceof Error) {
      throw response;
    }
    return response.data;
  }
  async batchRequests(documentsOrOptions, requestHeaders) {
    const batchRequestOptions = parseBatchRequestArgs(documentsOrOptions, requestHeaders);
    const { headers, excludeOperationName, ...fetchOptions } = this.requestConfig;
    if (batchRequestOptions.signal !== void 0) {
      fetchOptions.signal = batchRequestOptions.signal;
    }
    const analyzedDocuments = batchRequestOptions.documents.map(({ document: document2 }) => analyzeDocument(document2, excludeOperationName));
    const expressions = analyzedDocuments.map(({ expression }) => expression);
    const hasMutations = analyzedDocuments.some(({ isMutation }) => isMutation);
    const variables = batchRequestOptions.documents.map(({ variables: variables2 }) => variables2);
    const response = await runRequest({
      url: this.url,
      request: {
        _tag: `Batch`,
        operationName: void 0,
        query: expressions,
        hasMutations,
        variables
      },
      headers: {
        ...HeadersInitToPlainObject(callOrIdentity(headers)),
        ...HeadersInitToPlainObject(batchRequestOptions.requestHeaders)
      },
      fetch: this.requestConfig.fetch ?? globalThis.fetch,
      method: this.requestConfig.method || `POST`,
      fetchOptions,
      middleware: this.requestConfig.requestMiddleware
    });
    if (this.requestConfig.responseMiddleware) {
      await this.requestConfig.responseMiddleware(response, {
        operationName: void 0,
        variables,
        url: this.url
      });
    }
    if (response instanceof Error) {
      throw response;
    }
    return response.data;
  }
  setHeaders(headers) {
    this.requestConfig.headers = headers;
    return this;
  }
  /**
   * Attach a header to the client. All subsequent requests will have this header.
   */
  setHeader(key, value) {
    const { headers } = this.requestConfig;
    if (headers) {
      headers[key] = value;
    } else {
      this.requestConfig.headers = { [key]: value };
    }
    return this;
  }
  /**
   * Change the client endpoint. All subsequent requests will send to this endpoint.
   */
  setEndpoint(value) {
    this.url = value;
    return this;
  }
};

// node_modules/graphql-request/build/legacy/functions/request.js
async function request(urlOrOptions, document2, ...variablesAndRequestHeaders) {
  const requestOptions = parseRequestExtendedArgs(urlOrOptions, document2, ...variablesAndRequestHeaders);
  const client = new GraphQLClient(requestOptions.url);
  return client.request({
    ...requestOptions
  });
}
var parseRequestArgs = (documentOrOptions, variables, requestHeaders) => {
  return documentOrOptions.document ? documentOrOptions : {
    document: documentOrOptions,
    variables,
    requestHeaders,
    signal: void 0
  };
};
var parseRequestExtendedArgs = (urlOrOptions, document2, ...variablesAndRequestHeaders) => {
  const [variables, requestHeaders] = variablesAndRequestHeaders;
  return typeof urlOrOptions === `string` ? {
    url: urlOrOptions,
    document: document2,
    variables,
    requestHeaders,
    signal: void 0
  } : urlOrOptions;
};

// node_modules/graphql-request/build/legacy/functions/gql.js
var gql = (chunks, ...variables) => {
  return chunks.reduce((acc, chunk, index) => `${acc}${chunk}${index in variables ? String(variables[index]) : ``}`, ``);
};

// node_modules/graphql-request/build/entrypoints/main.js
var main_default = request;

// node_modules/@mizuwallet-sdk/core/dist/index.js
var k6 = Object.defineProperty;
var y13 = (r30, e10, t39) => e10 in r30 ? k6(r30, e10, { enumerable: true, configurable: true, writable: true, value: t39 }) : r30[e10] = t39;
var s13 = (r30, e10, t39) => y13(r30, typeof e10 != "symbol" ? e10 + "" : e10, t39);
var $7 = (r30) => {
  var t39;
  if (!r30) return new Error("JWT Token not found. ");
  const e10 = jwtDecode(r30);
  if ((e10 == null ? void 0 : e10.exp) < Date.now() / 1e3)
    throw new Error("JWT Token expired. Please login again! ");
  if ((t39 = e10 == null ? void 0 : e10["https://hasura.io/jwt/claims"]) != null && t39["x-hasura-user-id"])
    return [e10["https://hasura.io/jwt/claims"]["x-hasura-user-id"], r30];
  throw new Error("User id not found in JWT Token");
};
var p15 = (r30) => r30.arguments ? {
  function: r30.function,
  functionArguments: r30.arguments,
  typeArguments: r30.type_arguments
} : r30.functionArguments ? r30 : null;
var f18 = gql`
  mutation TGLoginMutation($appId: String = "", $initData: String = "") {
    tgLogin(appId: $appId, initData: $initData)
  }
`;
var T12 = gql`
  mutation TGLoginMutation($appId: String = "", $initData: String = "", $shortId: String = "") {
    tgLogin(appId: $appId, initData: $initData, shortId: $shortId)
  }
`;
var E10 = gql`
  mutation tgWidgetLoginMutation($appId: String = "", $authData: String = "") {
    tgWidgetLogin(appId: $appId, authData: $authData)
  }
`;
var q5 = gql`
  mutation tgWidgetLoginMutation(
    $appId: String = ""
    $authData: String = ""
    $shortId: String = ""
  ) {
    tgWidgetLogin(appId: $appId, authData: $authData, shortId: $shortId)
  }
`;
var S8 = gql`
  query CheckUserIsExistQueryByTgId {
    telegramUser {
      walletUserId
      tgId
    }
  }
`;
var g10 = gql`
  query UserWalletAddressQuery($id: uuid = "") {
    walletUserByPk(id: $id) {
      sub_wallets {
        address
        publicKey
      }
      google_user {
        email
      }
      telegram_user {
        firstName
        lastName
        photoUrl
        userName
      }
      twitter_user {
        name
        userName
      }
    }
  }
`;
var W10 = gql`
  mutation CreateOrderQuery($appId: String = "", $payload: String = "") {
    createOrder(appId: $appId, payload: $payload)
  }
`;
var z8 = gql`
  mutation createSignatureMutation($appId: String = "", $transactionHex: String = "") {
    createSignature(appId: $appId, transactionHex: $transactionHex)
  }
`;
var P7 = gql`
  mutation createSignMessageMutation(
    $appId: String = ""
    $message: String = ""
    $nonce: String = ""
  ) {
    createSignMessage(appId: $appId, nonce: $nonce, message: $message) {
      fullMessage
      message
      nonce
      prefix
      signature
    }
  }
`;
var C8 = gql`
  query simulateOrderQuery($payload: String = "") {
    simulateOrder(payload: $payload)
  }
`;
var O7 = gql`
  mutation confirmOrderQuery($orderId: String = "") {
    confirmOrder(orderId: $orderId)
  }
`;
var L8 = gql`
  query fetchOrderQuery($id: uuid = "") {
    orderByPk(id: $id) {
      id
      createdAt
      payload
      status
      type
      updatedAt
      walletUserId
      applicationId
      hash
      type
      transactions {
        hash
        type
      }
    }
  }
`;
gql`
  query fetchOrderHashQuery($orderId: String = "") {
    getOrderHash(orderId: $orderId)
  }
`;
var b11 = gql`
  query fetchOrderListQuery(
    $walletUserId: uuid = ""
    $limit: Int = 10
    $offset: Int = 0
    $status: [Int] = []
  ) {
    order(
      where: { walletUserId: { _eq: $walletUserId } }
      limit: $limit
      offset: $offset
      orderBy: { createdAt: DESC }
    ) {
      applicationId
      createdAt
      id
      payload
      status
      transactionSeqNo
      type
      updatedAt
      walletUserId
      hash
      gasFee
      transactions {
        hash
        gasFee
        createdAt
        status
        type
      }
    }
    orderAggregate(where: { walletUserId: { _eq: $walletUserId } }) {
      aggregate {
        count
      }
    }
  }
`;
var A17 = gql`
  mutation bindGoogleQuery($address: String = "", $idToken: String = "") {
    googleBind(address: $address, idToken: $idToken)
  }
`;
var D10 = gql`
  mutation createOrderWithCodeMutation(
    $appId: String = ""
    $authCode: String = ""
    $payload: String = ""
  ) {
    createOrderWithCode(appId: $appId, authCode: $authCode, payload: $payload)
  }
`;
var d23 = ((r30) => (r30[r30.PENDING = 0] = "PENDING", r30[r30.CONFIRMED = 1] = "CONFIRMED", r30[r30.EXECUTED = 2] = "EXECUTED", r30[r30.SUCCESS = 3] = "SUCCESS", r30[r30.FAIL = 4] = "FAIL", r30[r30.CANCELED = 5] = "CANCELED", r30))(d23 || {});
var I6 = {
  testnet: "https://hasura-wallet.groupwar.xyz/v1/graphql",
  mainnet: "https://api.mz.xyz/v1/graphql/"
};
var J3 = "https://mizu.io/keyless_google";
var h18 = class _h {
  /**
   * Initialize MizuWallet SDK Core Client
   *
   * @param args.appId - Application ID
   * @param args.network - Network.MAINNET | Network.TESTNET
   */
  constructor(e10) {
    s13(this, "appId");
    s13(this, "network");
    s13(this, "graphqlEndPoint", "");
    s13(this, "userId", "");
    s13(this, "jwtToken", "");
    s13(this, "initialized", false);
    if (!e10.appId) throw new Error("appId is required");
    if (!e10.network) throw new Error("network is required");
    this.appId = e10.appId, this.network = e10.network, this.graphqlEndPoint = I6[this.network], this.initialized = true;
  }
  /**
   * Check if MizuWallet SDK Core Client is initialized
   */
  checkInitialized() {
    if (!this.initialized) throw new Error("MizuWallet SDK Core Client not initialized");
  }
  /**
   * Check if JWT Token is available
   */
  checkJWTToken() {
    if (!this.jwtToken) throw new Error("JWT Token not found. Please login first.");
  }
  /**
   * Decode JWT Token
   */
  static decodeJWTToken(e10) {
    const [t39, n27] = $7(e10);
    return [t39, n27];
  }
  /**
   * Clone MizuWallet SDK Core Client
   *
   * @param args.appId - Application ID
   * @param args.network - Network.MAINNET | Network.TESTNET
   * @param args.jwtToken - JWT Token
   */
  static clone(e10) {
    if (!e10.appId) throw new Error("appId is required");
    if (!e10.network) throw new Error("network is required");
    if (!e10.jwtToken) throw new Error("jwtToken is required");
    const t39 = new _h({ appId: e10.appId, network: e10.network });
    return [t39.userId, t39.jwtToken] = _h.decodeJWTToken(e10.jwtToken), t39;
  }
  /**
   * Update network
   * @param network - Network.MAINNET | Network.TESTNET
   */
  updateNetwork(e10) {
    this.checkInitialized(), this.network = e10, this.graphqlEndPoint = I6[this.network];
  }
  /**
   * Get network info
   */
  get networkInfo() {
    return {
      name: this.network,
      chainId: this.network === e.MAINNET ? 1 : 2,
      url: this.network === e.MAINNET ? "https://fullnode.mainnet.aptoslabs.com/v1" : "https://fullnode.testnet.aptoslabs.com/v1"
    };
  }
  /**
   *
   *
   */
  login() {
    this.checkInitialized();
  }
  /**
   * Login in TG
   *
   * @param data - initial data of TG, or stringified widget user object
   * @param opt.isWidget - is from login widget
   */
  async loginInTG(e10, t39) {
    this.checkInitialized();
    let n27 = "";
    t39 != null && t39.isWidget ? n27 = (await main_default({
      url: this.graphqlEndPoint,
      document: t39 != null && t39.shortID ? q5 : E10,
      variables: {
        appId: this.appId,
        authData: window.btoa(e10),
        ...t39 != null && t39.shortID ? { shortId: t39.shortID } : {}
      }
    })).tgWidgetLogin : n27 = (await main_default({
      url: this.graphqlEndPoint,
      document: t39 != null && t39.shortID ? T12 : f18,
      variables: {
        appId: this.appId,
        initData: e10,
        ...t39 != null && t39.shortID ? { shortId: t39.shortID } : {}
      }
    })).tgLogin;
    try {
      [this.userId, this.jwtToken] = _h.decodeJWTToken(n27);
    } catch {
      this.logout();
    }
  }
  /**
   * Check if user exist by TG ID
   *
   * @param tgId
   * @returns
   */
  async isUserExistByTgID(e10) {
    var n27;
    if (this.checkInitialized(), !e10) throw new Error("tgId is required");
    const t39 = await main_default({
      url: this.graphqlEndPoint,
      document: S8,
      variables: {},
      requestHeaders: {
        "x-hasura-tg-id": e10
      }
    });
    return ((n27 = t39 == null ? void 0 : t39.telegramUser) == null ? void 0 : n27.length) > 0;
  }
  /**
   * fetch user wallet address
   *
   * @returns
   */
  async getUserWalletAddress() {
    return this.checkInitialized(), this.checkJWTToken(), (await main_default({
      url: this.graphqlEndPoint,
      document: g10,
      variables: {
        id: this.userId
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    })).walletUserByPk.sub_wallets[0].address;
  }
  /**
   * fetch user wallet address
   *
   * @returns
   */
  async getUserInfo() {
    return this.checkInitialized(), this.checkJWTToken(), (await main_default({
      url: this.graphqlEndPoint,
      document: g10,
      variables: {
        id: this.userId
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    })).walletUserByPk;
  }
  /**
   * Logout
   */
  logout() {
    this.userId = "", this.jwtToken = "";
  }
  /**
   *
   * @param args.redirect_uri
   */
  async startBindGoogle(e10) {
    this.checkInitialized(), this.checkJWTToken();
    const t39 = new URLSearchParams({
      token: this.jwtToken,
      appId: this.appId,
      ...e10
    });
    window.open(`${J3}?${t39.toString()}`, "_blank");
  }
  /**
   *
   * @param args.address keyless address
   * @param args.idToken google jwt
   * @returns
   */
  async bindGoogleAccount(e10) {
    return this.checkInitialized(), this.checkJWTToken(), await main_default({
      url: this.graphqlEndPoint,
      document: A17,
      variables: {
        ...e10
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    });
  }
  /**
   * Simulate Order
   *
   * @param args.payload TransactionPayload
   */
  async simulateOrder(e10) {
    this.checkInitialized(), this.checkJWTToken();
    const t39 = await main_default({
      url: this.graphqlEndPoint,
      document: C8,
      variables: {
        payload: window.btoa(JSON.stringify(e10.payload))
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    });
    return t39 == null ? void 0 : t39.simulateOrder;
  }
  /**
   * Create Order
   *
   * @param args.payload TransactionPayload
   * @returns
   */
  async createOrder(e10) {
    this.checkInitialized(), this.checkJWTToken();
    const t39 = await main_default({
      url: this.graphqlEndPoint,
      document: W10,
      variables: {
        appId: this.appId,
        payload: window.btoa(JSON.stringify(p15(e10.payload)))
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    });
    return t39 == null ? void 0 : t39.createOrder;
  }
  /**
   * Create Order with Code
   *
   * @param args.payload
   * @param args.code
   * @returns
   */
  async createOrderWithCode(e10) {
    this.checkInitialized();
    const t39 = await main_default({
      url: this.graphqlEndPoint,
      document: D10,
      variables: {
        appId: this.appId,
        authCode: e10.code,
        payload: window.btoa(JSON.stringify(p15(e10.payload)))
      },
      requestHeaders: {}
    });
    return t39 == null ? void 0 : t39.createOrderWithCode;
  }
  /**
   * Create Signature
   *
   * @param args.transactionHex AnyRawTransaction.bscToHex().toStringWithoutPrefix()
   * @returns
   */
  async createSignature(e10) {
    this.checkInitialized(), this.checkJWTToken();
    const t39 = await main_default({
      url: this.graphqlEndPoint,
      document: z8,
      variables: {
        appId: this.appId,
        transactionHex: e10.transactionHex
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    });
    return t39 == null ? void 0 : t39.createSignature;
  }
  /**
   * Sign Message
   *
   * @param args.message message to sign
   * @param args.nonce nonce
   * @returns
   */
  async signMessage(e10) {
    this.checkInitialized(), this.checkJWTToken();
    const t39 = await main_default({
      url: this.graphqlEndPoint,
      document: P7,
      variables: {
        appId: this.appId,
        ...e10
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    });
    return t39 == null ? void 0 : t39.createSignMessage;
  }
  /**
   * User interactive
   *
   * @param args.orderId Order ID
   * return bool
   */
  async confirmOrder(e10) {
    this.checkInitialized(), this.checkJWTToken();
    const t39 = await main_default({
      url: this.graphqlEndPoint,
      document: O7,
      variables: {
        orderId: e10.orderId
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    });
    return t39 == null ? void 0 : t39.confirmOrder;
  }
  /**
   * Fetch Order By ID
   *
   * @param args.id order.id
   * @returns
   */
  async fetchOrder(e10) {
    this.checkInitialized(), this.checkJWTToken();
    const t39 = await main_default({
      url: this.graphqlEndPoint,
      document: L8,
      variables: {
        id: e10.id
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    });
    if (!t39.orderByPk) throw new Error("Order not found");
    return {
      ...t39.orderByPk,
      payload: JSON.parse(window.atob(t39.orderByPk.payload))
    };
  }
  /**
   * Wait for order
   *
   * @param args.orderId order.id
   * @returns
   */
  async waitForOrder(e10) {
    let t39 = await this.fetchOrder({
      id: e10.orderId
    }), n27 = 20;
    for (; n27-- > 0 && ![d23.SUCCESS, d23.FAIL, d23.CANCELED].includes(t39.status); )
      await new Promise((o34) => setTimeout(o34, 5e3)), t39 = await this.fetchOrder({
        id: e10.orderId
      });
    if (t39.status === d23.FAIL)
      throw new Error("Order failed");
    return t39;
  }
  /**
   * fetch order list
   *
   * @param args.walletUserId
   * @param args.limit
   * @param args.offset
   *
   * @returns
   */
  async fetchOrderList(e10) {
    this.checkInitialized(), this.checkJWTToken();
    const { limit: t39 = 10, offset: n27 = 0 } = e10 || {}, o34 = await main_default({
      url: this.graphqlEndPoint,
      document: b11,
      variables: {
        walletUserId: this.userId,
        limit: t39,
        offset: n27
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    });
    return {
      data: o34 == null ? void 0 : o34.order.map((u17) => {
        let c16 = {};
        try {
          c16 = JSON.parse(window.atob(u17.payload));
        } catch (w5) {
          console.error(w5);
        }
        return {
          ...u17,
          payload: c16
        };
      }),
      pagination: {
        total: o34 == null ? void 0 : o34.orderAggregate.aggregate.count,
        limit: t39,
        offset: n27
      }
    };
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/dist/index.js
var we = Object.defineProperty;
var ye = (w5, s14, h19) => s14 in w5 ? we(w5, s14, { enumerable: true, configurable: true, writable: true, value: h19 }) : w5[s14] = h19;
var xt2 = (w5, s14, h19) => ye(w5, typeof s14 != "symbol" ? s14 + "" : s14, h19);
var Be = "aptos:devnet";
var Ie = "aptos:testnet";
var Ue = "aptos:localnet";
var ve = "aptos:mainnet";
var Re = [Be, Ie, Ue, ve];
var qr = ((w5) => (w5[w5.Unauthorized = 4100] = "Unauthorized", w5[w5.InternalError = -30001] = "InternalError", w5))(qr || {});
var ee3 = Object.freeze({ 4100: { status: "Unauthorized", message: "The requested method and/or account has not been authorized by the user." }, [-30001]: { status: "Internal error", message: "Something went wrong within the wallet." } });
var ne3 = class he2 extends Error {
  constructor(s14, h19) {
    var x11, d24;
    super(h19 ?? ((x11 = ee3[s14]) == null ? void 0 : x11.message) ?? "Unknown error occurred"), this.code = s14, this.status = ((d24 = ee3[s14]) == null ? void 0 : d24.status) ?? "Unknown error", this.name = "AptosWalletError", Object.setPrototypeOf(this, he2.prototype);
  }
};
var Gt2 = ((w5) => (w5.APPROVED = "Approved", w5.REJECTED = "Rejected", w5))(Gt2 || {});
var Ce = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Se2(w5) {
  return w5 && w5.__esModule && Object.prototype.hasOwnProperty.call(w5, "default") ? w5.default : w5;
}
function Te(w5) {
  if (w5.__esModule) return w5;
  var s14 = w5.default;
  if (typeof s14 == "function") {
    var h19 = function x11() {
      return this instanceof x11 ? Reflect.construct(s14, arguments, this.constructor) : s14.apply(this, arguments);
    };
    h19.prototype = s14.prototype;
  } else h19 = {};
  return Object.defineProperty(h19, "__esModule", { value: true }), Object.keys(w5).forEach(function(x11) {
    var d24 = Object.getOwnPropertyDescriptor(w5, x11);
    Object.defineProperty(h19, x11, d24.get ? d24 : {
      enumerable: true,
      get: function() {
        return w5[x11];
      }
    });
  }), h19;
}
var ue2 = {};
var jr = {};
jr.byteLength = Le;
jr.toByteArray = ke;
jr.fromByteArray = De;
var _t = [];
var jt = [];
var Ne = typeof Uint8Array < "u" ? Uint8Array : Array;
var Jr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (mr = 0, Fe = Jr.length; mr < Fe; ++mr)
  _t[mr] = Jr[mr], jt[Jr.charCodeAt(mr)] = mr;
var mr;
var Fe;
jt[45] = 62;
jt[95] = 63;
function le(w5) {
  var s14 = w5.length;
  if (s14 % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var h19 = w5.indexOf("=");
  h19 === -1 && (h19 = s14);
  var x11 = h19 === s14 ? 0 : 4 - h19 % 4;
  return [h19, x11];
}
function Le(w5) {
  var s14 = le(w5), h19 = s14[0], x11 = s14[1];
  return (h19 + x11) * 3 / 4 - x11;
}
function Oe(w5, s14, h19) {
  return (s14 + h19) * 3 / 4 - h19;
}
function ke(w5) {
  var s14, h19 = le(w5), x11 = h19[0], d24 = h19[1], I7 = new Ne(Oe(w5, x11, d24)), R7 = 0, l20 = d24 > 0 ? x11 - 4 : x11, j7;
  for (j7 = 0; j7 < l20; j7 += 4)
    s14 = jt[w5.charCodeAt(j7)] << 18 | jt[w5.charCodeAt(j7 + 1)] << 12 | jt[w5.charCodeAt(j7 + 2)] << 6 | jt[w5.charCodeAt(j7 + 3)], I7[R7++] = s14 >> 16 & 255, I7[R7++] = s14 >> 8 & 255, I7[R7++] = s14 & 255;
  return d24 === 2 && (s14 = jt[w5.charCodeAt(j7)] << 2 | jt[w5.charCodeAt(j7 + 1)] >> 4, I7[R7++] = s14 & 255), d24 === 1 && (s14 = jt[w5.charCodeAt(j7)] << 10 | jt[w5.charCodeAt(j7 + 1)] << 4 | jt[w5.charCodeAt(j7 + 2)] >> 2, I7[R7++] = s14 >> 8 & 255, I7[R7++] = s14 & 255), I7;
}
function Me(w5) {
  return _t[w5 >> 18 & 63] + _t[w5 >> 12 & 63] + _t[w5 >> 6 & 63] + _t[w5 & 63];
}
function Pe(w5, s14, h19) {
  for (var x11, d24 = [], I7 = s14; I7 < h19; I7 += 3)
    x11 = (w5[I7] << 16 & 16711680) + (w5[I7 + 1] << 8 & 65280) + (w5[I7 + 2] & 255), d24.push(Me(x11));
  return d24.join("");
}
function De(w5) {
  for (var s14, h19 = w5.length, x11 = h19 % 3, d24 = [], I7 = 16383, R7 = 0, l20 = h19 - x11; R7 < l20; R7 += I7)
    d24.push(Pe(w5, R7, R7 + I7 > l20 ? l20 : R7 + I7));
  return x11 === 1 ? (s14 = w5[h19 - 1], d24.push(
    _t[s14 >> 2] + _t[s14 << 4 & 63] + "=="
  )) : x11 === 2 && (s14 = (w5[h19 - 2] << 8) + w5[h19 - 1], d24.push(
    _t[s14 >> 10] + _t[s14 >> 4 & 63] + _t[s14 << 2 & 63] + "="
  )), d24.join("");
}
var Vr = {};
Vr.read = function(w5, s14, h19, x11, d24) {
  var I7, R7, l20 = d24 * 8 - x11 - 1, j7 = (1 << l20) - 1, et2 = j7 >> 1, ct = -7, dt = h19 ? d24 - 1 : 0, vt2 = h19 ? -1 : 1, At = w5[s14 + dt];
  for (dt += vt2, I7 = At & (1 << -ct) - 1, At >>= -ct, ct += l20; ct > 0; I7 = I7 * 256 + w5[s14 + dt], dt += vt2, ct -= 8)
    ;
  for (R7 = I7 & (1 << -ct) - 1, I7 >>= -ct, ct += x11; ct > 0; R7 = R7 * 256 + w5[s14 + dt], dt += vt2, ct -= 8)
    ;
  if (I7 === 0)
    I7 = 1 - et2;
  else {
    if (I7 === j7)
      return R7 ? NaN : (At ? -1 : 1) * (1 / 0);
    R7 = R7 + Math.pow(2, x11), I7 = I7 - et2;
  }
  return (At ? -1 : 1) * R7 * Math.pow(2, I7 - x11);
};
Vr.write = function(w5, s14, h19, x11, d24, I7) {
  var R7, l20, j7, et2 = I7 * 8 - d24 - 1, ct = (1 << et2) - 1, dt = ct >> 1, vt2 = d24 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, At = x11 ? 0 : I7 - 1, Bt2 = x11 ? 1 : -1, Dt2 = s14 < 0 || s14 === 0 && 1 / s14 < 0 ? 1 : 0;
  for (s14 = Math.abs(s14), isNaN(s14) || s14 === 1 / 0 ? (l20 = isNaN(s14) ? 1 : 0, R7 = ct) : (R7 = Math.floor(Math.log(s14) / Math.LN2), s14 * (j7 = Math.pow(2, -R7)) < 1 && (R7--, j7 *= 2), R7 + dt >= 1 ? s14 += vt2 / j7 : s14 += vt2 * Math.pow(2, 1 - dt), s14 * j7 >= 2 && (R7++, j7 /= 2), R7 + dt >= ct ? (l20 = 0, R7 = ct) : R7 + dt >= 1 ? (l20 = (s14 * j7 - 1) * Math.pow(2, d24), R7 = R7 + dt) : (l20 = s14 * Math.pow(2, dt - 1) * Math.pow(2, d24), R7 = 0)); d24 >= 8; w5[h19 + At] = l20 & 255, At += Bt2, l20 /= 256, d24 -= 8)
    ;
  for (R7 = R7 << d24 | l20, et2 += d24; et2 > 0; w5[h19 + At] = R7 & 255, At += Bt2, R7 /= 256, et2 -= 8)
    ;
  w5[h19 + At - Bt2] |= Dt2 * 128;
};
(function(w5) {
  const s14 = jr, h19 = Vr, x11 = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  w5.Buffer = l20, w5.SlowBuffer = nr, w5.INSPECT_MAX_BYTES = 50;
  const d24 = 2147483647;
  w5.kMaxLength = d24, l20.TYPED_ARRAY_SUPPORT = I7(), !l20.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function I7() {
    try {
      const f19 = new Uint8Array(1), r30 = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(r30, Uint8Array.prototype), Object.setPrototypeOf(f19, r30), f19.foo() === 42;
    } catch {
      return false;
    }
  }
  Object.defineProperty(l20.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (l20.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(l20.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (l20.isBuffer(this))
        return this.byteOffset;
    }
  });
  function R7(f19) {
    if (f19 > d24)
      throw new RangeError('The value "' + f19 + '" is invalid for option "size"');
    const r30 = new Uint8Array(f19);
    return Object.setPrototypeOf(r30, l20.prototype), r30;
  }
  function l20(f19, r30, e10) {
    if (typeof f19 == "number") {
      if (typeof r30 == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return dt(f19);
    }
    return j7(f19, r30, e10);
  }
  l20.poolSize = 8192;
  function j7(f19, r30, e10) {
    if (typeof f19 == "string")
      return vt2(f19, r30);
    if (ArrayBuffer.isView(f19))
      return Bt2(f19);
    if (f19 == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof f19
      );
    if (kt(f19, ArrayBuffer) || f19 && kt(f19.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (kt(f19, SharedArrayBuffer) || f19 && kt(f19.buffer, SharedArrayBuffer)))
      return Dt2(f19, r30, e10);
    if (typeof f19 == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const c16 = f19.valueOf && f19.valueOf();
    if (c16 != null && c16 !== f19)
      return l20.from(c16, r30, e10);
    const p16 = er(f19);
    if (p16) return p16;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof f19[Symbol.toPrimitive] == "function")
      return l20.from(f19[Symbol.toPrimitive]("string"), r30, e10);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof f19
    );
  }
  l20.from = function(f19, r30, e10) {
    return j7(f19, r30, e10);
  }, Object.setPrototypeOf(l20.prototype, Uint8Array.prototype), Object.setPrototypeOf(l20, Uint8Array);
  function et2(f19) {
    if (typeof f19 != "number")
      throw new TypeError('"size" argument must be of type number');
    if (f19 < 0)
      throw new RangeError('The value "' + f19 + '" is invalid for option "size"');
  }
  function ct(f19, r30, e10) {
    return et2(f19), f19 <= 0 ? R7(f19) : r30 !== void 0 ? typeof e10 == "string" ? R7(f19).fill(r30, e10) : R7(f19).fill(r30) : R7(f19);
  }
  l20.alloc = function(f19, r30, e10) {
    return ct(f19, r30, e10);
  };
  function dt(f19) {
    return et2(f19), R7(f19 < 0 ? 0 : Kt2(f19) | 0);
  }
  l20.allocUnsafe = function(f19) {
    return dt(f19);
  }, l20.allocUnsafeSlow = function(f19) {
    return dt(f19);
  };
  function vt2(f19, r30) {
    if ((typeof r30 != "string" || r30 === "") && (r30 = "utf8"), !l20.isEncoding(r30))
      throw new TypeError("Unknown encoding: " + r30);
    const e10 = lr(f19, r30) | 0;
    let c16 = R7(e10);
    const p16 = c16.write(f19, r30);
    return p16 !== e10 && (c16 = c16.slice(0, p16)), c16;
  }
  function At(f19) {
    const r30 = f19.length < 0 ? 0 : Kt2(f19.length) | 0, e10 = R7(r30);
    for (let c16 = 0; c16 < r30; c16 += 1)
      e10[c16] = f19[c16] & 255;
    return e10;
  }
  function Bt2(f19) {
    if (kt(f19, Uint8Array)) {
      const r30 = new Uint8Array(f19);
      return Dt2(r30.buffer, r30.byteOffset, r30.byteLength);
    }
    return At(f19);
  }
  function Dt2(f19, r30, e10) {
    if (r30 < 0 || f19.byteLength < r30)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (f19.byteLength < r30 + (e10 || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let c16;
    return r30 === void 0 && e10 === void 0 ? c16 = new Uint8Array(f19) : e10 === void 0 ? c16 = new Uint8Array(f19, r30) : c16 = new Uint8Array(f19, r30, e10), Object.setPrototypeOf(c16, l20.prototype), c16;
  }
  function er(f19) {
    if (l20.isBuffer(f19)) {
      const r30 = Kt2(f19.length) | 0, e10 = R7(r30);
      return e10.length === 0 || f19.copy(e10, 0, 0, r30), e10;
    }
    if (f19.length !== void 0)
      return typeof f19.length != "number" || cr(f19.length) ? R7(0) : At(f19);
    if (f19.type === "Buffer" && Array.isArray(f19.data))
      return At(f19.data);
  }
  function Kt2(f19) {
    if (f19 >= d24)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + d24.toString(16) + " bytes");
    return f19 | 0;
  }
  function nr(f19) {
    return +f19 != f19 && (f19 = 0), l20.alloc(+f19);
  }
  l20.isBuffer = function(r30) {
    return r30 != null && r30._isBuffer === true && r30 !== l20.prototype;
  }, l20.compare = function(r30, e10) {
    if (kt(r30, Uint8Array) && (r30 = l20.from(r30, r30.offset, r30.byteLength)), kt(e10, Uint8Array) && (e10 = l20.from(e10, e10.offset, e10.byteLength)), !l20.isBuffer(r30) || !l20.isBuffer(e10))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (r30 === e10) return 0;
    let c16 = r30.length, p16 = e10.length;
    for (let g11 = 0, b12 = Math.min(c16, p16); g11 < b12; ++g11)
      if (r30[g11] !== e10[g11]) {
        c16 = r30[g11], p16 = e10[g11];
        break;
      }
    return c16 < p16 ? -1 : p16 < c16 ? 1 : 0;
  }, l20.isEncoding = function(r30) {
    switch (String(r30).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  }, l20.concat = function(r30, e10) {
    if (!Array.isArray(r30))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (r30.length === 0)
      return l20.alloc(0);
    let c16;
    if (e10 === void 0)
      for (e10 = 0, c16 = 0; c16 < r30.length; ++c16)
        e10 += r30[c16].length;
    const p16 = l20.allocUnsafe(e10);
    let g11 = 0;
    for (c16 = 0; c16 < r30.length; ++c16) {
      let b12 = r30[c16];
      if (kt(b12, Uint8Array))
        g11 + b12.length > p16.length ? (l20.isBuffer(b12) || (b12 = l20.from(b12)), b12.copy(p16, g11)) : Uint8Array.prototype.set.call(
          p16,
          b12,
          g11
        );
      else if (l20.isBuffer(b12))
        b12.copy(p16, g11);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      g11 += b12.length;
    }
    return p16;
  };
  function lr(f19, r30) {
    if (l20.isBuffer(f19))
      return f19.length;
    if (ArrayBuffer.isView(f19) || kt(f19, ArrayBuffer))
      return f19.byteLength;
    if (typeof f19 != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof f19
      );
    const e10 = f19.length, c16 = arguments.length > 2 && arguments[2] === true;
    if (!c16 && e10 === 0) return 0;
    let p16 = false;
    for (; ; )
      switch (r30) {
        case "ascii":
        case "latin1":
        case "binary":
          return e10;
        case "utf8":
        case "utf-8":
          return Ar(f19).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return e10 * 2;
        case "hex":
          return e10 >>> 1;
        case "base64":
          return ar(f19).length;
        default:
          if (p16)
            return c16 ? -1 : Ar(f19).length;
          r30 = ("" + r30).toLowerCase(), p16 = true;
      }
  }
  l20.byteLength = lr;
  function Vt2(f19, r30, e10) {
    let c16 = false;
    if ((r30 === void 0 || r30 < 0) && (r30 = 0), r30 > this.length || ((e10 === void 0 || e10 > this.length) && (e10 = this.length), e10 <= 0) || (e10 >>>= 0, r30 >>>= 0, e10 <= r30))
      return "";
    for (f19 || (f19 = "utf8"); ; )
      switch (f19) {
        case "hex":
          return $t(this, r30, e10);
        case "utf8":
        case "utf-8":
          return pr(this, r30, e10);
        case "ascii":
          return Ir(this, r30, e10);
        case "latin1":
        case "binary":
          return Xt(this, r30, e10);
        case "base64":
          return Fr(this, r30, e10);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Lr(this, r30, e10);
        default:
          if (c16) throw new TypeError("Unknown encoding: " + f19);
          f19 = (f19 + "").toLowerCase(), c16 = true;
      }
  }
  l20.prototype._isBuffer = true;
  function Rt2(f19, r30, e10) {
    const c16 = f19[r30];
    f19[r30] = f19[e10], f19[e10] = c16;
  }
  l20.prototype.swap16 = function() {
    const r30 = this.length;
    if (r30 % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let e10 = 0; e10 < r30; e10 += 2)
      Rt2(this, e10, e10 + 1);
    return this;
  }, l20.prototype.swap32 = function() {
    const r30 = this.length;
    if (r30 % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let e10 = 0; e10 < r30; e10 += 4)
      Rt2(this, e10, e10 + 3), Rt2(this, e10 + 1, e10 + 2);
    return this;
  }, l20.prototype.swap64 = function() {
    const r30 = this.length;
    if (r30 % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let e10 = 0; e10 < r30; e10 += 8)
      Rt2(this, e10, e10 + 7), Rt2(this, e10 + 1, e10 + 6), Rt2(this, e10 + 2, e10 + 5), Rt2(this, e10 + 3, e10 + 4);
    return this;
  }, l20.prototype.toString = function() {
    const r30 = this.length;
    return r30 === 0 ? "" : arguments.length === 0 ? pr(this, 0, r30) : Vt2.apply(this, arguments);
  }, l20.prototype.toLocaleString = l20.prototype.toString, l20.prototype.equals = function(r30) {
    if (!l20.isBuffer(r30)) throw new TypeError("Argument must be a Buffer");
    return this === r30 ? true : l20.compare(this, r30) === 0;
  }, l20.prototype.inspect = function() {
    let r30 = "";
    const e10 = w5.INSPECT_MAX_BYTES;
    return r30 = this.toString("hex", 0, e10).replace(/(.{2})/g, "$1 ").trim(), this.length > e10 && (r30 += " ... "), "<Buffer " + r30 + ">";
  }, x11 && (l20.prototype[x11] = l20.prototype.inspect), l20.prototype.compare = function(r30, e10, c16, p16, g11) {
    if (kt(r30, Uint8Array) && (r30 = l20.from(r30, r30.offset, r30.byteLength)), !l20.isBuffer(r30))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof r30
      );
    if (e10 === void 0 && (e10 = 0), c16 === void 0 && (c16 = r30 ? r30.length : 0), p16 === void 0 && (p16 = 0), g11 === void 0 && (g11 = this.length), e10 < 0 || c16 > r30.length || p16 < 0 || g11 > this.length)
      throw new RangeError("out of range index");
    if (p16 >= g11 && e10 >= c16)
      return 0;
    if (p16 >= g11)
      return -1;
    if (e10 >= c16)
      return 1;
    if (e10 >>>= 0, c16 >>>= 0, p16 >>>= 0, g11 >>>= 0, this === r30) return 0;
    let b12 = g11 - p16, W11 = c16 - e10;
    const ut = Math.min(b12, W11), ht2 = this.slice(p16, g11), pt = r30.slice(e10, c16);
    for (let ft = 0; ft < ut; ++ft)
      if (ht2[ft] !== pt[ft]) {
        b12 = ht2[ft], W11 = pt[ft];
        break;
      }
    return b12 < W11 ? -1 : W11 < b12 ? 1 : 0;
  };
  function Ft2(f19, r30, e10, c16, p16) {
    if (f19.length === 0) return -1;
    if (typeof e10 == "string" ? (c16 = e10, e10 = 0) : e10 > 2147483647 ? e10 = 2147483647 : e10 < -2147483648 && (e10 = -2147483648), e10 = +e10, cr(e10) && (e10 = p16 ? 0 : f19.length - 1), e10 < 0 && (e10 = f19.length + e10), e10 >= f19.length) {
      if (p16) return -1;
      e10 = f19.length - 1;
    } else if (e10 < 0)
      if (p16) e10 = 0;
      else return -1;
    if (typeof r30 == "string" && (r30 = l20.from(r30, c16)), l20.isBuffer(r30))
      return r30.length === 0 ? -1 : Ht(f19, r30, e10, c16, p16);
    if (typeof r30 == "number")
      return r30 = r30 & 255, typeof Uint8Array.prototype.indexOf == "function" ? p16 ? Uint8Array.prototype.indexOf.call(f19, r30, e10) : Uint8Array.prototype.lastIndexOf.call(f19, r30, e10) : Ht(f19, [r30], e10, c16, p16);
    throw new TypeError("val must be string, number or Buffer");
  }
  function Ht(f19, r30, e10, c16, p16) {
    let g11 = 1, b12 = f19.length, W11 = r30.length;
    if (c16 !== void 0 && (c16 = String(c16).toLowerCase(), c16 === "ucs2" || c16 === "ucs-2" || c16 === "utf16le" || c16 === "utf-16le")) {
      if (f19.length < 2 || r30.length < 2)
        return -1;
      g11 = 2, b12 /= 2, W11 /= 2, e10 /= 2;
    }
    function ut(pt, ft) {
      return g11 === 1 ? pt[ft] : pt.readUInt16BE(ft * g11);
    }
    let ht2;
    if (p16) {
      let pt = -1;
      for (ht2 = e10; ht2 < b12; ht2++)
        if (ut(f19, ht2) === ut(r30, pt === -1 ? 0 : ht2 - pt)) {
          if (pt === -1 && (pt = ht2), ht2 - pt + 1 === W11) return pt * g11;
        } else
          pt !== -1 && (ht2 -= ht2 - pt), pt = -1;
    } else
      for (e10 + W11 > b12 && (e10 = b12 - W11), ht2 = e10; ht2 >= 0; ht2--) {
        let pt = true;
        for (let ft = 0; ft < W11; ft++)
          if (ut(f19, ht2 + ft) !== ut(r30, ft)) {
            pt = false;
            break;
          }
        if (pt) return ht2;
      }
    return -1;
  }
  l20.prototype.includes = function(r30, e10, c16) {
    return this.indexOf(r30, e10, c16) !== -1;
  }, l20.prototype.indexOf = function(r30, e10, c16) {
    return Ft2(this, r30, e10, c16, true);
  }, l20.prototype.lastIndexOf = function(r30, e10, c16) {
    return Ft2(this, r30, e10, c16, false);
  };
  function Mt2(f19, r30, e10, c16) {
    e10 = Number(e10) || 0;
    const p16 = f19.length - e10;
    c16 ? (c16 = Number(c16), c16 > p16 && (c16 = p16)) : c16 = p16;
    const g11 = r30.length;
    c16 > g11 / 2 && (c16 = g11 / 2);
    let b12;
    for (b12 = 0; b12 < c16; ++b12) {
      const W11 = parseInt(r30.substr(b12 * 2, 2), 16);
      if (cr(W11)) return b12;
      f19[e10 + b12] = W11;
    }
    return b12;
  }
  function Nr(f19, r30, e10, c16) {
    return sr(Ar(r30, f19.length - e10), f19, e10, c16);
  }
  function br(f19, r30, e10, c16) {
    return sr(kr(r30), f19, e10, c16);
  }
  function xr(f19, r30, e10, c16) {
    return sr(ar(r30), f19, e10, c16);
  }
  function Br(f19, r30, e10, c16) {
    return sr(Zt(r30, f19.length - e10), f19, e10, c16);
  }
  l20.prototype.write = function(r30, e10, c16, p16) {
    if (e10 === void 0)
      p16 = "utf8", c16 = this.length, e10 = 0;
    else if (c16 === void 0 && typeof e10 == "string")
      p16 = e10, c16 = this.length, e10 = 0;
    else if (isFinite(e10))
      e10 = e10 >>> 0, isFinite(c16) ? (c16 = c16 >>> 0, p16 === void 0 && (p16 = "utf8")) : (p16 = c16, c16 = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const g11 = this.length - e10;
    if ((c16 === void 0 || c16 > g11) && (c16 = g11), r30.length > 0 && (c16 < 0 || e10 < 0) || e10 > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    p16 || (p16 = "utf8");
    let b12 = false;
    for (; ; )
      switch (p16) {
        case "hex":
          return Mt2(this, r30, e10, c16);
        case "utf8":
        case "utf-8":
          return Nr(this, r30, e10, c16);
        case "ascii":
        case "latin1":
        case "binary":
          return br(this, r30, e10, c16);
        case "base64":
          return xr(this, r30, e10, c16);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Br(this, r30, e10, c16);
        default:
          if (b12) throw new TypeError("Unknown encoding: " + p16);
          p16 = ("" + p16).toLowerCase(), b12 = true;
      }
  }, l20.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function Fr(f19, r30, e10) {
    return r30 === 0 && e10 === f19.length ? s14.fromByteArray(f19) : s14.fromByteArray(f19.slice(r30, e10));
  }
  function pr(f19, r30, e10) {
    e10 = Math.min(f19.length, e10);
    const c16 = [];
    let p16 = r30;
    for (; p16 < e10; ) {
      const g11 = f19[p16];
      let b12 = null, W11 = g11 > 239 ? 4 : g11 > 223 ? 3 : g11 > 191 ? 2 : 1;
      if (p16 + W11 <= e10) {
        let ut, ht2, pt, ft;
        switch (W11) {
          case 1:
            g11 < 128 && (b12 = g11);
            break;
          case 2:
            ut = f19[p16 + 1], (ut & 192) === 128 && (ft = (g11 & 31) << 6 | ut & 63, ft > 127 && (b12 = ft));
            break;
          case 3:
            ut = f19[p16 + 1], ht2 = f19[p16 + 2], (ut & 192) === 128 && (ht2 & 192) === 128 && (ft = (g11 & 15) << 12 | (ut & 63) << 6 | ht2 & 63, ft > 2047 && (ft < 55296 || ft > 57343) && (b12 = ft));
            break;
          case 4:
            ut = f19[p16 + 1], ht2 = f19[p16 + 2], pt = f19[p16 + 3], (ut & 192) === 128 && (ht2 & 192) === 128 && (pt & 192) === 128 && (ft = (g11 & 15) << 18 | (ut & 63) << 12 | (ht2 & 63) << 6 | pt & 63, ft > 65535 && ft < 1114112 && (b12 = ft));
        }
      }
      b12 === null ? (b12 = 65533, W11 = 1) : b12 > 65535 && (b12 -= 65536, c16.push(b12 >>> 10 & 1023 | 55296), b12 = 56320 | b12 & 1023), c16.push(b12), p16 += W11;
    }
    return Yt2(c16);
  }
  const dr = 4096;
  function Yt2(f19) {
    const r30 = f19.length;
    if (r30 <= dr)
      return String.fromCharCode.apply(String, f19);
    let e10 = "", c16 = 0;
    for (; c16 < r30; )
      e10 += String.fromCharCode.apply(
        String,
        f19.slice(c16, c16 += dr)
      );
    return e10;
  }
  function Ir(f19, r30, e10) {
    let c16 = "";
    e10 = Math.min(f19.length, e10);
    for (let p16 = r30; p16 < e10; ++p16)
      c16 += String.fromCharCode(f19[p16] & 127);
    return c16;
  }
  function Xt(f19, r30, e10) {
    let c16 = "";
    e10 = Math.min(f19.length, e10);
    for (let p16 = r30; p16 < e10; ++p16)
      c16 += String.fromCharCode(f19[p16]);
    return c16;
  }
  function $t(f19, r30, e10) {
    const c16 = f19.length;
    (!r30 || r30 < 0) && (r30 = 0), (!e10 || e10 < 0 || e10 > c16) && (e10 = c16);
    let p16 = "";
    for (let g11 = r30; g11 < e10; ++g11)
      p16 += wr[f19[g11]];
    return p16;
  }
  function Lr(f19, r30, e10) {
    const c16 = f19.slice(r30, e10);
    let p16 = "";
    for (let g11 = 0; g11 < c16.length - 1; g11 += 2)
      p16 += String.fromCharCode(c16[g11] + c16[g11 + 1] * 256);
    return p16;
  }
  l20.prototype.slice = function(r30, e10) {
    const c16 = this.length;
    r30 = ~~r30, e10 = e10 === void 0 ? c16 : ~~e10, r30 < 0 ? (r30 += c16, r30 < 0 && (r30 = 0)) : r30 > c16 && (r30 = c16), e10 < 0 ? (e10 += c16, e10 < 0 && (e10 = 0)) : e10 > c16 && (e10 = c16), e10 < r30 && (e10 = r30);
    const p16 = this.subarray(r30, e10);
    return Object.setPrototypeOf(p16, l20.prototype), p16;
  };
  function mt(f19, r30, e10) {
    if (f19 % 1 !== 0 || f19 < 0) throw new RangeError("offset is not uint");
    if (f19 + r30 > e10) throw new RangeError("Trying to access beyond buffer length");
  }
  l20.prototype.readUintLE = l20.prototype.readUIntLE = function(r30, e10, c16) {
    r30 = r30 >>> 0, e10 = e10 >>> 0, c16 || mt(r30, e10, this.length);
    let p16 = this[r30], g11 = 1, b12 = 0;
    for (; ++b12 < e10 && (g11 *= 256); )
      p16 += this[r30 + b12] * g11;
    return p16;
  }, l20.prototype.readUintBE = l20.prototype.readUIntBE = function(r30, e10, c16) {
    r30 = r30 >>> 0, e10 = e10 >>> 0, c16 || mt(r30, e10, this.length);
    let p16 = this[r30 + --e10], g11 = 1;
    for (; e10 > 0 && (g11 *= 256); )
      p16 += this[r30 + --e10] * g11;
    return p16;
  }, l20.prototype.readUint8 = l20.prototype.readUInt8 = function(r30, e10) {
    return r30 = r30 >>> 0, e10 || mt(r30, 1, this.length), this[r30];
  }, l20.prototype.readUint16LE = l20.prototype.readUInt16LE = function(r30, e10) {
    return r30 = r30 >>> 0, e10 || mt(r30, 2, this.length), this[r30] | this[r30 + 1] << 8;
  }, l20.prototype.readUint16BE = l20.prototype.readUInt16BE = function(r30, e10) {
    return r30 = r30 >>> 0, e10 || mt(r30, 2, this.length), this[r30] << 8 | this[r30 + 1];
  }, l20.prototype.readUint32LE = l20.prototype.readUInt32LE = function(r30, e10) {
    return r30 = r30 >>> 0, e10 || mt(r30, 4, this.length), (this[r30] | this[r30 + 1] << 8 | this[r30 + 2] << 16) + this[r30 + 3] * 16777216;
  }, l20.prototype.readUint32BE = l20.prototype.readUInt32BE = function(r30, e10) {
    return r30 = r30 >>> 0, e10 || mt(r30, 4, this.length), this[r30] * 16777216 + (this[r30 + 1] << 16 | this[r30 + 2] << 8 | this[r30 + 3]);
  }, l20.prototype.readBigUInt64LE = Qt2(function(r30) {
    r30 = r30 >>> 0, Wt(r30, "offset");
    const e10 = this[r30], c16 = this[r30 + 7];
    (e10 === void 0 || c16 === void 0) && or(r30, this.length - 8);
    const p16 = e10 + this[++r30] * 2 ** 8 + this[++r30] * 2 ** 16 + this[++r30] * 2 ** 24, g11 = this[++r30] + this[++r30] * 2 ** 8 + this[++r30] * 2 ** 16 + c16 * 2 ** 24;
    return BigInt(p16) + (BigInt(g11) << BigInt(32));
  }), l20.prototype.readBigUInt64BE = Qt2(function(r30) {
    r30 = r30 >>> 0, Wt(r30, "offset");
    const e10 = this[r30], c16 = this[r30 + 7];
    (e10 === void 0 || c16 === void 0) && or(r30, this.length - 8);
    const p16 = e10 * 2 ** 24 + this[++r30] * 2 ** 16 + this[++r30] * 2 ** 8 + this[++r30], g11 = this[++r30] * 2 ** 24 + this[++r30] * 2 ** 16 + this[++r30] * 2 ** 8 + c16;
    return (BigInt(p16) << BigInt(32)) + BigInt(g11);
  }), l20.prototype.readIntLE = function(r30, e10, c16) {
    r30 = r30 >>> 0, e10 = e10 >>> 0, c16 || mt(r30, e10, this.length);
    let p16 = this[r30], g11 = 1, b12 = 0;
    for (; ++b12 < e10 && (g11 *= 256); )
      p16 += this[r30 + b12] * g11;
    return g11 *= 128, p16 >= g11 && (p16 -= Math.pow(2, 8 * e10)), p16;
  }, l20.prototype.readIntBE = function(r30, e10, c16) {
    r30 = r30 >>> 0, e10 = e10 >>> 0, c16 || mt(r30, e10, this.length);
    let p16 = e10, g11 = 1, b12 = this[r30 + --p16];
    for (; p16 > 0 && (g11 *= 256); )
      b12 += this[r30 + --p16] * g11;
    return g11 *= 128, b12 >= g11 && (b12 -= Math.pow(2, 8 * e10)), b12;
  }, l20.prototype.readInt8 = function(r30, e10) {
    return r30 = r30 >>> 0, e10 || mt(r30, 1, this.length), this[r30] & 128 ? (255 - this[r30] + 1) * -1 : this[r30];
  }, l20.prototype.readInt16LE = function(r30, e10) {
    r30 = r30 >>> 0, e10 || mt(r30, 2, this.length);
    const c16 = this[r30] | this[r30 + 1] << 8;
    return c16 & 32768 ? c16 | 4294901760 : c16;
  }, l20.prototype.readInt16BE = function(r30, e10) {
    r30 = r30 >>> 0, e10 || mt(r30, 2, this.length);
    const c16 = this[r30 + 1] | this[r30] << 8;
    return c16 & 32768 ? c16 | 4294901760 : c16;
  }, l20.prototype.readInt32LE = function(r30, e10) {
    return r30 = r30 >>> 0, e10 || mt(r30, 4, this.length), this[r30] | this[r30 + 1] << 8 | this[r30 + 2] << 16 | this[r30 + 3] << 24;
  }, l20.prototype.readInt32BE = function(r30, e10) {
    return r30 = r30 >>> 0, e10 || mt(r30, 4, this.length), this[r30] << 24 | this[r30 + 1] << 16 | this[r30 + 2] << 8 | this[r30 + 3];
  }, l20.prototype.readBigInt64LE = Qt2(function(r30) {
    r30 = r30 >>> 0, Wt(r30, "offset");
    const e10 = this[r30], c16 = this[r30 + 7];
    (e10 === void 0 || c16 === void 0) && or(r30, this.length - 8);
    const p16 = this[r30 + 4] + this[r30 + 5] * 2 ** 8 + this[r30 + 6] * 2 ** 16 + (c16 << 24);
    return (BigInt(p16) << BigInt(32)) + BigInt(e10 + this[++r30] * 2 ** 8 + this[++r30] * 2 ** 16 + this[++r30] * 2 ** 24);
  }), l20.prototype.readBigInt64BE = Qt2(function(r30) {
    r30 = r30 >>> 0, Wt(r30, "offset");
    const e10 = this[r30], c16 = this[r30 + 7];
    (e10 === void 0 || c16 === void 0) && or(r30, this.length - 8);
    const p16 = (e10 << 24) + // Overflow
    this[++r30] * 2 ** 16 + this[++r30] * 2 ** 8 + this[++r30];
    return (BigInt(p16) << BigInt(32)) + BigInt(this[++r30] * 2 ** 24 + this[++r30] * 2 ** 16 + this[++r30] * 2 ** 8 + c16);
  }), l20.prototype.readFloatLE = function(r30, e10) {
    return r30 = r30 >>> 0, e10 || mt(r30, 4, this.length), h19.read(this, r30, true, 23, 4);
  }, l20.prototype.readFloatBE = function(r30, e10) {
    return r30 = r30 >>> 0, e10 || mt(r30, 4, this.length), h19.read(this, r30, false, 23, 4);
  }, l20.prototype.readDoubleLE = function(r30, e10) {
    return r30 = r30 >>> 0, e10 || mt(r30, 8, this.length), h19.read(this, r30, true, 52, 8);
  }, l20.prototype.readDoubleBE = function(r30, e10) {
    return r30 = r30 >>> 0, e10 || mt(r30, 8, this.length), h19.read(this, r30, false, 52, 8);
  };
  function It2(f19, r30, e10, c16, p16, g11) {
    if (!l20.isBuffer(f19)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (r30 > p16 || r30 < g11) throw new RangeError('"value" argument is out of bounds');
    if (e10 + c16 > f19.length) throw new RangeError("Index out of range");
  }
  l20.prototype.writeUintLE = l20.prototype.writeUIntLE = function(r30, e10, c16, p16) {
    if (r30 = +r30, e10 = e10 >>> 0, c16 = c16 >>> 0, !p16) {
      const W11 = Math.pow(2, 8 * c16) - 1;
      It2(this, r30, e10, c16, W11, 0);
    }
    let g11 = 1, b12 = 0;
    for (this[e10] = r30 & 255; ++b12 < c16 && (g11 *= 256); )
      this[e10 + b12] = r30 / g11 & 255;
    return e10 + c16;
  }, l20.prototype.writeUintBE = l20.prototype.writeUIntBE = function(r30, e10, c16, p16) {
    if (r30 = +r30, e10 = e10 >>> 0, c16 = c16 >>> 0, !p16) {
      const W11 = Math.pow(2, 8 * c16) - 1;
      It2(this, r30, e10, c16, W11, 0);
    }
    let g11 = c16 - 1, b12 = 1;
    for (this[e10 + g11] = r30 & 255; --g11 >= 0 && (b12 *= 256); )
      this[e10 + g11] = r30 / b12 & 255;
    return e10 + c16;
  }, l20.prototype.writeUint8 = l20.prototype.writeUInt8 = function(r30, e10, c16) {
    return r30 = +r30, e10 = e10 >>> 0, c16 || It2(this, r30, e10, 1, 255, 0), this[e10] = r30 & 255, e10 + 1;
  }, l20.prototype.writeUint16LE = l20.prototype.writeUInt16LE = function(r30, e10, c16) {
    return r30 = +r30, e10 = e10 >>> 0, c16 || It2(this, r30, e10, 2, 65535, 0), this[e10] = r30 & 255, this[e10 + 1] = r30 >>> 8, e10 + 2;
  }, l20.prototype.writeUint16BE = l20.prototype.writeUInt16BE = function(r30, e10, c16) {
    return r30 = +r30, e10 = e10 >>> 0, c16 || It2(this, r30, e10, 2, 65535, 0), this[e10] = r30 >>> 8, this[e10 + 1] = r30 & 255, e10 + 2;
  }, l20.prototype.writeUint32LE = l20.prototype.writeUInt32LE = function(r30, e10, c16) {
    return r30 = +r30, e10 = e10 >>> 0, c16 || It2(this, r30, e10, 4, 4294967295, 0), this[e10 + 3] = r30 >>> 24, this[e10 + 2] = r30 >>> 16, this[e10 + 1] = r30 >>> 8, this[e10] = r30 & 255, e10 + 4;
  }, l20.prototype.writeUint32BE = l20.prototype.writeUInt32BE = function(r30, e10, c16) {
    return r30 = +r30, e10 = e10 >>> 0, c16 || It2(this, r30, e10, 4, 4294967295, 0), this[e10] = r30 >>> 24, this[e10 + 1] = r30 >>> 16, this[e10 + 2] = r30 >>> 8, this[e10 + 3] = r30 & 255, e10 + 4;
  };
  function Lt2(f19, r30, e10, c16, p16) {
    fr(r30, c16, p16, f19, e10, 7);
    let g11 = Number(r30 & BigInt(4294967295));
    f19[e10++] = g11, g11 = g11 >> 8, f19[e10++] = g11, g11 = g11 >> 8, f19[e10++] = g11, g11 = g11 >> 8, f19[e10++] = g11;
    let b12 = Number(r30 >> BigInt(32) & BigInt(4294967295));
    return f19[e10++] = b12, b12 = b12 >> 8, f19[e10++] = b12, b12 = b12 >> 8, f19[e10++] = b12, b12 = b12 >> 8, f19[e10++] = b12, e10;
  }
  function Ot2(f19, r30, e10, c16, p16) {
    fr(r30, c16, p16, f19, e10, 7);
    let g11 = Number(r30 & BigInt(4294967295));
    f19[e10 + 7] = g11, g11 = g11 >> 8, f19[e10 + 6] = g11, g11 = g11 >> 8, f19[e10 + 5] = g11, g11 = g11 >> 8, f19[e10 + 4] = g11;
    let b12 = Number(r30 >> BigInt(32) & BigInt(4294967295));
    return f19[e10 + 3] = b12, b12 = b12 >> 8, f19[e10 + 2] = b12, b12 = b12 >> 8, f19[e10 + 1] = b12, b12 = b12 >> 8, f19[e10] = b12, e10 + 8;
  }
  l20.prototype.writeBigUInt64LE = Qt2(function(r30, e10 = 0) {
    return Lt2(this, r30, e10, BigInt(0), BigInt("0xffffffffffffffff"));
  }), l20.prototype.writeBigUInt64BE = Qt2(function(r30, e10 = 0) {
    return Ot2(this, r30, e10, BigInt(0), BigInt("0xffffffffffffffff"));
  }), l20.prototype.writeIntLE = function(r30, e10, c16, p16) {
    if (r30 = +r30, e10 = e10 >>> 0, !p16) {
      const ut = Math.pow(2, 8 * c16 - 1);
      It2(this, r30, e10, c16, ut - 1, -ut);
    }
    let g11 = 0, b12 = 1, W11 = 0;
    for (this[e10] = r30 & 255; ++g11 < c16 && (b12 *= 256); )
      r30 < 0 && W11 === 0 && this[e10 + g11 - 1] !== 0 && (W11 = 1), this[e10 + g11] = (r30 / b12 >> 0) - W11 & 255;
    return e10 + c16;
  }, l20.prototype.writeIntBE = function(r30, e10, c16, p16) {
    if (r30 = +r30, e10 = e10 >>> 0, !p16) {
      const ut = Math.pow(2, 8 * c16 - 1);
      It2(this, r30, e10, c16, ut - 1, -ut);
    }
    let g11 = c16 - 1, b12 = 1, W11 = 0;
    for (this[e10 + g11] = r30 & 255; --g11 >= 0 && (b12 *= 256); )
      r30 < 0 && W11 === 0 && this[e10 + g11 + 1] !== 0 && (W11 = 1), this[e10 + g11] = (r30 / b12 >> 0) - W11 & 255;
    return e10 + c16;
  }, l20.prototype.writeInt8 = function(r30, e10, c16) {
    return r30 = +r30, e10 = e10 >>> 0, c16 || It2(this, r30, e10, 1, 127, -128), r30 < 0 && (r30 = 255 + r30 + 1), this[e10] = r30 & 255, e10 + 1;
  }, l20.prototype.writeInt16LE = function(r30, e10, c16) {
    return r30 = +r30, e10 = e10 >>> 0, c16 || It2(this, r30, e10, 2, 32767, -32768), this[e10] = r30 & 255, this[e10 + 1] = r30 >>> 8, e10 + 2;
  }, l20.prototype.writeInt16BE = function(r30, e10, c16) {
    return r30 = +r30, e10 = e10 >>> 0, c16 || It2(this, r30, e10, 2, 32767, -32768), this[e10] = r30 >>> 8, this[e10 + 1] = r30 & 255, e10 + 2;
  }, l20.prototype.writeInt32LE = function(r30, e10, c16) {
    return r30 = +r30, e10 = e10 >>> 0, c16 || It2(this, r30, e10, 4, 2147483647, -2147483648), this[e10] = r30 & 255, this[e10 + 1] = r30 >>> 8, this[e10 + 2] = r30 >>> 16, this[e10 + 3] = r30 >>> 24, e10 + 4;
  }, l20.prototype.writeInt32BE = function(r30, e10, c16) {
    return r30 = +r30, e10 = e10 >>> 0, c16 || It2(this, r30, e10, 4, 2147483647, -2147483648), r30 < 0 && (r30 = 4294967295 + r30 + 1), this[e10] = r30 >>> 24, this[e10 + 1] = r30 >>> 16, this[e10 + 2] = r30 >>> 8, this[e10 + 3] = r30 & 255, e10 + 4;
  }, l20.prototype.writeBigInt64LE = Qt2(function(r30, e10 = 0) {
    return Lt2(this, r30, e10, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), l20.prototype.writeBigInt64BE = Qt2(function(r30, e10 = 0) {
    return Ot2(this, r30, e10, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function rt(f19, r30, e10, c16, p16, g11) {
    if (e10 + c16 > f19.length) throw new RangeError("Index out of range");
    if (e10 < 0) throw new RangeError("Index out of range");
  }
  function Nt2(f19, r30, e10, c16, p16) {
    return r30 = +r30, e10 = e10 >>> 0, p16 || rt(f19, r30, e10, 4), h19.write(f19, r30, e10, c16, 23, 4), e10 + 4;
  }
  l20.prototype.writeFloatLE = function(r30, e10, c16) {
    return Nt2(this, r30, e10, true, c16);
  }, l20.prototype.writeFloatBE = function(r30, e10, c16) {
    return Nt2(this, r30, e10, false, c16);
  };
  function Ur(f19, r30, e10, c16, p16) {
    return r30 = +r30, e10 = e10 >>> 0, p16 || rt(f19, r30, e10, 8), h19.write(f19, r30, e10, c16, 52, 8), e10 + 8;
  }
  l20.prototype.writeDoubleLE = function(r30, e10, c16) {
    return Ur(this, r30, e10, true, c16);
  }, l20.prototype.writeDoubleBE = function(r30, e10, c16) {
    return Ur(this, r30, e10, false, c16);
  }, l20.prototype.copy = function(r30, e10, c16, p16) {
    if (!l20.isBuffer(r30)) throw new TypeError("argument should be a Buffer");
    if (c16 || (c16 = 0), !p16 && p16 !== 0 && (p16 = this.length), e10 >= r30.length && (e10 = r30.length), e10 || (e10 = 0), p16 > 0 && p16 < c16 && (p16 = c16), p16 === c16 || r30.length === 0 || this.length === 0) return 0;
    if (e10 < 0)
      throw new RangeError("targetStart out of bounds");
    if (c16 < 0 || c16 >= this.length) throw new RangeError("Index out of range");
    if (p16 < 0) throw new RangeError("sourceEnd out of bounds");
    p16 > this.length && (p16 = this.length), r30.length - e10 < p16 - c16 && (p16 = r30.length - e10 + c16);
    const g11 = p16 - c16;
    return this === r30 && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(e10, c16, p16) : Uint8Array.prototype.set.call(
      r30,
      this.subarray(c16, p16),
      e10
    ), g11;
  }, l20.prototype.fill = function(r30, e10, c16, p16) {
    if (typeof r30 == "string") {
      if (typeof e10 == "string" ? (p16 = e10, e10 = 0, c16 = this.length) : typeof c16 == "string" && (p16 = c16, c16 = this.length), p16 !== void 0 && typeof p16 != "string")
        throw new TypeError("encoding must be a string");
      if (typeof p16 == "string" && !l20.isEncoding(p16))
        throw new TypeError("Unknown encoding: " + p16);
      if (r30.length === 1) {
        const b12 = r30.charCodeAt(0);
        (p16 === "utf8" && b12 < 128 || p16 === "latin1") && (r30 = b12);
      }
    } else typeof r30 == "number" ? r30 = r30 & 255 : typeof r30 == "boolean" && (r30 = Number(r30));
    if (e10 < 0 || this.length < e10 || this.length < c16)
      throw new RangeError("Out of range index");
    if (c16 <= e10)
      return this;
    e10 = e10 >>> 0, c16 = c16 === void 0 ? this.length : c16 >>> 0, r30 || (r30 = 0);
    let g11;
    if (typeof r30 == "number")
      for (g11 = e10; g11 < c16; ++g11)
        this[g11] = r30;
    else {
      const b12 = l20.isBuffer(r30) ? r30 : l20.from(r30, p16), W11 = b12.length;
      if (W11 === 0)
        throw new TypeError('The value "' + r30 + '" is invalid for argument "value"');
      for (g11 = 0; g11 < c16 - e10; ++g11)
        this[g11 + e10] = b12[g11 % W11];
    }
    return this;
  };
  const Jt = {};
  function tr(f19, r30, e10) {
    Jt[f19] = class extends e10 {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: r30.apply(this, arguments),
          writable: true,
          configurable: true
        }), this.name = `${this.name} [${f19}]`, this.stack, delete this.name;
      }
      get code() {
        return f19;
      }
      set code(p16) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value: p16,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${f19}]: ${this.message}`;
      }
    };
  }
  tr(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(f19) {
      return f19 ? `${f19} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), tr(
    "ERR_INVALID_ARG_TYPE",
    function(f19, r30) {
      return `The "${f19}" argument must be of type number. Received type ${typeof r30}`;
    },
    TypeError
  ), tr(
    "ERR_OUT_OF_RANGE",
    function(f19, r30, e10) {
      let c16 = `The value of "${f19}" is out of range.`, p16 = e10;
      return Number.isInteger(e10) && Math.abs(e10) > 2 ** 32 ? p16 = ir(String(e10)) : typeof e10 == "bigint" && (p16 = String(e10), (e10 > BigInt(2) ** BigInt(32) || e10 < -(BigInt(2) ** BigInt(32))) && (p16 = ir(p16)), p16 += "n"), c16 += ` It must be ${r30}. Received ${p16}`, c16;
    },
    RangeError
  );
  function ir(f19) {
    let r30 = "", e10 = f19.length;
    const c16 = f19[0] === "-" ? 1 : 0;
    for (; e10 >= c16 + 4; e10 -= 3)
      r30 = `_${f19.slice(e10 - 3, e10)}${r30}`;
    return `${f19.slice(0, e10)}${r30}`;
  }
  function Or(f19, r30, e10) {
    Wt(r30, "offset"), (f19[r30] === void 0 || f19[r30 + e10] === void 0) && or(r30, f19.length - (e10 + 1));
  }
  function fr(f19, r30, e10, c16, p16, g11) {
    if (f19 > e10 || f19 < r30) {
      const b12 = typeof r30 == "bigint" ? "n" : "";
      let W11;
      throw r30 === 0 || r30 === BigInt(0) ? W11 = `>= 0${b12} and < 2${b12} ** ${(g11 + 1) * 8}${b12}` : W11 = `>= -(2${b12} ** ${(g11 + 1) * 8 - 1}${b12}) and < 2 ** ${(g11 + 1) * 8 - 1}${b12}`, new Jt.ERR_OUT_OF_RANGE("value", W11, f19);
    }
    Or(c16, p16, g11);
  }
  function Wt(f19, r30) {
    if (typeof f19 != "number")
      throw new Jt.ERR_INVALID_ARG_TYPE(r30, "number", f19);
  }
  function or(f19, r30, e10) {
    throw Math.floor(f19) !== f19 ? (Wt(f19, e10), new Jt.ERR_OUT_OF_RANGE("offset", "an integer", f19)) : r30 < 0 ? new Jt.ERR_BUFFER_OUT_OF_BOUNDS() : new Jt.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${r30}`,
      f19
    );
  }
  const zr = /[^+/0-9A-Za-z-_]/g;
  function Kr(f19) {
    if (f19 = f19.split("=")[0], f19 = f19.trim().replace(zr, ""), f19.length < 2) return "";
    for (; f19.length % 4 !== 0; )
      f19 = f19 + "=";
    return f19;
  }
  function Ar(f19, r30) {
    r30 = r30 || 1 / 0;
    let e10;
    const c16 = f19.length;
    let p16 = null;
    const g11 = [];
    for (let b12 = 0; b12 < c16; ++b12) {
      if (e10 = f19.charCodeAt(b12), e10 > 55295 && e10 < 57344) {
        if (!p16) {
          if (e10 > 56319) {
            (r30 -= 3) > -1 && g11.push(239, 191, 189);
            continue;
          } else if (b12 + 1 === c16) {
            (r30 -= 3) > -1 && g11.push(239, 191, 189);
            continue;
          }
          p16 = e10;
          continue;
        }
        if (e10 < 56320) {
          (r30 -= 3) > -1 && g11.push(239, 191, 189), p16 = e10;
          continue;
        }
        e10 = (p16 - 55296 << 10 | e10 - 56320) + 65536;
      } else p16 && (r30 -= 3) > -1 && g11.push(239, 191, 189);
      if (p16 = null, e10 < 128) {
        if ((r30 -= 1) < 0) break;
        g11.push(e10);
      } else if (e10 < 2048) {
        if ((r30 -= 2) < 0) break;
        g11.push(
          e10 >> 6 | 192,
          e10 & 63 | 128
        );
      } else if (e10 < 65536) {
        if ((r30 -= 3) < 0) break;
        g11.push(
          e10 >> 12 | 224,
          e10 >> 6 & 63 | 128,
          e10 & 63 | 128
        );
      } else if (e10 < 1114112) {
        if ((r30 -= 4) < 0) break;
        g11.push(
          e10 >> 18 | 240,
          e10 >> 12 & 63 | 128,
          e10 >> 6 & 63 | 128,
          e10 & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return g11;
  }
  function kr(f19) {
    const r30 = [];
    for (let e10 = 0; e10 < f19.length; ++e10)
      r30.push(f19.charCodeAt(e10) & 255);
    return r30;
  }
  function Zt(f19, r30) {
    let e10, c16, p16;
    const g11 = [];
    for (let b12 = 0; b12 < f19.length && !((r30 -= 2) < 0); ++b12)
      e10 = f19.charCodeAt(b12), c16 = e10 >> 8, p16 = e10 % 256, g11.push(p16), g11.push(c16);
    return g11;
  }
  function ar(f19) {
    return s14.toByteArray(Kr(f19));
  }
  function sr(f19, r30, e10, c16) {
    let p16;
    for (p16 = 0; p16 < c16 && !(p16 + e10 >= r30.length || p16 >= f19.length); ++p16)
      r30[p16 + e10] = f19[p16];
    return p16;
  }
  function kt(f19, r30) {
    return f19 instanceof r30 || f19 != null && f19.constructor != null && f19.constructor.name != null && f19.constructor.name === r30.name;
  }
  function cr(f19) {
    return f19 !== f19;
  }
  const wr = function() {
    const f19 = "0123456789abcdef", r30 = new Array(256);
    for (let e10 = 0; e10 < 16; ++e10) {
      const c16 = e10 * 16;
      for (let p16 = 0; p16 < 16; ++p16)
        r30[c16 + p16] = f19[e10] + f19[p16];
    }
    return r30;
  }();
  function Qt2(f19) {
    return typeof BigInt > "u" ? yr : f19;
  }
  function yr() {
    throw new Error("BigInt not supported");
  }
})(ue2);
var Qe = "https://t.me/mizuwallet_bot/mizuwallet";
var je = "https://t.me/mizuwallet_bot/mizuwallet_testnet";
var ze = (w5) => w5 === e8.TESTNET ? je : Qe;
var Sr = {
  CONNECT: "[Mizu Wallet Connection] ",
  TRANSACTION: "[Mizu Wallet Transaction] "
};
var Ke = "07418a1b-9574-4449-bd34-2146db60b05c";
var Ye = "0c460c1a-5175-4383-b1c2-35b934f5aa71";
var He = (w5) => w5 === e8.TESTNET ? Ye : Ke;
var _e = "Mizu Wallet";
var Je = "https://mizu.io";
var We = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAAAXNSR0IArs4c6QAAAIRlWElmTU0AKgAAAAgABQESAAMAAAABAAEAAAEaAAUAAAABAAAASgEbAAUAAAABAAAAUgEoAAMAAAABAAIAAIdpAAQAAAABAAAAWgAAAAAAAABIAAAAAQAAAEgAAAABAAOgAQADAAAAAQABAACgAgAEAAAAAQAAAQCgAwAEAAAAAQAAAQAAAAAAlNB3SgAAAAlwSFlzAAALEwAACxMBAJqcGAAAAVlpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDYuMC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KGV7hBwAALERJREFUeAHtnXm0XUd15rc1z7OeJmu0ZEs2HnFs4yGriWmbxstM6ZA0fyQNTvdqOgSymIIXEBscOg6GhKzQCc2CBuIE0pB0O2YycQx4CBgIOAFPYMlPsgZrtObZRv376px6vnrS0xt0qu559+xa77w7V9X+qvZXu3btqnOG3XTsmHlyBByBRiIwopFSu9COgCMQEHAC8I7gCDQYASeABje+i+4IOAF4H3AEGoyAE0CDG99FdwScALwPOAINRsAJoMGN76I7Ak4A3gccgQYj4ATQ4MZ30R0BJwDvA45AgxFwAmhw47vojoATgPcBR6DBCDgBNLjxXXRHwAnA+4Aj0GAEnAAa3PguuiPgBOB9wBFoMAJOAA1ufBfdEXAC8D7gCDQYASeABje+i+4IOAF4H3AEGoyAE0CDG99FdwScALwPOAINRsAJoMGN76I7Ak4A3gccgQYj4ATQ4MZ30R0BJwDvA45AgxFwAmhw47vojoATgPcBR6DBCDgBNLjxXXRHwAnA+4Aj0GAEnAAa3PguuiPgBOB9wBFoMAJOAA1ufBfdEXAC8D7gCDQYASeABje+i+4IOAF4H3AEGoyAE0CDG99FdwScALwPOAINRsAJoMGN76I7Ak4A3gccgQYj4ATQ4MZ30R0BJwDvA45AgxFwAmhw47vojoATgPcBR6DBCDgBNLjxXXRHwAnA+4Aj0GAEnAAa3PguuiPgBOB9wBFoMAJOAA1ufBfdEXAC8D7gCDQYASeABje+i+4IOAF4H3AEGoyAE0CDG99FdwScALwPOAINRsAJoMGN76I7Ak4A3gccgQYj4ATQ4MZ30R0BJwDvA45AgxFwAmhw47vojoATgPcBR6DBCDgBNLjxXXRHwAnA+4Aj0GAEnAAa3PguuiPgBOB9wBFoMAJOAA1ufBfdEXAC8D7gCDQYASeABje+i+4IOAF4H3AEGoyAE0CDG99FdwScALwPOAINRsAJoMGN76I7Ak4A3gccgQYj4ATQ4MZ30R2BUQ5BXgRGnmE2G9qdKOrlOX/HpWPHzPg7/tIbpCM8HuV6nud6PMT1i/CJ/3MEhoaAE8DQcBvSr6TsL6C9m3fz5Lkyi9G9siqJITCDnsfXetR31WLlNYvHcbw/hivkzUciif2wwn4RBZcnR+BUCDgBnAqdCj8bi4YeRvl/5UyzX3212Yp5KO5IFPZIUcgIlFij/8GjvPcC3+XxIJ/pOnIYZeb11r2Qxz6z3Vzref5vu/gtz+0Ql8wCEcRYrvFmE8aZnUnryuI4TL57IIW9XM4J4OOpBwEngB4o0j7RyDwChX9km9mcx8xmTIQMLjPrmja4co9CDsdQZBHDvgPoPsq/DYtiJ9d68l632ewnm8y+utFsLY8GedgErslmCyAGWQwH+P12Lk0jPDUbgTPsJo07nrIhILQPcm3hmmL28f9k9luvMps2iUEc5R4hW75MZ7Q811u9X8fv9X48hLWwGwthyw6zbkjg0W6zB35u9o+r+aamH5DBqKlmi8cUlsE2yvXUTAScANrQ7hNR7C5sr+cZhdevN7t4ldlfv9Xs3KXFNGAgih5pO7B3pHDyZYA/0bPIW7IYNm01ewIyeOhRsz/+MW8+wzXdbBmXrILNTgQA0qzkBNDm9l7BKPyU5vGMzA9+0OzqiwZOAn1VPZJCfBSh9CaVbfgPHnnS7EsPmH3mQXLCZ3DWLKYGkMBuyICfuL+gL4A76H0ngDY2ZlSyOfgGpG1bmLff/4dmv3wxy3sooRyDVSWRQbAaeNKa7wu8fpSpwee/afanX+NLXWZL8Rl0M43w1PkIOAHUpI2nouzy1T3LnP3HH2NacE71JNAqqshAVysZfJ+pwds+b/YDLIPlrFZ0s7IggvDUuQg4AdSobWdhCWzXyItp8OxHzObOhASkpDIVEqZWa2MvDspP/T+zd91pNn9R4STc5ySQEP32Zl2hkdleQTqhdM2/F2sdH3/AbX+VR/mFW7QCRASTWSp85xtZRnx/4TTUOvEU7yWCqSOTN22NmlUD/Tq89SvnmP0F8/Gv/3NROSlmjiQiiFODG65iteBWs13bg3/Qxie2QnLI52WciIATwImYtO0dWdry1ndDAqMXm934VwT54K2PipmjYnHFQKRz1YXED/wBEYj4JbrkqCQ5DxQ4dMp/J4CataRIQKG7i1getA1md32nqGDw4BdPs/wX6YgErmFF4v/8HpbJWsKXqZPqdzpJocnzIJPl5NV6nUUY8zKupVxLuBZzLWL+oXBm+UamUZ8J/NY77Omgf+Jv3Ql4IiZtf0ejrBx/BAfabvwCz95ROARFAr3X81NWtrW8mz9pdvs/mi1kmXA9qwNDSZLrmIKN8HEYYcsmqwJFDykIzbP4KE3XczkhRIZ65LuzeRzP70bzmWZGCrHexxPtc9BrT4NDwAlgcHhl/bZGxKfXmv3v/272phuLETk67HJVJK5CbNkJCb0HYkLLRqOcUrzBWAPyIRyEOF61yOy1l5itWliQwQH2KoxCobVRSiHMug4wBTrAHofnedx7gIBFCGP7HvY28PgT7aIkzDmEU4skcFoa+ypmEsg0DXIQN4k0dzkbgET/yQmgf4za9o2oNKvYM/C9/2E2lY7eOirnqpimAiKef7gf5f0jTPdlZqtRzsEkDebS18ko+39A+X/9GrN/fwVmvVY9+kna1vwLNDtugNJuyK0QwUasiJ+tN/uXdWbf4ApWhSyFaVgqYDWKArfwuwP8XuUPhrD6qVLHfOwEUPOm1Dx59Rqzb3/Y7N9d2h4rIJKORuvrP8DqADsOJzPiyuweUmJUt01cS83u/W9mr7i8ILZobUhRpbAx9TftOQQZ7cA6WEee//oUm55+ClkR1BSsBFZUlmMlbJB14UQQIe15HGmX3Hprzyt/UjsE0P8wx9XhH9ddhmK0akam2qpMWQFjNAdH8b94DyPsDLYgD5EAJiDUkrmY6vz+818mr+lml6ws/B4SSf4PlRmvKKaISEkPeh5fjwabKYz4C8nzl841e93VZr95ldlFWBprIIWf/ZypAQ6VRdRfZXp6EQG3AF7EopbPsJhtCsqwk1FuEyHC82YVHT83EUQrYCfz77N/nzn5Ic4e0dy9VMqhgKddkUsgg8c4H+HP8HO87Q1DyaUgBLFCrGMrNrv3m33rB2Zv/BIWwLNYA/Pwq2ANOA8UWGta5qnGCLxA3WZqXrsZBxjmrVIc+YpXef5LqVTudM4SuJkR1ggQCpuYTqN4HVv2GNOK884ze/snzf7uviIzWRuDSVQtWAvyU4R68lrTCeUjv8nrXs7Kxe1mH3wN06lunJkQl8jHU+GXcRxqjsBBOrM83d9lpFRqHeGKd/L8j8Sj3YoGM42qSImegASWnW32ax9nZ+IaOiWKPFgSaEVA1dI0Qvmozspr1lSzP3iT2d3vK0KcmQ3YpIrq31r2cHvuFsAwaLHnZAbQgf8ex5ZM2jga5656JJ7lCzHdl2JKMw0YV4ESacAPG46Q8d2fxVRnuhOV93RlVJ0DoYhEuW68hnMXbilCnCfzWVUkdrr1bNfvnQDahfwgypUFsIjlsseeYSaA6a2k/pw7RQLQ8WVvwNmm9fjpFfWgrZDcOSx33sN8/WsPFZJFi6MKOWURHOOSNaBDV77xHgKsWEJcrOkViY8amSpqvkZil1VoRb4Zo/86HFkhtYMBKDia5pcs58U+4nAq6kESby3OOTuToKe/49R0yKUqK4BcQ1IZMc9XvozzGP8zqwQbLIQftwnOomJt/F9R8+WVQMqg+Zu84/GaWr6neHEdwS3TblgK1weUmgUoFPbpjeUXkK+dadkCSq8QYCmgVhRWsMy4dw2bkH5USFelFdAbr5tebXYFy4/dxCVMRpY2Q9q7ellelwZQlrIqKUQVPspIcZR5YuiArZ1QLajXPGpuqkZV2Ko2oIg09JHmm1ImHYmtgzAVJaaw1rqnw6o4yrFmc1FTmbTtSHEaMJflSB0oug8wVZWqINxK5J6OJfv0fWavvAqRIT3lXaW4kkGWzCQChD7862bXvo8VjWWnEdhE/YZrGlYEoMrqJN1LCUI5h86nm2VswSxWyKcUfR+dZzfXZq6tEMQhvMvhXHyRhS51LvUkuYBZfw5x5MyttfNMFoM+3kuHVhy59K1OSUSl+j4BAeimIWMTKMZg5J3OfP1yAm++j09iIlhqSa+KpECdZfgYvvaI2ZPdBPOwOiArIBJPFWUojzM0GpC05fk1VxA5uIYI4gnN20MwrAhAI7mUdBJK+8s03CsJIV1EqOcRFOIFFFdrvyIIna+vG2iIIH7Bo7zKmlMePEhADY8b6bRbiCV/lPn0P2xhXs1lmIGBFFjnnsWSmzaWSOnknKrDLbYUxiri+g511waZsXjMKx8aybK/FBVRdx66YB4EsJF4fp7vB6eqUjiHkLZ+ABIQAYizq07KU1aAiPSma+kHDxNvgRXQtE1Ew4oANEccTRDHdzZxfY7Qz2+a3fFas9f/CoMjDTnYdAQ22YMFsX0ngSKQwJPr2HTzc0Jdn+S9beTGSDQZS6OLvJ/luyIEdRzpYu4k2efRWs9S1wMQmZYF25U0ImsKsgLyVbz9eDbfVJmek/kF7ndBAL9N+2rDUBIrQI1JulQrGpDZdtqY7hWmiHq/Cak0hIaPqJq7j8XkXMA8cT2d7zdu5/owwR1SWJIsAXWW1itGhYnxdekzpTEolAJEVi5hZ9rlZr/7BmLTbybfPzH7p9vM3n99MSVY043S0Tm0Pbf8afh97n+6CagUTrvhlNpVl4ifwpI1tZJlVmXSJqNFmOPfhozXby5yTiFrtGbkz/idC8F1N1aAGKBBadgRgNpGo+FGFFLWwKqVZv/3pxDCBzDl6SwjeU8dVI0brxgVpiUgXbHhlZe+GwlCz5XnmZDLtZdxMOd/ZcT9KDfPeBd37YEonl7HZ3w+s0St4n6v6pwyhaCVcjoTvkh925nmz6R0CBdIKk9x2VPLdCElklUDgtrxSlkBTA8nDUuNKCAayv9hLa7m5k8QjbZMI9E+s/M/hAOQub2UXEo9kCQyiAQRiSGQQmkp6GjuX3sFYbhYGZ95C9tKd7D1lDK1sywQzUAKqeg7gXBQuCNYAXVIk5giGdYYVao8Bb8Lea8uCSC2TeUFlRmevZAnuRk9lTCDyHdYE4B0XB3jaUbFZTjv9jINeMdfoiBYB1JqKehQUiAFkNFjJANtKnnzjWaP38GW09mcUoMzbikdNCcJBEVjuN3K6ThtTaWizMYq0tLkEciy6hT2PzANeHJjQeapCCDmO482Nch+j/pO1cLUOL9hL2srCazCdP/i/WZ/c0+B+BD1/7jmUgeJ0WMyF1ctJVz1FraXEk7aDQksyUgCQc/wWzyHtaMUO2/xKt//Uv9tDLJrk5JiFKruSAclLOTyONO6sJzLy6ES+kCQmcYAcs1cHIEMJgoma0qqut3aglskAe0qW4SCvvlzRcScrICBTgX6q3gkghfomDNYA/9f7+R4rPMIX92J/yGTczAoAC12hClIHdLE8YVvRN5zRV9WmTTLmQCu9zOl23OgypyPzyuS6DhWGlbN4TOwrSq8+fiS6vmqIwhA0MbRXhs+NCn9/DcKwCvulzYSxEQCkxidPvk2ymAJbCPEk2NraZwC6PZdbU0lqONRmmWQoYIzxlQMtHwA0+VdxDN/qCS82MZVyy5i1UrG8kgAFctSdX2rzK9jCCCCoiOrF9OQH/o6R0GtK8zkqqyAWEYkgTlEJD78Vt7dRqwApnnqpCVQBQNtZQogmeLolbrc3vlH/dDUaDJTABFAspUAlF/BWylTJJbZtKcRPCbLsSmp4whADRcalOHyrgeKZkzRniIBjRyXv8Tsg69jysFcVTexSJmCZxxN24UFICuk3UlLpovkCFRocgKQQ3wB5KJgrZCippYvK3so810gAqC8xM1YWbWryKgjCWATyj8er+57IYCtzNE1UqZwIMX++Fs30BRMCY6ilCkBDTpPAfsYFeWQbGeKeM6aRC0ggLBuX3GFgoVDWx5lipUjTZA1g/a3GdocovaUkbK/9hSS+4lGygXyUD9j9uMnitJjh62yLnGpcfFcs1tewf4CVgUUrpsqBcKBzF5glIpOj0hCqcrsL98xOAKlMSmmI2HqRg/dFS2A/ioz1M9L62UGKwGKawiW1lDzGma/60gCUBtom6rhoLrvkaJFNF9NkSKx3PAycmdkTmEKx3pHhdCdc3qmAG1igFjsFNbq5XRNMAMoRmKmGc+VBJCCZIRtrLu2B0dLTu83ISVSi/ZDt4NRaQQE8NF/Y213V1GfqKxV1i52ypVLCBBahS+A+XmqE2c18GuOsQUCULBTW1PJADM1BYAAUjgBQ3sh70GINUcaiYPVIDSdE1H1/oYc9R9KGR1LAPKYK0hHd9hdu6mAJhUBKN/JdJzXX0g5kM2MFNpA1jJqNFw9wZz7aLsJQHUhTcT3oelIJMLwZkX/AsfQQ7WtO0eSLBcyDdC9BVnhbETqWAJQ64UOxL+n1qdty0gsF5xFOVgAVa+Jx9rLOTVBLYZC9EwB4odtegyjJoQXMaiyGqH9ILzkBFDOAXT60IJyWTOFU7NKbKrKq6MJIKybw+prNhZwpRilQs5lB1oyn1fMI1M5kaRk4RhuRv+6EEAIB6YXBWWtqleW+QSLB3LZU64CpGq/svlMpwSNk0Wj6WPFstQ1u46WU3M5KeRjTAF0QlDqDtQ1nfLmsC2ZETqFFSAlQx/CXOCYZGtnKrUmTAFY+Qin+FRcn5BnSQA5xJWjeBr9Jfg0IitULFPdsutoAgjHaDGZe2wbjp3SkZTCVI1uZEXF3QgB6BxC3dq76hQIQPlCZknkGEKFdTybWCmM1kP4/al+EvKkhx6EUHPIq7Mlu+TUxMKS+6gJqeMJYDaj00+fY6twwrXkqOs6X+5cYgK0HJhqR1koCybIoRCnUoAo8yjFPXBVHW6tsoOMFHQYhUyRf6t8Ec/psgAoryl3DOpoApDZOE42M8ofl5JSzFXVkWIHmq/DSbAAUk0BwjSmRhZAOF0X4pO5HklBeFSRQluRqZY8I75V5HuqPEZp6M8x3zhVJTJ+1tEEIBzjMVo74oaSRAwQO+j8ckNJqnXkHiVLJMdg+56OYJO9rENBqt5EEwkgODwzyTsaMku1rDlYbHN8v+MJQP1Ty2Y6EjxHmqnNMXTWVMD26EEPE+SQqu8ywhQAAtiTQ+a+q1HZJzoXIIQ2V5ZjvTNK1U9rI3VQGP7lOkRjotaRZRInQiDovTKviZk6CobV0WgapQPZVih3EBGBFfQULawKsz8uq5j/+HIKUBN+Pa6OKV50PAGEToSTalt5jFYKEEOeZY+ZVW4oCTEIKQqrWc8cC7Znlkojf2CVqR2ihlUNOk07yq4Su4Hm1QwCQMp4rFTqWIDRMiEJC9bW4BSdKOSJRaO4BqVg4RRP8/4vhZMFMKmcN1ft9wiyUU5r0FNqeSeWU4Cq/Rl5G2fgpXU8AQTTDikPl9FkA4dmaN8cI2VgGrADBU2xlBQaDHKJBDC0Wlb7qzNk+yfUzGMiu4T5t6IxQrKI3DKV11p2O553PAEEUDWK4AjMkRQZdxXBJM8zb9VgUnWKBNDu3YClARDCZ3s85xULG8ibgnSvxzhHr7iIE7LrIYATPunMNzqeAAKRI6XuqJsyxanFaCbCIZiEUbpqk1j1D+UgVA8BtHukQkHlB0jhOQ+zHNpuR+v258TyhmVNykxcTMquOKi8O54A4jl6u8tQ4Kiog0JpEF9WPLmOyw7x5IP43UC/GkZeTQGwMOqQNFeeUDoBqya8ICJ46sYvPYSXWOhgzTgBJEY5Y/ZxFNmPBYDeJE86LHRGeUpOCh9AJABNMeqQwsnApeOs6mVAtd1E8NwFAWgakCMpnFtBHKlDj3PIMpAyELWzU1B6pNSGktQHaWqeqhGxS7EAlJdiT3kPAWRSiFP2DsnLF6ZpCy31qZrwpIThdCUcuMktngAs1ozIDCbLMVicEttMH3Y8AURHUs54ct00JNUUIHio6Z3HamABxHny5ETySgm1Q0+3IA8rAQmVotR/C4FA+DRSbG9OWP0hZ93xBBAtAO0oy+ZJLtfFh9wqp/hhJLTUTs1TVOGEj0aUTsATPqjgjbAejzV1lEspkk7xqvr/YXMTPg1ZH5EUqi+lPjl2PAFEqFN3nFiOHsfGcNIEPSgQGibqzoT3y2uVZSDPR0teKUwCecUtmk7tjns5EjfkSBXINEBnSTRBOTpexthfUs//1U9jWeOiQujNilMkgHh/wBRKN9gqp9xAE1YWsN72RQIYbOUG+X05AXU8+M4EPo1BViXL15tBAIxMWYJJSgYIjiQ0NcGAWLAMrRZvmJmll/RRSJxSBR9AInkDhijj85kiOdV2l5arOOLxTk8dTwBJlLCfXhE3lKQAN3AMQh3JpBD9iBo+jsueVccBKPNg8QDkzkybuRQIFG4QAuk0YT9Aij46kD6T7TtRYV6gQaONHk31VJXo2VKagH3iHYJ3JL5bzmCwCT4A/SABsGo2HTm2uby5S6opT2yqENcgCwDmqTquQaLULXU8AQTAad2cp+gGT7J6VAKFOKI8madu2oNvLAyP7e9S4RgttCWBuEVADgSwL7UFUMKoOx4v1KEuLD2mvM1b+1utqEHHE0CI6EIZw8GSUWFS9NSWFg0bSkA2RTFhRKST7sYCSL023iLSKZ+OTxg8E092fpobr4ZzB+NQfcoaDe3D6NPo0pkOiQK5hlazdL/qeAIICoOUW2F0kUCOFI7JStRRw94GRsRtEMCRuDaegmkGAlQp41SZzFglKW6IEiwevHHrOdk5VyzAhPJ+h6mmGwOBNtd3Op4Ags7TUR+FAJKHk5atlnJDifY0TYYAHt7NUeeZlsb66oyR48KyJ0qaInruoMiNvL+BBbA3xj4kIrxoASwoD3YF5o5PHU8AsvqnSEoIIPmGklIjdI+5EE+eoKNqlJ0s7xRz4qPIVIcU7g/I2vkhwK66Q8kCOFOa2HJvhwSwHgfjVFkAkd2O+6TzXlTdXrVDSKPSeEnJslmuHXThdlkoaZh+JEAkbDLCFIjHnKVWiP5E0Nr5cubNz2FupXCcjVH7QXhbdpQ1SSVwqfQz5AREphRTmv6wzP15xxOA+kpYn2a0TL0SEAeNcEAGo1aqLaVh1x2E9hwrASGlUogy+z4fSoFFACs0akIAKW6IEmXcsLXPmlTyQWy/aXICIo8smvheJQXUMJOOJwBhHggAh9nh0mROrS/hjDzmrRpBknUg8t4bb3bSpo4VZZO8k0QAmDwpOlRwBDLFePKZQtDUzrkpyHLBbCwO+kuKezy2qblOWmyK9jppQe18MzhzGJ12JXYiRRl7NpRoThy1JH5YwWNwbOJnWLe9yCy1QvRX5TEQwDLdGRmFCbcv7+8Hg/x8rxw5KOUPuhmVKUPypiDxiONkVjUuX0CZTLN0IEknpw4Xr2i6oIRoTbxDcOoGlRNwIZ1oNx1X/sCqU5ibYmFsi3PiqgsYRH7Rc95VBs+kOARFBNCFBfDVNci8s6xcCgYga8mj/nLhEl6w1DqhwzWkw8UrOksYhDFPj2aKn1dgzEqtjWtOXFSh0v8HNCKiEI9vRibkiiNXpYUMMLOoh9NFAJoCJLB4JG5Y+YDwnnqmqFgkngFWc8Bfi/met5SfMG3s9KXARhAA/TIsy22PTrMBd4fBfTEqos4FHI+CKp48hUKE6DiY5RGcYvvLaU3suIOrcQXfLhkg9dp5kBlSfeinRZ0j1hVIcFwWMd8Vi3m7i2kjJN7JStLJsvU0rEYQUfk2gmeUYiMXr6r/r1DgEB0H86TYIafgmAUQwFNb6KClIzCOxNVLM7Acp0zhe8x3AtYD+8mgvrUVLEcRoHPLw7QjG4PUhilIL/aNeTgB33IRR5IzaMyiPTs1NYMApB004t4cG0ooS+fYLZ5GmTisUqyLqzOOVcshz+boB2gXA5Qmf5fkxerRbcJTJO2CXKz51Dqzf/7XooQUBKCcdXiM4L3hMv7tIpDMCUCwDN8Uwkk5uHI1XvPnadzI8ikkino4Ha918jkksqx7NoUUA8+z1H+bLHlnmm2Q3yO+OfBsBvTNLeRt88xuu7sIgtLW3RQkEPvH5edT3mIwhsjl3Ewk1oBkT/UlEV3Hp7ihZEPGDSU96+KJes1hMQ1z4sfXFc0XO23uxozlTuUo9NfOpXQcrRMSybwPmZdhZfz4SbMv3VtImooAlO8sHJufehU8vslsCdMbQd5pqREEIAtAN+28Fwsghs+mas3YIc9kvioLIJX1GNfGv9fN8iZKJ0VsVweVzML3goXIjFMy1dq5eOVpMF20yOy/fNbsRxCBrIBw2EsizfyP1+LPWYK/Bblmp2rMRHUfSLaNIADNH+fQQcOGktIPkFpZggWQEF0RwFymNfc+jVMMyyak1EKVxfR+iKR3LoopAkjl94ji7UJ2I/Do0o9inrMUqmO8qiYBEap8AdMnm933u5RHOaOowNSEbdob1xyvO0ycviEL81I6Z3KnWWn+ynw0FDQc4dV3tYb8iZRhokYkAmNWry+yiYo45ExP84fLZQFkGCX3oJhz5RDE8nn5h5F/Q0ECMoGqPP05+hheusrswdvNnmXVRSQwrYO0poNEOXXvlcIoracRU6ZS/y1sKWX0OMjyVSqQgx+AOfHDjxcSxfl4SvlOlncsd/F8PoUEdDPPFBGBrWVvxiE4H79DN0u7K95r9q0f8ingR6UVEVRBiGFqRee5+iJWHz7EsiCxF6N5PSNVo7YKmeF5h4jRP1JRWXJuKLm8C/McZUi1oWQ75CJT+DM/YrWKqU3srP2jUe03IgHI6nnX+eSNUs5M3LNU5ib8AbMhQN2K7dpbzG7+JOSzscBBRBDxiGQwVEJQPsrjygshgdtoU6YD2im4QGGCkEEk/WpRzZNb4mbKI8RASpHZqA0lD61pcZrReFWnqAyT8NC/dAG5H0rnFFN03Fl0/u6nOPFodSHJUDv56eIQTe9rLyYngpNSOQJjPUPToXnbIMGjPJ612Oz2e3l8B8FCnzb7IVbRfrBXe0QyiG2jbdqqb7h4Lsz6w015BBK4wOz7TAcOQLgbCRJaCf6prZ0oc4rHxhDAPhp8Ho31rbWcDxidZikQJc94X7kLlvAi8YYSyWVMNf7+AR5J6qjtSFG5Ljyb0ufimsBEz1UVWXdrsAYWEL03n4CkD33d7LJ3m133AbOPfcHs2/9itpalPBGCksKzhVO4eK66x/oX33iRFCI5RIKQs/Gy88x+9hGzaxayRfknBD+1+Wi2WOehPHb6XoceTOgjNqF0mv18Heu684pG7t3wPT84nScqjE517lIeUYSUfrEtdMjFBOB8/D6Wxm4sytRIlZsIAo7IPW+W2fuvMvvDb6KMKOQm5M+VNlIWsNsCpl5aifgu8/Xv/i1v4CzUVOlKFPaKRWZLIaglc5jHQxazubRvYwKDw0Q2celId60qnCyEu7WvnE0+D/yx2d0PmH0O7O/fzMyHthAfq/mHS2oMAahBQkQgjqMHYe3rrjiR9atqtNhRVtBJFLm2ldFJJED/SJJioNOnv2b2J2/Nr/xRKFk+Gl1ffTUEcBcKJW3MnKR8IgKlSawUzMAxKRP9AOAHQljLB7IE8M2ERkHxjT6xGP/FuVhSE5m6zWKqOI9LR7uNYPlYMQ664au2eY9BY3Tik6ybKfouv3ntZfSth83u2QCZ8FnoZ3w+HNIZdlM0boZDdU+vjjpKaxw9ZB+dYfPHiA2YkdAKKKv6jj83+1NGibmUtTkVA1DWWXTONWsZlf4I0/QiyIahSLsS25EUbv1mRsc7IdquKRBgQrkHKp+4SIQ0CUy0jwI9DSO1lmkPUb9tIg3VU5eeQ9rhuRglDuutz3k7fEffw9IxLAlZXfrqcErCoTFJB2l0oSj7Nhbzwt+4Lh0BRDP8lb8EAXyFaTqdJCUBhDh5TNtXf4qoNUhAHvlYh5wNrDK1Gertr4MAHsDyxvQWAUgBpT/tSipbocQi/96mGNW1cWiC7gys57IYFDei50qy6FT/eIX3yvf1fD95SkZlPdxSoywANY6OrBLj6462axmlZmDCyQaKZntVDRjz3IlH/PybMUsP0MGYB8hcV2dMkRbSiddvN3srJvjH317MY6NZnqK8vvKMsn/0b8ze/ddmq5aZPYHZLYxTyd5XXfz9UyMQSe7U3+qgT7V0tgRnz971Zl/EUaWUYhKkzq7RUKGkd9xIIRsol3lkKgXQ6LQec3Q5DrBP3Gf2kTslGaNYWY/iVd7/b/lVLJLLUf7N1AvMAzHkrYKX1g8CI+2SW2/t5zsd97FiyZcwZ/vCg2bXn8/mEkxnLe+k8JyLCBQhdzfz4Sf34HeABPYnYgGVpbP5V+Bv+PJDmLHIdCXr1vIFyCeQ4nSik3WOQH7IKJP6+pdCAKuJVlyLn4Jpieqnzz3VA4HGWQARds3ZRjBaXnnHi7HkUpIqU1AE8pS3+Au/Q86Y5ypjeiLUxSsq8yk83CuWmL3vy2a/92fFqTbBIcgXZJXkSNHy0BTrzveYveYlOClZlnNLIAf6Ay8jUVcceAXa9c0DKMPMUZSOwqy4zeyx7he95lUqSfAMU9aFK1iGwjm3HRKQKZyUBBBLJKDNOZ/AyrnsfWbfwwKRrNHKkYwppj6t7RlkpxydFfDZd7L0uhKy3eYk0IpRu583lgAEvJZ+5uAM1LrwS3DU3fO9ojnUcaUcVSlJHA1fhjn+MGSzi5FQu8pSxcuTtXTdVh9mesPqw9M4Iq98r9l7/gJzvPtFGWUtVClnkfPx/yMJyBfyxd+HBM6hXvgEzgF3la16emofAo30AUS4pQBaGprJXHU8c/NPf4XXu5izEyU2Cx+BPo9K0jpa6r3BJv1GhLKQvK87z+zP72a5manBPMrey3RkKHn2VwflqXsT6G7Ci1iO++pjZv/zHg5FYRSeQvTbNNboNU/X92L5kjNcZebx/f7KOtXnykOyK9ruBpZFu9cRr0BdVhE1KH8Mf57ahEDjlgH7wllrv4tQlDUoh3rkzdcT4XU1nXQpCoSi9k5RUcL7/Ja/IrU+j++1PEoRNCrqNJtLsQa0LLAS5ezGZA87Flu+W/XT+ciHvtu6HfxjM8slq8x+8zLuggMhLV1QkF5fwUN9yltWciBEEWU/iKy330nM/hcocxlkRL3WY42lOjuhahw7KT8ngF6tKSUZiVJqPd0Oml280uyNeLIvPpvz6Eol0U6/HoXv9fvjXmo0Pe6NYnTV2vyokYXz8bc/QRz5Q3xpCRcjZI40l7K1W28N8umUpBDRNt/sTch46Vn4RPAdyFKZiRU0ZWJhJQymXiKL3klvCTM5QSW7Xt/1HbPX/yVPhDXl6468nvIi4ATQB97z6KS6LVRQkp18CT+Bwj0vPdPsZSjICsggbChhaUtHYmtDyXgUOMSP87u+NpScrLivPMiGkn8iOnEz5jnTAZnEJ9Ghk/30tN7T4Z06817Wz8ajiLif7PAXBEKQ1TMbkx0iOHcuG2ww13XNZNqgE4BnMqcfzbRpLEqrTTRS6riRBvEHnHZT5leR/28hwe9ife1CfsmeQ/4BV7KDv+gE0E/jSklm0rkVGnoQzdyEY03n3sk6CBtK1Ns1cjNSzoMMLkAxZCFoQ8kcLs21R2BVjJGycJ2woYTPpUhrNrFU+HD7NpRon4SOupJlQHXDnY0VWPQLySvy0yOvg2ZS33DPM5EEMr6cazJyTOKawXtdYKFbhp9BRqOZc2gDTdhQo9dgGW6fTnnjeC6/gIjjZxuIXfhh++RHkkYmJ4BBNDt9Nhx5rQ0l40pF0c8V3nsYctjKPDZsJGEUG+qGEilDXUY/WQYiQF1jqBf6GuLjJd5R5NVNQMJGH73Reoko+KxnKJdAvV/zVngPf0D4XhePWBd1kl9V7PQEJ3saKALqx4ri0+aP3js/RA4a0TTaSVE0ospq0HMlOcn0nXiF98r39byOG0rklNutSxWUzL2SZNGtwbXHQfvn4YgwnRBx6LlSlDs81+vyCq/1okxaCdERZycpJn7FHxMg4ARQEagiB+0zCDexrCjPumcjmWX9aBCvjdlSd9BqVr9I1DWrllfHEXAEciDgBJADZS/DEagpAk4ANW0Yr5YjkAMBJ4AcKHsZjkBNEXACqGnDeLUcgRwIOAHkQNnLcARqioATQE0bxqvlCORAwAkgB8pehiNQUwScAGraMF4tRyAHAk4AOVD2MhyBmiLgBFDThvFqOQI5EHACyIGyl+EI1BQBJ4CaNoxXyxHIgYATQA6UvQxHoKYIOAHUtGG8Wo5ADgScAHKg7GU4AjVFwAmgpg3j1XIEciDgBJADZS/DEagpAk4ANW0Yr5YjkAMBJ4AcKHsZjkBNEXACqGnDeLUcgRwIOAHkQNnLcARqioATQE0bxqvlCORAwAkgB8pehiNQUwScAGraMF4tRyAHAk4AOVD2MhyBmiLgBFDThvFqOQI5EHACyIGyl+EI1BQBJ4CaNoxXyxHIgYATQA6UvQxHoKYIOAHUtGG8Wo5ADgScAHKg7GU4AjVFwAmgpg3j1XIEciDgBJADZS/DEagpAk4ANW0Yr5YjkAMBJ4AcKHsZjkBNEXACqGnDeLUcgRwIOAHkQNnLcARqioATQE0bxqvlCORAwAkgB8pehiNQUwScAGraMF4tRyAHAk4AOVD2MhyBmiLgBFDThvFqOQI5EHACyIGyl+EI1BQBJ4CaNoxXyxHIgYATQA6UvQxHoKYIOAHUtGG8Wo5ADgScAHKg7GU4AjVFwAmgpg3j1XIEciDgBJADZS/DEagpAk4ANW0Yr5YjkAMBJ4AcKHsZjkBNEXACqGnDeLUcgRwIOAHkQNnLcARqioATQE0bxqvlCORAwAkgB8pehiNQUwScAGraMF4tRyAHAk4AOVD2MhyBmiLgBFDThvFqOQI5EHACyIGyl+EI1BQBJ4CaNoxXyxHIgYATQA6UvQxHoKYIOAHUtGG8Wo5ADgScAHKg7GU4AjVFwAmgpg3j1XIEciDgBJADZS/DEagpAk4ANW0Yr5YjkAMBJ4AcKHsZjkBNEXACqGnDeLUcgRwIOAHkQNnLcARqioATQE0bxqvlCORAwAkgB8pehiNQUwScAGraMF4tRyAHAv8fTRTpSk+HEsQAAAAASUVORK5CYII=";
var Ze = { exports: {} };
(function(w5) {
  (function(s14, h19) {
    w5.exports ? w5.exports = h19() : (s14.nacl || (s14.nacl = {}), s14.nacl.util = h19());
  })(Ce, function() {
    var s14 = {};
    function h19(x11) {
      if (!/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(x11))
        throw new TypeError("invalid encoding");
    }
    return s14.decodeUTF8 = function(x11) {
      if (typeof x11 != "string") throw new TypeError("expected string");
      var d24, I7 = unescape(encodeURIComponent(x11)), R7 = new Uint8Array(I7.length);
      for (d24 = 0; d24 < I7.length; d24++) R7[d24] = I7.charCodeAt(d24);
      return R7;
    }, s14.encodeUTF8 = function(x11) {
      var d24, I7 = [];
      for (d24 = 0; d24 < x11.length; d24++) I7.push(String.fromCharCode(x11[d24]));
      return decodeURIComponent(escape(I7.join("")));
    }, typeof atob > "u" ? typeof Buffer.from < "u" ? (s14.encodeBase64 = function(x11) {
      return Buffer.from(x11).toString("base64");
    }, s14.decodeBase64 = function(x11) {
      return h19(x11), new Uint8Array(Array.prototype.slice.call(Buffer.from(x11, "base64"), 0));
    }) : (s14.encodeBase64 = function(x11) {
      return new Buffer(x11).toString("base64");
    }, s14.decodeBase64 = function(x11) {
      return h19(x11), new Uint8Array(Array.prototype.slice.call(new Buffer(x11, "base64"), 0));
    }) : (s14.encodeBase64 = function(x11) {
      var d24, I7 = [], R7 = x11.length;
      for (d24 = 0; d24 < R7; d24++) I7.push(String.fromCharCode(x11[d24]));
      return btoa(I7.join(""));
    }, s14.decodeBase64 = function(x11) {
      h19(x11);
      var d24, I7 = atob(x11), R7 = new Uint8Array(I7.length);
      for (d24 = 0; d24 < I7.length; d24++) R7[d24] = I7.charCodeAt(d24);
      return R7;
    }), s14;
  });
})(Ze);
function qe(w5) {
  throw new Error('Could not dynamically require "' + w5 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var xe2 = { exports: {} };
var Ge = {};
var Ve = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: Ge
}, Symbol.toStringTag, { value: "Module" }));
var Xe = Te(Ve);
(function(w5) {
  (function(s14) {
    var h19 = function(n27) {
      var o34, i49 = new Float64Array(16);
      if (n27) for (o34 = 0; o34 < n27.length; o34++) i49[o34] = n27[o34];
      return i49;
    }, x11 = function() {
      throw new Error("no PRNG");
    }, d24 = new Uint8Array(16), I7 = new Uint8Array(32);
    I7[0] = 9;
    var R7 = h19(), l20 = h19([1]), j7 = h19([56129, 1]), et2 = h19([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), ct = h19([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), dt = h19([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), vt2 = h19([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), At = h19([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function Bt2(n27, o34, i49, t39) {
      n27[o34] = i49 >> 24 & 255, n27[o34 + 1] = i49 >> 16 & 255, n27[o34 + 2] = i49 >> 8 & 255, n27[o34 + 3] = i49 & 255, n27[o34 + 4] = t39 >> 24 & 255, n27[o34 + 5] = t39 >> 16 & 255, n27[o34 + 6] = t39 >> 8 & 255, n27[o34 + 7] = t39 & 255;
    }
    function Dt2(n27, o34, i49, t39, a26) {
      var A18, y14 = 0;
      for (A18 = 0; A18 < a26; A18++) y14 |= n27[o34 + A18] ^ i49[t39 + A18];
      return (1 & y14 - 1 >>> 8) - 1;
    }
    function er(n27, o34, i49, t39) {
      return Dt2(n27, o34, i49, t39, 16);
    }
    function Kt2(n27, o34, i49, t39) {
      return Dt2(n27, o34, i49, t39, 32);
    }
    function nr(n27, o34, i49, t39) {
      for (var a26 = t39[0] & 255 | (t39[1] & 255) << 8 | (t39[2] & 255) << 16 | (t39[3] & 255) << 24, A18 = i49[0] & 255 | (i49[1] & 255) << 8 | (i49[2] & 255) << 16 | (i49[3] & 255) << 24, y14 = i49[4] & 255 | (i49[5] & 255) << 8 | (i49[6] & 255) << 16 | (i49[7] & 255) << 24, U13 = i49[8] & 255 | (i49[9] & 255) << 8 | (i49[10] & 255) << 16 | (i49[11] & 255) << 24, T13 = i49[12] & 255 | (i49[13] & 255) << 8 | (i49[14] & 255) << 16 | (i49[15] & 255) << 24, D11 = t39[4] & 255 | (t39[5] & 255) << 8 | (t39[6] & 255) << 16 | (t39[7] & 255) << 24, F8 = o34[0] & 255 | (o34[1] & 255) << 8 | (o34[2] & 255) << 16 | (o34[3] & 255) << 24, ot = o34[4] & 255 | (o34[5] & 255) << 8 | (o34[6] & 255) << 16 | (o34[7] & 255) << 24, O8 = o34[8] & 255 | (o34[9] & 255) << 8 | (o34[10] & 255) << 16 | (o34[11] & 255) << 24, K5 = o34[12] & 255 | (o34[13] & 255) << 8 | (o34[14] & 255) << 16 | (o34[15] & 255) << 24, Y6 = t39[8] & 255 | (t39[9] & 255) << 8 | (t39[10] & 255) << 16 | (t39[11] & 255) << 24, q6 = i49[16] & 255 | (i49[17] & 255) << 8 | (i49[18] & 255) << 16 | (i49[19] & 255) << 24, Z5 = i49[20] & 255 | (i49[21] & 255) << 8 | (i49[22] & 255) << 16 | (i49[23] & 255) << 24, H4 = i49[24] & 255 | (i49[25] & 255) << 8 | (i49[26] & 255) << 16 | (i49[27] & 255) << 24, J4 = i49[28] & 255 | (i49[29] & 255) << 8 | (i49[30] & 255) << 16 | (i49[31] & 255) << 24, _8 = t39[12] & 255 | (t39[13] & 255) << 8 | (t39[14] & 255) << 16 | (t39[15] & 255) << 24, k7 = a26, Q4 = A18, L9 = y14, M5 = U13, P8 = T13, N6 = D11, m17 = F8, E11 = ot, C9 = O8, B10 = K5, v8 = Y6, S9 = q6, z9 = Z5, G7 = H4, X4 = J4, V3 = _8, u17, tt2 = 0; tt2 < 20; tt2 += 2)
        u17 = k7 + z9 | 0, P8 ^= u17 << 7 | u17 >>> 25, u17 = P8 + k7 | 0, C9 ^= u17 << 9 | u17 >>> 23, u17 = C9 + P8 | 0, z9 ^= u17 << 13 | u17 >>> 19, u17 = z9 + C9 | 0, k7 ^= u17 << 18 | u17 >>> 14, u17 = N6 + Q4 | 0, B10 ^= u17 << 7 | u17 >>> 25, u17 = B10 + N6 | 0, G7 ^= u17 << 9 | u17 >>> 23, u17 = G7 + B10 | 0, Q4 ^= u17 << 13 | u17 >>> 19, u17 = Q4 + G7 | 0, N6 ^= u17 << 18 | u17 >>> 14, u17 = v8 + m17 | 0, X4 ^= u17 << 7 | u17 >>> 25, u17 = X4 + v8 | 0, L9 ^= u17 << 9 | u17 >>> 23, u17 = L9 + X4 | 0, m17 ^= u17 << 13 | u17 >>> 19, u17 = m17 + L9 | 0, v8 ^= u17 << 18 | u17 >>> 14, u17 = V3 + S9 | 0, M5 ^= u17 << 7 | u17 >>> 25, u17 = M5 + V3 | 0, E11 ^= u17 << 9 | u17 >>> 23, u17 = E11 + M5 | 0, S9 ^= u17 << 13 | u17 >>> 19, u17 = S9 + E11 | 0, V3 ^= u17 << 18 | u17 >>> 14, u17 = k7 + M5 | 0, Q4 ^= u17 << 7 | u17 >>> 25, u17 = Q4 + k7 | 0, L9 ^= u17 << 9 | u17 >>> 23, u17 = L9 + Q4 | 0, M5 ^= u17 << 13 | u17 >>> 19, u17 = M5 + L9 | 0, k7 ^= u17 << 18 | u17 >>> 14, u17 = N6 + P8 | 0, m17 ^= u17 << 7 | u17 >>> 25, u17 = m17 + N6 | 0, E11 ^= u17 << 9 | u17 >>> 23, u17 = E11 + m17 | 0, P8 ^= u17 << 13 | u17 >>> 19, u17 = P8 + E11 | 0, N6 ^= u17 << 18 | u17 >>> 14, u17 = v8 + B10 | 0, S9 ^= u17 << 7 | u17 >>> 25, u17 = S9 + v8 | 0, C9 ^= u17 << 9 | u17 >>> 23, u17 = C9 + S9 | 0, B10 ^= u17 << 13 | u17 >>> 19, u17 = B10 + C9 | 0, v8 ^= u17 << 18 | u17 >>> 14, u17 = V3 + X4 | 0, z9 ^= u17 << 7 | u17 >>> 25, u17 = z9 + V3 | 0, G7 ^= u17 << 9 | u17 >>> 23, u17 = G7 + z9 | 0, X4 ^= u17 << 13 | u17 >>> 19, u17 = X4 + G7 | 0, V3 ^= u17 << 18 | u17 >>> 14;
      k7 = k7 + a26 | 0, Q4 = Q4 + A18 | 0, L9 = L9 + y14 | 0, M5 = M5 + U13 | 0, P8 = P8 + T13 | 0, N6 = N6 + D11 | 0, m17 = m17 + F8 | 0, E11 = E11 + ot | 0, C9 = C9 + O8 | 0, B10 = B10 + K5 | 0, v8 = v8 + Y6 | 0, S9 = S9 + q6 | 0, z9 = z9 + Z5 | 0, G7 = G7 + H4 | 0, X4 = X4 + J4 | 0, V3 = V3 + _8 | 0, n27[0] = k7 >>> 0 & 255, n27[1] = k7 >>> 8 & 255, n27[2] = k7 >>> 16 & 255, n27[3] = k7 >>> 24 & 255, n27[4] = Q4 >>> 0 & 255, n27[5] = Q4 >>> 8 & 255, n27[6] = Q4 >>> 16 & 255, n27[7] = Q4 >>> 24 & 255, n27[8] = L9 >>> 0 & 255, n27[9] = L9 >>> 8 & 255, n27[10] = L9 >>> 16 & 255, n27[11] = L9 >>> 24 & 255, n27[12] = M5 >>> 0 & 255, n27[13] = M5 >>> 8 & 255, n27[14] = M5 >>> 16 & 255, n27[15] = M5 >>> 24 & 255, n27[16] = P8 >>> 0 & 255, n27[17] = P8 >>> 8 & 255, n27[18] = P8 >>> 16 & 255, n27[19] = P8 >>> 24 & 255, n27[20] = N6 >>> 0 & 255, n27[21] = N6 >>> 8 & 255, n27[22] = N6 >>> 16 & 255, n27[23] = N6 >>> 24 & 255, n27[24] = m17 >>> 0 & 255, n27[25] = m17 >>> 8 & 255, n27[26] = m17 >>> 16 & 255, n27[27] = m17 >>> 24 & 255, n27[28] = E11 >>> 0 & 255, n27[29] = E11 >>> 8 & 255, n27[30] = E11 >>> 16 & 255, n27[31] = E11 >>> 24 & 255, n27[32] = C9 >>> 0 & 255, n27[33] = C9 >>> 8 & 255, n27[34] = C9 >>> 16 & 255, n27[35] = C9 >>> 24 & 255, n27[36] = B10 >>> 0 & 255, n27[37] = B10 >>> 8 & 255, n27[38] = B10 >>> 16 & 255, n27[39] = B10 >>> 24 & 255, n27[40] = v8 >>> 0 & 255, n27[41] = v8 >>> 8 & 255, n27[42] = v8 >>> 16 & 255, n27[43] = v8 >>> 24 & 255, n27[44] = S9 >>> 0 & 255, n27[45] = S9 >>> 8 & 255, n27[46] = S9 >>> 16 & 255, n27[47] = S9 >>> 24 & 255, n27[48] = z9 >>> 0 & 255, n27[49] = z9 >>> 8 & 255, n27[50] = z9 >>> 16 & 255, n27[51] = z9 >>> 24 & 255, n27[52] = G7 >>> 0 & 255, n27[53] = G7 >>> 8 & 255, n27[54] = G7 >>> 16 & 255, n27[55] = G7 >>> 24 & 255, n27[56] = X4 >>> 0 & 255, n27[57] = X4 >>> 8 & 255, n27[58] = X4 >>> 16 & 255, n27[59] = X4 >>> 24 & 255, n27[60] = V3 >>> 0 & 255, n27[61] = V3 >>> 8 & 255, n27[62] = V3 >>> 16 & 255, n27[63] = V3 >>> 24 & 255;
    }
    function lr(n27, o34, i49, t39) {
      for (var a26 = t39[0] & 255 | (t39[1] & 255) << 8 | (t39[2] & 255) << 16 | (t39[3] & 255) << 24, A18 = i49[0] & 255 | (i49[1] & 255) << 8 | (i49[2] & 255) << 16 | (i49[3] & 255) << 24, y14 = i49[4] & 255 | (i49[5] & 255) << 8 | (i49[6] & 255) << 16 | (i49[7] & 255) << 24, U13 = i49[8] & 255 | (i49[9] & 255) << 8 | (i49[10] & 255) << 16 | (i49[11] & 255) << 24, T13 = i49[12] & 255 | (i49[13] & 255) << 8 | (i49[14] & 255) << 16 | (i49[15] & 255) << 24, D11 = t39[4] & 255 | (t39[5] & 255) << 8 | (t39[6] & 255) << 16 | (t39[7] & 255) << 24, F8 = o34[0] & 255 | (o34[1] & 255) << 8 | (o34[2] & 255) << 16 | (o34[3] & 255) << 24, ot = o34[4] & 255 | (o34[5] & 255) << 8 | (o34[6] & 255) << 16 | (o34[7] & 255) << 24, O8 = o34[8] & 255 | (o34[9] & 255) << 8 | (o34[10] & 255) << 16 | (o34[11] & 255) << 24, K5 = o34[12] & 255 | (o34[13] & 255) << 8 | (o34[14] & 255) << 16 | (o34[15] & 255) << 24, Y6 = t39[8] & 255 | (t39[9] & 255) << 8 | (t39[10] & 255) << 16 | (t39[11] & 255) << 24, q6 = i49[16] & 255 | (i49[17] & 255) << 8 | (i49[18] & 255) << 16 | (i49[19] & 255) << 24, Z5 = i49[20] & 255 | (i49[21] & 255) << 8 | (i49[22] & 255) << 16 | (i49[23] & 255) << 24, H4 = i49[24] & 255 | (i49[25] & 255) << 8 | (i49[26] & 255) << 16 | (i49[27] & 255) << 24, J4 = i49[28] & 255 | (i49[29] & 255) << 8 | (i49[30] & 255) << 16 | (i49[31] & 255) << 24, _8 = t39[12] & 255 | (t39[13] & 255) << 8 | (t39[14] & 255) << 16 | (t39[15] & 255) << 24, k7 = a26, Q4 = A18, L9 = y14, M5 = U13, P8 = T13, N6 = D11, m17 = F8, E11 = ot, C9 = O8, B10 = K5, v8 = Y6, S9 = q6, z9 = Z5, G7 = H4, X4 = J4, V3 = _8, u17, tt2 = 0; tt2 < 20; tt2 += 2)
        u17 = k7 + z9 | 0, P8 ^= u17 << 7 | u17 >>> 25, u17 = P8 + k7 | 0, C9 ^= u17 << 9 | u17 >>> 23, u17 = C9 + P8 | 0, z9 ^= u17 << 13 | u17 >>> 19, u17 = z9 + C9 | 0, k7 ^= u17 << 18 | u17 >>> 14, u17 = N6 + Q4 | 0, B10 ^= u17 << 7 | u17 >>> 25, u17 = B10 + N6 | 0, G7 ^= u17 << 9 | u17 >>> 23, u17 = G7 + B10 | 0, Q4 ^= u17 << 13 | u17 >>> 19, u17 = Q4 + G7 | 0, N6 ^= u17 << 18 | u17 >>> 14, u17 = v8 + m17 | 0, X4 ^= u17 << 7 | u17 >>> 25, u17 = X4 + v8 | 0, L9 ^= u17 << 9 | u17 >>> 23, u17 = L9 + X4 | 0, m17 ^= u17 << 13 | u17 >>> 19, u17 = m17 + L9 | 0, v8 ^= u17 << 18 | u17 >>> 14, u17 = V3 + S9 | 0, M5 ^= u17 << 7 | u17 >>> 25, u17 = M5 + V3 | 0, E11 ^= u17 << 9 | u17 >>> 23, u17 = E11 + M5 | 0, S9 ^= u17 << 13 | u17 >>> 19, u17 = S9 + E11 | 0, V3 ^= u17 << 18 | u17 >>> 14, u17 = k7 + M5 | 0, Q4 ^= u17 << 7 | u17 >>> 25, u17 = Q4 + k7 | 0, L9 ^= u17 << 9 | u17 >>> 23, u17 = L9 + Q4 | 0, M5 ^= u17 << 13 | u17 >>> 19, u17 = M5 + L9 | 0, k7 ^= u17 << 18 | u17 >>> 14, u17 = N6 + P8 | 0, m17 ^= u17 << 7 | u17 >>> 25, u17 = m17 + N6 | 0, E11 ^= u17 << 9 | u17 >>> 23, u17 = E11 + m17 | 0, P8 ^= u17 << 13 | u17 >>> 19, u17 = P8 + E11 | 0, N6 ^= u17 << 18 | u17 >>> 14, u17 = v8 + B10 | 0, S9 ^= u17 << 7 | u17 >>> 25, u17 = S9 + v8 | 0, C9 ^= u17 << 9 | u17 >>> 23, u17 = C9 + S9 | 0, B10 ^= u17 << 13 | u17 >>> 19, u17 = B10 + C9 | 0, v8 ^= u17 << 18 | u17 >>> 14, u17 = V3 + X4 | 0, z9 ^= u17 << 7 | u17 >>> 25, u17 = z9 + V3 | 0, G7 ^= u17 << 9 | u17 >>> 23, u17 = G7 + z9 | 0, X4 ^= u17 << 13 | u17 >>> 19, u17 = X4 + G7 | 0, V3 ^= u17 << 18 | u17 >>> 14;
      n27[0] = k7 >>> 0 & 255, n27[1] = k7 >>> 8 & 255, n27[2] = k7 >>> 16 & 255, n27[3] = k7 >>> 24 & 255, n27[4] = N6 >>> 0 & 255, n27[5] = N6 >>> 8 & 255, n27[6] = N6 >>> 16 & 255, n27[7] = N6 >>> 24 & 255, n27[8] = v8 >>> 0 & 255, n27[9] = v8 >>> 8 & 255, n27[10] = v8 >>> 16 & 255, n27[11] = v8 >>> 24 & 255, n27[12] = V3 >>> 0 & 255, n27[13] = V3 >>> 8 & 255, n27[14] = V3 >>> 16 & 255, n27[15] = V3 >>> 24 & 255, n27[16] = m17 >>> 0 & 255, n27[17] = m17 >>> 8 & 255, n27[18] = m17 >>> 16 & 255, n27[19] = m17 >>> 24 & 255, n27[20] = E11 >>> 0 & 255, n27[21] = E11 >>> 8 & 255, n27[22] = E11 >>> 16 & 255, n27[23] = E11 >>> 24 & 255, n27[24] = C9 >>> 0 & 255, n27[25] = C9 >>> 8 & 255, n27[26] = C9 >>> 16 & 255, n27[27] = C9 >>> 24 & 255, n27[28] = B10 >>> 0 & 255, n27[29] = B10 >>> 8 & 255, n27[30] = B10 >>> 16 & 255, n27[31] = B10 >>> 24 & 255;
    }
    function Vt2(n27, o34, i49, t39) {
      nr(n27, o34, i49, t39);
    }
    function Rt2(n27, o34, i49, t39) {
      lr(n27, o34, i49, t39);
    }
    var Ft2 = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function Ht(n27, o34, i49, t39, a26, A18, y14) {
      var U13 = new Uint8Array(16), T13 = new Uint8Array(64), D11, F8;
      for (F8 = 0; F8 < 16; F8++) U13[F8] = 0;
      for (F8 = 0; F8 < 8; F8++) U13[F8] = A18[F8];
      for (; a26 >= 64; ) {
        for (Vt2(T13, U13, y14, Ft2), F8 = 0; F8 < 64; F8++) n27[o34 + F8] = i49[t39 + F8] ^ T13[F8];
        for (D11 = 1, F8 = 8; F8 < 16; F8++)
          D11 = D11 + (U13[F8] & 255) | 0, U13[F8] = D11 & 255, D11 >>>= 8;
        a26 -= 64, o34 += 64, t39 += 64;
      }
      if (a26 > 0)
        for (Vt2(T13, U13, y14, Ft2), F8 = 0; F8 < a26; F8++) n27[o34 + F8] = i49[t39 + F8] ^ T13[F8];
      return 0;
    }
    function Mt2(n27, o34, i49, t39, a26) {
      var A18 = new Uint8Array(16), y14 = new Uint8Array(64), U13, T13;
      for (T13 = 0; T13 < 16; T13++) A18[T13] = 0;
      for (T13 = 0; T13 < 8; T13++) A18[T13] = t39[T13];
      for (; i49 >= 64; ) {
        for (Vt2(y14, A18, a26, Ft2), T13 = 0; T13 < 64; T13++) n27[o34 + T13] = y14[T13];
        for (U13 = 1, T13 = 8; T13 < 16; T13++)
          U13 = U13 + (A18[T13] & 255) | 0, A18[T13] = U13 & 255, U13 >>>= 8;
        i49 -= 64, o34 += 64;
      }
      if (i49 > 0)
        for (Vt2(y14, A18, a26, Ft2), T13 = 0; T13 < i49; T13++) n27[o34 + T13] = y14[T13];
      return 0;
    }
    function Nr(n27, o34, i49, t39, a26) {
      var A18 = new Uint8Array(32);
      Rt2(A18, t39, a26, Ft2);
      for (var y14 = new Uint8Array(8), U13 = 0; U13 < 8; U13++) y14[U13] = t39[U13 + 16];
      return Mt2(n27, o34, i49, y14, A18);
    }
    function br(n27, o34, i49, t39, a26, A18, y14) {
      var U13 = new Uint8Array(32);
      Rt2(U13, A18, y14, Ft2);
      for (var T13 = new Uint8Array(8), D11 = 0; D11 < 8; D11++) T13[D11] = A18[D11 + 16];
      return Ht(n27, o34, i49, t39, a26, T13, U13);
    }
    var xr = function(n27) {
      this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0;
      var o34, i49, t39, a26, A18, y14, U13, T13;
      o34 = n27[0] & 255 | (n27[1] & 255) << 8, this.r[0] = o34 & 8191, i49 = n27[2] & 255 | (n27[3] & 255) << 8, this.r[1] = (o34 >>> 13 | i49 << 3) & 8191, t39 = n27[4] & 255 | (n27[5] & 255) << 8, this.r[2] = (i49 >>> 10 | t39 << 6) & 7939, a26 = n27[6] & 255 | (n27[7] & 255) << 8, this.r[3] = (t39 >>> 7 | a26 << 9) & 8191, A18 = n27[8] & 255 | (n27[9] & 255) << 8, this.r[4] = (a26 >>> 4 | A18 << 12) & 255, this.r[5] = A18 >>> 1 & 8190, y14 = n27[10] & 255 | (n27[11] & 255) << 8, this.r[6] = (A18 >>> 14 | y14 << 2) & 8191, U13 = n27[12] & 255 | (n27[13] & 255) << 8, this.r[7] = (y14 >>> 11 | U13 << 5) & 8065, T13 = n27[14] & 255 | (n27[15] & 255) << 8, this.r[8] = (U13 >>> 8 | T13 << 8) & 8191, this.r[9] = T13 >>> 5 & 127, this.pad[0] = n27[16] & 255 | (n27[17] & 255) << 8, this.pad[1] = n27[18] & 255 | (n27[19] & 255) << 8, this.pad[2] = n27[20] & 255 | (n27[21] & 255) << 8, this.pad[3] = n27[22] & 255 | (n27[23] & 255) << 8, this.pad[4] = n27[24] & 255 | (n27[25] & 255) << 8, this.pad[5] = n27[26] & 255 | (n27[27] & 255) << 8, this.pad[6] = n27[28] & 255 | (n27[29] & 255) << 8, this.pad[7] = n27[30] & 255 | (n27[31] & 255) << 8;
    };
    xr.prototype.blocks = function(n27, o34, i49) {
      for (var t39 = this.fin ? 0 : 2048, a26, A18, y14, U13, T13, D11, F8, ot, O8, K5, Y6, q6, Z5, H4, J4, _8, k7, Q4, L9, M5 = this.h[0], P8 = this.h[1], N6 = this.h[2], m17 = this.h[3], E11 = this.h[4], C9 = this.h[5], B10 = this.h[6], v8 = this.h[7], S9 = this.h[8], z9 = this.h[9], G7 = this.r[0], X4 = this.r[1], V3 = this.r[2], u17 = this.r[3], tt2 = this.r[4], at = this.r[5], st = this.r[6], $8 = this.r[7], nt = this.r[8], it = this.r[9]; i49 >= 16; )
        a26 = n27[o34 + 0] & 255 | (n27[o34 + 1] & 255) << 8, M5 += a26 & 8191, A18 = n27[o34 + 2] & 255 | (n27[o34 + 3] & 255) << 8, P8 += (a26 >>> 13 | A18 << 3) & 8191, y14 = n27[o34 + 4] & 255 | (n27[o34 + 5] & 255) << 8, N6 += (A18 >>> 10 | y14 << 6) & 8191, U13 = n27[o34 + 6] & 255 | (n27[o34 + 7] & 255) << 8, m17 += (y14 >>> 7 | U13 << 9) & 8191, T13 = n27[o34 + 8] & 255 | (n27[o34 + 9] & 255) << 8, E11 += (U13 >>> 4 | T13 << 12) & 8191, C9 += T13 >>> 1 & 8191, D11 = n27[o34 + 10] & 255 | (n27[o34 + 11] & 255) << 8, B10 += (T13 >>> 14 | D11 << 2) & 8191, F8 = n27[o34 + 12] & 255 | (n27[o34 + 13] & 255) << 8, v8 += (D11 >>> 11 | F8 << 5) & 8191, ot = n27[o34 + 14] & 255 | (n27[o34 + 15] & 255) << 8, S9 += (F8 >>> 8 | ot << 8) & 8191, z9 += ot >>> 5 | t39, O8 = 0, K5 = O8, K5 += M5 * G7, K5 += P8 * (5 * it), K5 += N6 * (5 * nt), K5 += m17 * (5 * $8), K5 += E11 * (5 * st), O8 = K5 >>> 13, K5 &= 8191, K5 += C9 * (5 * at), K5 += B10 * (5 * tt2), K5 += v8 * (5 * u17), K5 += S9 * (5 * V3), K5 += z9 * (5 * X4), O8 += K5 >>> 13, K5 &= 8191, Y6 = O8, Y6 += M5 * X4, Y6 += P8 * G7, Y6 += N6 * (5 * it), Y6 += m17 * (5 * nt), Y6 += E11 * (5 * $8), O8 = Y6 >>> 13, Y6 &= 8191, Y6 += C9 * (5 * st), Y6 += B10 * (5 * at), Y6 += v8 * (5 * tt2), Y6 += S9 * (5 * u17), Y6 += z9 * (5 * V3), O8 += Y6 >>> 13, Y6 &= 8191, q6 = O8, q6 += M5 * V3, q6 += P8 * X4, q6 += N6 * G7, q6 += m17 * (5 * it), q6 += E11 * (5 * nt), O8 = q6 >>> 13, q6 &= 8191, q6 += C9 * (5 * $8), q6 += B10 * (5 * st), q6 += v8 * (5 * at), q6 += S9 * (5 * tt2), q6 += z9 * (5 * u17), O8 += q6 >>> 13, q6 &= 8191, Z5 = O8, Z5 += M5 * u17, Z5 += P8 * V3, Z5 += N6 * X4, Z5 += m17 * G7, Z5 += E11 * (5 * it), O8 = Z5 >>> 13, Z5 &= 8191, Z5 += C9 * (5 * nt), Z5 += B10 * (5 * $8), Z5 += v8 * (5 * st), Z5 += S9 * (5 * at), Z5 += z9 * (5 * tt2), O8 += Z5 >>> 13, Z5 &= 8191, H4 = O8, H4 += M5 * tt2, H4 += P8 * u17, H4 += N6 * V3, H4 += m17 * X4, H4 += E11 * G7, O8 = H4 >>> 13, H4 &= 8191, H4 += C9 * (5 * it), H4 += B10 * (5 * nt), H4 += v8 * (5 * $8), H4 += S9 * (5 * st), H4 += z9 * (5 * at), O8 += H4 >>> 13, H4 &= 8191, J4 = O8, J4 += M5 * at, J4 += P8 * tt2, J4 += N6 * u17, J4 += m17 * V3, J4 += E11 * X4, O8 = J4 >>> 13, J4 &= 8191, J4 += C9 * G7, J4 += B10 * (5 * it), J4 += v8 * (5 * nt), J4 += S9 * (5 * $8), J4 += z9 * (5 * st), O8 += J4 >>> 13, J4 &= 8191, _8 = O8, _8 += M5 * st, _8 += P8 * at, _8 += N6 * tt2, _8 += m17 * u17, _8 += E11 * V3, O8 = _8 >>> 13, _8 &= 8191, _8 += C9 * X4, _8 += B10 * G7, _8 += v8 * (5 * it), _8 += S9 * (5 * nt), _8 += z9 * (5 * $8), O8 += _8 >>> 13, _8 &= 8191, k7 = O8, k7 += M5 * $8, k7 += P8 * st, k7 += N6 * at, k7 += m17 * tt2, k7 += E11 * u17, O8 = k7 >>> 13, k7 &= 8191, k7 += C9 * V3, k7 += B10 * X4, k7 += v8 * G7, k7 += S9 * (5 * it), k7 += z9 * (5 * nt), O8 += k7 >>> 13, k7 &= 8191, Q4 = O8, Q4 += M5 * nt, Q4 += P8 * $8, Q4 += N6 * st, Q4 += m17 * at, Q4 += E11 * tt2, O8 = Q4 >>> 13, Q4 &= 8191, Q4 += C9 * u17, Q4 += B10 * V3, Q4 += v8 * X4, Q4 += S9 * G7, Q4 += z9 * (5 * it), O8 += Q4 >>> 13, Q4 &= 8191, L9 = O8, L9 += M5 * it, L9 += P8 * nt, L9 += N6 * $8, L9 += m17 * st, L9 += E11 * at, O8 = L9 >>> 13, L9 &= 8191, L9 += C9 * tt2, L9 += B10 * u17, L9 += v8 * V3, L9 += S9 * X4, L9 += z9 * G7, O8 += L9 >>> 13, L9 &= 8191, O8 = (O8 << 2) + O8 | 0, O8 = O8 + K5 | 0, K5 = O8 & 8191, O8 = O8 >>> 13, Y6 += O8, M5 = K5, P8 = Y6, N6 = q6, m17 = Z5, E11 = H4, C9 = J4, B10 = _8, v8 = k7, S9 = Q4, z9 = L9, o34 += 16, i49 -= 16;
      this.h[0] = M5, this.h[1] = P8, this.h[2] = N6, this.h[3] = m17, this.h[4] = E11, this.h[5] = C9, this.h[6] = B10, this.h[7] = v8, this.h[8] = S9, this.h[9] = z9;
    }, xr.prototype.finish = function(n27, o34) {
      var i49 = new Uint16Array(10), t39, a26, A18, y14;
      if (this.leftover) {
        for (y14 = this.leftover, this.buffer[y14++] = 1; y14 < 16; y14++) this.buffer[y14] = 0;
        this.fin = 1, this.blocks(this.buffer, 0, 16);
      }
      for (t39 = this.h[1] >>> 13, this.h[1] &= 8191, y14 = 2; y14 < 10; y14++)
        this.h[y14] += t39, t39 = this.h[y14] >>> 13, this.h[y14] &= 8191;
      for (this.h[0] += t39 * 5, t39 = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += t39, t39 = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += t39, i49[0] = this.h[0] + 5, t39 = i49[0] >>> 13, i49[0] &= 8191, y14 = 1; y14 < 10; y14++)
        i49[y14] = this.h[y14] + t39, t39 = i49[y14] >>> 13, i49[y14] &= 8191;
      for (i49[9] -= 8192, a26 = (t39 ^ 1) - 1, y14 = 0; y14 < 10; y14++) i49[y14] &= a26;
      for (a26 = ~a26, y14 = 0; y14 < 10; y14++) this.h[y14] = this.h[y14] & a26 | i49[y14];
      for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535, this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535, this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535, this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535, this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535, this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535, this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535, this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535, A18 = this.h[0] + this.pad[0], this.h[0] = A18 & 65535, y14 = 1; y14 < 8; y14++)
        A18 = (this.h[y14] + this.pad[y14] | 0) + (A18 >>> 16) | 0, this.h[y14] = A18 & 65535;
      n27[o34 + 0] = this.h[0] >>> 0 & 255, n27[o34 + 1] = this.h[0] >>> 8 & 255, n27[o34 + 2] = this.h[1] >>> 0 & 255, n27[o34 + 3] = this.h[1] >>> 8 & 255, n27[o34 + 4] = this.h[2] >>> 0 & 255, n27[o34 + 5] = this.h[2] >>> 8 & 255, n27[o34 + 6] = this.h[3] >>> 0 & 255, n27[o34 + 7] = this.h[3] >>> 8 & 255, n27[o34 + 8] = this.h[4] >>> 0 & 255, n27[o34 + 9] = this.h[4] >>> 8 & 255, n27[o34 + 10] = this.h[5] >>> 0 & 255, n27[o34 + 11] = this.h[5] >>> 8 & 255, n27[o34 + 12] = this.h[6] >>> 0 & 255, n27[o34 + 13] = this.h[6] >>> 8 & 255, n27[o34 + 14] = this.h[7] >>> 0 & 255, n27[o34 + 15] = this.h[7] >>> 8 & 255;
    }, xr.prototype.update = function(n27, o34, i49) {
      var t39, a26;
      if (this.leftover) {
        for (a26 = 16 - this.leftover, a26 > i49 && (a26 = i49), t39 = 0; t39 < a26; t39++)
          this.buffer[this.leftover + t39] = n27[o34 + t39];
        if (i49 -= a26, o34 += a26, this.leftover += a26, this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16), this.leftover = 0;
      }
      if (i49 >= 16 && (a26 = i49 - i49 % 16, this.blocks(n27, o34, a26), o34 += a26, i49 -= a26), i49) {
        for (t39 = 0; t39 < i49; t39++)
          this.buffer[this.leftover + t39] = n27[o34 + t39];
        this.leftover += i49;
      }
    };
    function Br(n27, o34, i49, t39, a26, A18) {
      var y14 = new xr(A18);
      return y14.update(i49, t39, a26), y14.finish(n27, o34), 0;
    }
    function Fr(n27, o34, i49, t39, a26, A18) {
      var y14 = new Uint8Array(16);
      return Br(y14, 0, i49, t39, a26, A18), er(n27, o34, y14, 0);
    }
    function pr(n27, o34, i49, t39, a26) {
      var A18;
      if (i49 < 32) return -1;
      for (br(n27, 0, o34, 0, i49, t39, a26), Br(n27, 16, n27, 32, i49 - 32, n27), A18 = 0; A18 < 16; A18++) n27[A18] = 0;
      return 0;
    }
    function dr(n27, o34, i49, t39, a26) {
      var A18, y14 = new Uint8Array(32);
      if (i49 < 32 || (Nr(y14, 0, 32, t39, a26), Fr(o34, 16, o34, 32, i49 - 32, y14) !== 0)) return -1;
      for (br(n27, 0, o34, 0, i49, t39, a26), A18 = 0; A18 < 32; A18++) n27[A18] = 0;
      return 0;
    }
    function Yt2(n27, o34) {
      var i49;
      for (i49 = 0; i49 < 16; i49++) n27[i49] = o34[i49] | 0;
    }
    function Ir(n27) {
      var o34, i49, t39 = 1;
      for (o34 = 0; o34 < 16; o34++)
        i49 = n27[o34] + t39 + 65535, t39 = Math.floor(i49 / 65536), n27[o34] = i49 - t39 * 65536;
      n27[0] += t39 - 1 + 37 * (t39 - 1);
    }
    function Xt(n27, o34, i49) {
      for (var t39, a26 = ~(i49 - 1), A18 = 0; A18 < 16; A18++)
        t39 = a26 & (n27[A18] ^ o34[A18]), n27[A18] ^= t39, o34[A18] ^= t39;
    }
    function $t(n27, o34) {
      var i49, t39, a26, A18 = h19(), y14 = h19();
      for (i49 = 0; i49 < 16; i49++) y14[i49] = o34[i49];
      for (Ir(y14), Ir(y14), Ir(y14), t39 = 0; t39 < 2; t39++) {
        for (A18[0] = y14[0] - 65517, i49 = 1; i49 < 15; i49++)
          A18[i49] = y14[i49] - 65535 - (A18[i49 - 1] >> 16 & 1), A18[i49 - 1] &= 65535;
        A18[15] = y14[15] - 32767 - (A18[14] >> 16 & 1), a26 = A18[15] >> 16 & 1, A18[14] &= 65535, Xt(y14, A18, 1 - a26);
      }
      for (i49 = 0; i49 < 16; i49++)
        n27[2 * i49] = y14[i49] & 255, n27[2 * i49 + 1] = y14[i49] >> 8;
    }
    function Lr(n27, o34) {
      var i49 = new Uint8Array(32), t39 = new Uint8Array(32);
      return $t(i49, n27), $t(t39, o34), Kt2(i49, 0, t39, 0);
    }
    function mt(n27) {
      var o34 = new Uint8Array(32);
      return $t(o34, n27), o34[0] & 1;
    }
    function It2(n27, o34) {
      var i49;
      for (i49 = 0; i49 < 16; i49++) n27[i49] = o34[2 * i49] + (o34[2 * i49 + 1] << 8);
      n27[15] &= 32767;
    }
    function Lt2(n27, o34, i49) {
      for (var t39 = 0; t39 < 16; t39++) n27[t39] = o34[t39] + i49[t39];
    }
    function Ot2(n27, o34, i49) {
      for (var t39 = 0; t39 < 16; t39++) n27[t39] = o34[t39] - i49[t39];
    }
    function rt(n27, o34, i49) {
      var t39, a26, A18 = 0, y14 = 0, U13 = 0, T13 = 0, D11 = 0, F8 = 0, ot = 0, O8 = 0, K5 = 0, Y6 = 0, q6 = 0, Z5 = 0, H4 = 0, J4 = 0, _8 = 0, k7 = 0, Q4 = 0, L9 = 0, M5 = 0, P8 = 0, N6 = 0, m17 = 0, E11 = 0, C9 = 0, B10 = 0, v8 = 0, S9 = 0, z9 = 0, G7 = 0, X4 = 0, V3 = 0, u17 = i49[0], tt2 = i49[1], at = i49[2], st = i49[3], $8 = i49[4], nt = i49[5], it = i49[6], Et2 = i49[7], lt = i49[8], wt = i49[9], yt = i49[10], gt = i49[11], bt2 = i49[12], Ct = i49[13], St2 = i49[14], Tt = i49[15];
      t39 = o34[0], A18 += t39 * u17, y14 += t39 * tt2, U13 += t39 * at, T13 += t39 * st, D11 += t39 * $8, F8 += t39 * nt, ot += t39 * it, O8 += t39 * Et2, K5 += t39 * lt, Y6 += t39 * wt, q6 += t39 * yt, Z5 += t39 * gt, H4 += t39 * bt2, J4 += t39 * Ct, _8 += t39 * St2, k7 += t39 * Tt, t39 = o34[1], y14 += t39 * u17, U13 += t39 * tt2, T13 += t39 * at, D11 += t39 * st, F8 += t39 * $8, ot += t39 * nt, O8 += t39 * it, K5 += t39 * Et2, Y6 += t39 * lt, q6 += t39 * wt, Z5 += t39 * yt, H4 += t39 * gt, J4 += t39 * bt2, _8 += t39 * Ct, k7 += t39 * St2, Q4 += t39 * Tt, t39 = o34[2], U13 += t39 * u17, T13 += t39 * tt2, D11 += t39 * at, F8 += t39 * st, ot += t39 * $8, O8 += t39 * nt, K5 += t39 * it, Y6 += t39 * Et2, q6 += t39 * lt, Z5 += t39 * wt, H4 += t39 * yt, J4 += t39 * gt, _8 += t39 * bt2, k7 += t39 * Ct, Q4 += t39 * St2, L9 += t39 * Tt, t39 = o34[3], T13 += t39 * u17, D11 += t39 * tt2, F8 += t39 * at, ot += t39 * st, O8 += t39 * $8, K5 += t39 * nt, Y6 += t39 * it, q6 += t39 * Et2, Z5 += t39 * lt, H4 += t39 * wt, J4 += t39 * yt, _8 += t39 * gt, k7 += t39 * bt2, Q4 += t39 * Ct, L9 += t39 * St2, M5 += t39 * Tt, t39 = o34[4], D11 += t39 * u17, F8 += t39 * tt2, ot += t39 * at, O8 += t39 * st, K5 += t39 * $8, Y6 += t39 * nt, q6 += t39 * it, Z5 += t39 * Et2, H4 += t39 * lt, J4 += t39 * wt, _8 += t39 * yt, k7 += t39 * gt, Q4 += t39 * bt2, L9 += t39 * Ct, M5 += t39 * St2, P8 += t39 * Tt, t39 = o34[5], F8 += t39 * u17, ot += t39 * tt2, O8 += t39 * at, K5 += t39 * st, Y6 += t39 * $8, q6 += t39 * nt, Z5 += t39 * it, H4 += t39 * Et2, J4 += t39 * lt, _8 += t39 * wt, k7 += t39 * yt, Q4 += t39 * gt, L9 += t39 * bt2, M5 += t39 * Ct, P8 += t39 * St2, N6 += t39 * Tt, t39 = o34[6], ot += t39 * u17, O8 += t39 * tt2, K5 += t39 * at, Y6 += t39 * st, q6 += t39 * $8, Z5 += t39 * nt, H4 += t39 * it, J4 += t39 * Et2, _8 += t39 * lt, k7 += t39 * wt, Q4 += t39 * yt, L9 += t39 * gt, M5 += t39 * bt2, P8 += t39 * Ct, N6 += t39 * St2, m17 += t39 * Tt, t39 = o34[7], O8 += t39 * u17, K5 += t39 * tt2, Y6 += t39 * at, q6 += t39 * st, Z5 += t39 * $8, H4 += t39 * nt, J4 += t39 * it, _8 += t39 * Et2, k7 += t39 * lt, Q4 += t39 * wt, L9 += t39 * yt, M5 += t39 * gt, P8 += t39 * bt2, N6 += t39 * Ct, m17 += t39 * St2, E11 += t39 * Tt, t39 = o34[8], K5 += t39 * u17, Y6 += t39 * tt2, q6 += t39 * at, Z5 += t39 * st, H4 += t39 * $8, J4 += t39 * nt, _8 += t39 * it, k7 += t39 * Et2, Q4 += t39 * lt, L9 += t39 * wt, M5 += t39 * yt, P8 += t39 * gt, N6 += t39 * bt2, m17 += t39 * Ct, E11 += t39 * St2, C9 += t39 * Tt, t39 = o34[9], Y6 += t39 * u17, q6 += t39 * tt2, Z5 += t39 * at, H4 += t39 * st, J4 += t39 * $8, _8 += t39 * nt, k7 += t39 * it, Q4 += t39 * Et2, L9 += t39 * lt, M5 += t39 * wt, P8 += t39 * yt, N6 += t39 * gt, m17 += t39 * bt2, E11 += t39 * Ct, C9 += t39 * St2, B10 += t39 * Tt, t39 = o34[10], q6 += t39 * u17, Z5 += t39 * tt2, H4 += t39 * at, J4 += t39 * st, _8 += t39 * $8, k7 += t39 * nt, Q4 += t39 * it, L9 += t39 * Et2, M5 += t39 * lt, P8 += t39 * wt, N6 += t39 * yt, m17 += t39 * gt, E11 += t39 * bt2, C9 += t39 * Ct, B10 += t39 * St2, v8 += t39 * Tt, t39 = o34[11], Z5 += t39 * u17, H4 += t39 * tt2, J4 += t39 * at, _8 += t39 * st, k7 += t39 * $8, Q4 += t39 * nt, L9 += t39 * it, M5 += t39 * Et2, P8 += t39 * lt, N6 += t39 * wt, m17 += t39 * yt, E11 += t39 * gt, C9 += t39 * bt2, B10 += t39 * Ct, v8 += t39 * St2, S9 += t39 * Tt, t39 = o34[12], H4 += t39 * u17, J4 += t39 * tt2, _8 += t39 * at, k7 += t39 * st, Q4 += t39 * $8, L9 += t39 * nt, M5 += t39 * it, P8 += t39 * Et2, N6 += t39 * lt, m17 += t39 * wt, E11 += t39 * yt, C9 += t39 * gt, B10 += t39 * bt2, v8 += t39 * Ct, S9 += t39 * St2, z9 += t39 * Tt, t39 = o34[13], J4 += t39 * u17, _8 += t39 * tt2, k7 += t39 * at, Q4 += t39 * st, L9 += t39 * $8, M5 += t39 * nt, P8 += t39 * it, N6 += t39 * Et2, m17 += t39 * lt, E11 += t39 * wt, C9 += t39 * yt, B10 += t39 * gt, v8 += t39 * bt2, S9 += t39 * Ct, z9 += t39 * St2, G7 += t39 * Tt, t39 = o34[14], _8 += t39 * u17, k7 += t39 * tt2, Q4 += t39 * at, L9 += t39 * st, M5 += t39 * $8, P8 += t39 * nt, N6 += t39 * it, m17 += t39 * Et2, E11 += t39 * lt, C9 += t39 * wt, B10 += t39 * yt, v8 += t39 * gt, S9 += t39 * bt2, z9 += t39 * Ct, G7 += t39 * St2, X4 += t39 * Tt, t39 = o34[15], k7 += t39 * u17, Q4 += t39 * tt2, L9 += t39 * at, M5 += t39 * st, P8 += t39 * $8, N6 += t39 * nt, m17 += t39 * it, E11 += t39 * Et2, C9 += t39 * lt, B10 += t39 * wt, v8 += t39 * yt, S9 += t39 * gt, z9 += t39 * bt2, G7 += t39 * Ct, X4 += t39 * St2, V3 += t39 * Tt, A18 += 38 * Q4, y14 += 38 * L9, U13 += 38 * M5, T13 += 38 * P8, D11 += 38 * N6, F8 += 38 * m17, ot += 38 * E11, O8 += 38 * C9, K5 += 38 * B10, Y6 += 38 * v8, q6 += 38 * S9, Z5 += 38 * z9, H4 += 38 * G7, J4 += 38 * X4, _8 += 38 * V3, a26 = 1, t39 = A18 + a26 + 65535, a26 = Math.floor(t39 / 65536), A18 = t39 - a26 * 65536, t39 = y14 + a26 + 65535, a26 = Math.floor(t39 / 65536), y14 = t39 - a26 * 65536, t39 = U13 + a26 + 65535, a26 = Math.floor(t39 / 65536), U13 = t39 - a26 * 65536, t39 = T13 + a26 + 65535, a26 = Math.floor(t39 / 65536), T13 = t39 - a26 * 65536, t39 = D11 + a26 + 65535, a26 = Math.floor(t39 / 65536), D11 = t39 - a26 * 65536, t39 = F8 + a26 + 65535, a26 = Math.floor(t39 / 65536), F8 = t39 - a26 * 65536, t39 = ot + a26 + 65535, a26 = Math.floor(t39 / 65536), ot = t39 - a26 * 65536, t39 = O8 + a26 + 65535, a26 = Math.floor(t39 / 65536), O8 = t39 - a26 * 65536, t39 = K5 + a26 + 65535, a26 = Math.floor(t39 / 65536), K5 = t39 - a26 * 65536, t39 = Y6 + a26 + 65535, a26 = Math.floor(t39 / 65536), Y6 = t39 - a26 * 65536, t39 = q6 + a26 + 65535, a26 = Math.floor(t39 / 65536), q6 = t39 - a26 * 65536, t39 = Z5 + a26 + 65535, a26 = Math.floor(t39 / 65536), Z5 = t39 - a26 * 65536, t39 = H4 + a26 + 65535, a26 = Math.floor(t39 / 65536), H4 = t39 - a26 * 65536, t39 = J4 + a26 + 65535, a26 = Math.floor(t39 / 65536), J4 = t39 - a26 * 65536, t39 = _8 + a26 + 65535, a26 = Math.floor(t39 / 65536), _8 = t39 - a26 * 65536, t39 = k7 + a26 + 65535, a26 = Math.floor(t39 / 65536), k7 = t39 - a26 * 65536, A18 += a26 - 1 + 37 * (a26 - 1), a26 = 1, t39 = A18 + a26 + 65535, a26 = Math.floor(t39 / 65536), A18 = t39 - a26 * 65536, t39 = y14 + a26 + 65535, a26 = Math.floor(t39 / 65536), y14 = t39 - a26 * 65536, t39 = U13 + a26 + 65535, a26 = Math.floor(t39 / 65536), U13 = t39 - a26 * 65536, t39 = T13 + a26 + 65535, a26 = Math.floor(t39 / 65536), T13 = t39 - a26 * 65536, t39 = D11 + a26 + 65535, a26 = Math.floor(t39 / 65536), D11 = t39 - a26 * 65536, t39 = F8 + a26 + 65535, a26 = Math.floor(t39 / 65536), F8 = t39 - a26 * 65536, t39 = ot + a26 + 65535, a26 = Math.floor(t39 / 65536), ot = t39 - a26 * 65536, t39 = O8 + a26 + 65535, a26 = Math.floor(t39 / 65536), O8 = t39 - a26 * 65536, t39 = K5 + a26 + 65535, a26 = Math.floor(t39 / 65536), K5 = t39 - a26 * 65536, t39 = Y6 + a26 + 65535, a26 = Math.floor(t39 / 65536), Y6 = t39 - a26 * 65536, t39 = q6 + a26 + 65535, a26 = Math.floor(t39 / 65536), q6 = t39 - a26 * 65536, t39 = Z5 + a26 + 65535, a26 = Math.floor(t39 / 65536), Z5 = t39 - a26 * 65536, t39 = H4 + a26 + 65535, a26 = Math.floor(t39 / 65536), H4 = t39 - a26 * 65536, t39 = J4 + a26 + 65535, a26 = Math.floor(t39 / 65536), J4 = t39 - a26 * 65536, t39 = _8 + a26 + 65535, a26 = Math.floor(t39 / 65536), _8 = t39 - a26 * 65536, t39 = k7 + a26 + 65535, a26 = Math.floor(t39 / 65536), k7 = t39 - a26 * 65536, A18 += a26 - 1 + 37 * (a26 - 1), n27[0] = A18, n27[1] = y14, n27[2] = U13, n27[3] = T13, n27[4] = D11, n27[5] = F8, n27[6] = ot, n27[7] = O8, n27[8] = K5, n27[9] = Y6, n27[10] = q6, n27[11] = Z5, n27[12] = H4, n27[13] = J4, n27[14] = _8, n27[15] = k7;
    }
    function Nt2(n27, o34) {
      rt(n27, o34, o34);
    }
    function Ur(n27, o34) {
      var i49 = h19(), t39;
      for (t39 = 0; t39 < 16; t39++) i49[t39] = o34[t39];
      for (t39 = 253; t39 >= 0; t39--)
        Nt2(i49, i49), t39 !== 2 && t39 !== 4 && rt(i49, i49, o34);
      for (t39 = 0; t39 < 16; t39++) n27[t39] = i49[t39];
    }
    function Jt(n27, o34) {
      var i49 = h19(), t39;
      for (t39 = 0; t39 < 16; t39++) i49[t39] = o34[t39];
      for (t39 = 250; t39 >= 0; t39--)
        Nt2(i49, i49), t39 !== 1 && rt(i49, i49, o34);
      for (t39 = 0; t39 < 16; t39++) n27[t39] = i49[t39];
    }
    function tr(n27, o34, i49) {
      var t39 = new Uint8Array(32), a26 = new Float64Array(80), A18, y14, U13 = h19(), T13 = h19(), D11 = h19(), F8 = h19(), ot = h19(), O8 = h19();
      for (y14 = 0; y14 < 31; y14++) t39[y14] = o34[y14];
      for (t39[31] = o34[31] & 127 | 64, t39[0] &= 248, It2(a26, i49), y14 = 0; y14 < 16; y14++)
        T13[y14] = a26[y14], F8[y14] = U13[y14] = D11[y14] = 0;
      for (U13[0] = F8[0] = 1, y14 = 254; y14 >= 0; --y14)
        A18 = t39[y14 >>> 3] >>> (y14 & 7) & 1, Xt(U13, T13, A18), Xt(D11, F8, A18), Lt2(ot, U13, D11), Ot2(U13, U13, D11), Lt2(D11, T13, F8), Ot2(T13, T13, F8), Nt2(F8, ot), Nt2(O8, U13), rt(U13, D11, U13), rt(D11, T13, ot), Lt2(ot, U13, D11), Ot2(U13, U13, D11), Nt2(T13, U13), Ot2(D11, F8, O8), rt(U13, D11, j7), Lt2(U13, U13, F8), rt(D11, D11, U13), rt(U13, F8, O8), rt(F8, T13, a26), Nt2(T13, ot), Xt(U13, T13, A18), Xt(D11, F8, A18);
      for (y14 = 0; y14 < 16; y14++)
        a26[y14 + 16] = U13[y14], a26[y14 + 32] = D11[y14], a26[y14 + 48] = T13[y14], a26[y14 + 64] = F8[y14];
      var K5 = a26.subarray(32), Y6 = a26.subarray(16);
      return Ur(K5, K5), rt(Y6, Y6, K5), $t(n27, Y6), 0;
    }
    function ir(n27, o34) {
      return tr(n27, o34, I7);
    }
    function Or(n27, o34) {
      return x11(o34, 32), ir(n27, o34);
    }
    function fr(n27, o34, i49) {
      var t39 = new Uint8Array(32);
      return tr(t39, i49, o34), Rt2(n27, d24, t39, Ft2);
    }
    var Wt = pr, or = dr;
    function zr(n27, o34, i49, t39, a26, A18) {
      var y14 = new Uint8Array(32);
      return fr(y14, a26, A18), Wt(n27, o34, i49, t39, y14);
    }
    function Kr(n27, o34, i49, t39, a26, A18) {
      var y14 = new Uint8Array(32);
      return fr(y14, a26, A18), or(n27, o34, i49, t39, y14);
    }
    var Ar = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function kr(n27, o34, i49, t39) {
      for (var a26 = new Int32Array(16), A18 = new Int32Array(16), y14, U13, T13, D11, F8, ot, O8, K5, Y6, q6, Z5, H4, J4, _8, k7, Q4, L9, M5, P8, N6, m17, E11, C9, B10, v8, S9, z9 = n27[0], G7 = n27[1], X4 = n27[2], V3 = n27[3], u17 = n27[4], tt2 = n27[5], at = n27[6], st = n27[7], $8 = o34[0], nt = o34[1], it = o34[2], Et2 = o34[3], lt = o34[4], wt = o34[5], yt = o34[6], gt = o34[7], bt2 = 0; t39 >= 128; ) {
        for (P8 = 0; P8 < 16; P8++)
          N6 = 8 * P8 + bt2, a26[P8] = i49[N6 + 0] << 24 | i49[N6 + 1] << 16 | i49[N6 + 2] << 8 | i49[N6 + 3], A18[P8] = i49[N6 + 4] << 24 | i49[N6 + 5] << 16 | i49[N6 + 6] << 8 | i49[N6 + 7];
        for (P8 = 0; P8 < 80; P8++)
          if (y14 = z9, U13 = G7, T13 = X4, D11 = V3, F8 = u17, ot = tt2, O8 = at, K5 = st, Y6 = $8, q6 = nt, Z5 = it, H4 = Et2, J4 = lt, _8 = wt, k7 = yt, Q4 = gt, m17 = st, E11 = gt, C9 = E11 & 65535, B10 = E11 >>> 16, v8 = m17 & 65535, S9 = m17 >>> 16, m17 = (u17 >>> 14 | lt << 18) ^ (u17 >>> 18 | lt << 14) ^ (lt >>> 9 | u17 << 23), E11 = (lt >>> 14 | u17 << 18) ^ (lt >>> 18 | u17 << 14) ^ (u17 >>> 9 | lt << 23), C9 += E11 & 65535, B10 += E11 >>> 16, v8 += m17 & 65535, S9 += m17 >>> 16, m17 = u17 & tt2 ^ ~u17 & at, E11 = lt & wt ^ ~lt & yt, C9 += E11 & 65535, B10 += E11 >>> 16, v8 += m17 & 65535, S9 += m17 >>> 16, m17 = Ar[P8 * 2], E11 = Ar[P8 * 2 + 1], C9 += E11 & 65535, B10 += E11 >>> 16, v8 += m17 & 65535, S9 += m17 >>> 16, m17 = a26[P8 % 16], E11 = A18[P8 % 16], C9 += E11 & 65535, B10 += E11 >>> 16, v8 += m17 & 65535, S9 += m17 >>> 16, B10 += C9 >>> 16, v8 += B10 >>> 16, S9 += v8 >>> 16, L9 = v8 & 65535 | S9 << 16, M5 = C9 & 65535 | B10 << 16, m17 = L9, E11 = M5, C9 = E11 & 65535, B10 = E11 >>> 16, v8 = m17 & 65535, S9 = m17 >>> 16, m17 = (z9 >>> 28 | $8 << 4) ^ ($8 >>> 2 | z9 << 30) ^ ($8 >>> 7 | z9 << 25), E11 = ($8 >>> 28 | z9 << 4) ^ (z9 >>> 2 | $8 << 30) ^ (z9 >>> 7 | $8 << 25), C9 += E11 & 65535, B10 += E11 >>> 16, v8 += m17 & 65535, S9 += m17 >>> 16, m17 = z9 & G7 ^ z9 & X4 ^ G7 & X4, E11 = $8 & nt ^ $8 & it ^ nt & it, C9 += E11 & 65535, B10 += E11 >>> 16, v8 += m17 & 65535, S9 += m17 >>> 16, B10 += C9 >>> 16, v8 += B10 >>> 16, S9 += v8 >>> 16, K5 = v8 & 65535 | S9 << 16, Q4 = C9 & 65535 | B10 << 16, m17 = D11, E11 = H4, C9 = E11 & 65535, B10 = E11 >>> 16, v8 = m17 & 65535, S9 = m17 >>> 16, m17 = L9, E11 = M5, C9 += E11 & 65535, B10 += E11 >>> 16, v8 += m17 & 65535, S9 += m17 >>> 16, B10 += C9 >>> 16, v8 += B10 >>> 16, S9 += v8 >>> 16, D11 = v8 & 65535 | S9 << 16, H4 = C9 & 65535 | B10 << 16, G7 = y14, X4 = U13, V3 = T13, u17 = D11, tt2 = F8, at = ot, st = O8, z9 = K5, nt = Y6, it = q6, Et2 = Z5, lt = H4, wt = J4, yt = _8, gt = k7, $8 = Q4, P8 % 16 === 15)
            for (N6 = 0; N6 < 16; N6++)
              m17 = a26[N6], E11 = A18[N6], C9 = E11 & 65535, B10 = E11 >>> 16, v8 = m17 & 65535, S9 = m17 >>> 16, m17 = a26[(N6 + 9) % 16], E11 = A18[(N6 + 9) % 16], C9 += E11 & 65535, B10 += E11 >>> 16, v8 += m17 & 65535, S9 += m17 >>> 16, L9 = a26[(N6 + 1) % 16], M5 = A18[(N6 + 1) % 16], m17 = (L9 >>> 1 | M5 << 31) ^ (L9 >>> 8 | M5 << 24) ^ L9 >>> 7, E11 = (M5 >>> 1 | L9 << 31) ^ (M5 >>> 8 | L9 << 24) ^ (M5 >>> 7 | L9 << 25), C9 += E11 & 65535, B10 += E11 >>> 16, v8 += m17 & 65535, S9 += m17 >>> 16, L9 = a26[(N6 + 14) % 16], M5 = A18[(N6 + 14) % 16], m17 = (L9 >>> 19 | M5 << 13) ^ (M5 >>> 29 | L9 << 3) ^ L9 >>> 6, E11 = (M5 >>> 19 | L9 << 13) ^ (L9 >>> 29 | M5 << 3) ^ (M5 >>> 6 | L9 << 26), C9 += E11 & 65535, B10 += E11 >>> 16, v8 += m17 & 65535, S9 += m17 >>> 16, B10 += C9 >>> 16, v8 += B10 >>> 16, S9 += v8 >>> 16, a26[N6] = v8 & 65535 | S9 << 16, A18[N6] = C9 & 65535 | B10 << 16;
        m17 = z9, E11 = $8, C9 = E11 & 65535, B10 = E11 >>> 16, v8 = m17 & 65535, S9 = m17 >>> 16, m17 = n27[0], E11 = o34[0], C9 += E11 & 65535, B10 += E11 >>> 16, v8 += m17 & 65535, S9 += m17 >>> 16, B10 += C9 >>> 16, v8 += B10 >>> 16, S9 += v8 >>> 16, n27[0] = z9 = v8 & 65535 | S9 << 16, o34[0] = $8 = C9 & 65535 | B10 << 16, m17 = G7, E11 = nt, C9 = E11 & 65535, B10 = E11 >>> 16, v8 = m17 & 65535, S9 = m17 >>> 16, m17 = n27[1], E11 = o34[1], C9 += E11 & 65535, B10 += E11 >>> 16, v8 += m17 & 65535, S9 += m17 >>> 16, B10 += C9 >>> 16, v8 += B10 >>> 16, S9 += v8 >>> 16, n27[1] = G7 = v8 & 65535 | S9 << 16, o34[1] = nt = C9 & 65535 | B10 << 16, m17 = X4, E11 = it, C9 = E11 & 65535, B10 = E11 >>> 16, v8 = m17 & 65535, S9 = m17 >>> 16, m17 = n27[2], E11 = o34[2], C9 += E11 & 65535, B10 += E11 >>> 16, v8 += m17 & 65535, S9 += m17 >>> 16, B10 += C9 >>> 16, v8 += B10 >>> 16, S9 += v8 >>> 16, n27[2] = X4 = v8 & 65535 | S9 << 16, o34[2] = it = C9 & 65535 | B10 << 16, m17 = V3, E11 = Et2, C9 = E11 & 65535, B10 = E11 >>> 16, v8 = m17 & 65535, S9 = m17 >>> 16, m17 = n27[3], E11 = o34[3], C9 += E11 & 65535, B10 += E11 >>> 16, v8 += m17 & 65535, S9 += m17 >>> 16, B10 += C9 >>> 16, v8 += B10 >>> 16, S9 += v8 >>> 16, n27[3] = V3 = v8 & 65535 | S9 << 16, o34[3] = Et2 = C9 & 65535 | B10 << 16, m17 = u17, E11 = lt, C9 = E11 & 65535, B10 = E11 >>> 16, v8 = m17 & 65535, S9 = m17 >>> 16, m17 = n27[4], E11 = o34[4], C9 += E11 & 65535, B10 += E11 >>> 16, v8 += m17 & 65535, S9 += m17 >>> 16, B10 += C9 >>> 16, v8 += B10 >>> 16, S9 += v8 >>> 16, n27[4] = u17 = v8 & 65535 | S9 << 16, o34[4] = lt = C9 & 65535 | B10 << 16, m17 = tt2, E11 = wt, C9 = E11 & 65535, B10 = E11 >>> 16, v8 = m17 & 65535, S9 = m17 >>> 16, m17 = n27[5], E11 = o34[5], C9 += E11 & 65535, B10 += E11 >>> 16, v8 += m17 & 65535, S9 += m17 >>> 16, B10 += C9 >>> 16, v8 += B10 >>> 16, S9 += v8 >>> 16, n27[5] = tt2 = v8 & 65535 | S9 << 16, o34[5] = wt = C9 & 65535 | B10 << 16, m17 = at, E11 = yt, C9 = E11 & 65535, B10 = E11 >>> 16, v8 = m17 & 65535, S9 = m17 >>> 16, m17 = n27[6], E11 = o34[6], C9 += E11 & 65535, B10 += E11 >>> 16, v8 += m17 & 65535, S9 += m17 >>> 16, B10 += C9 >>> 16, v8 += B10 >>> 16, S9 += v8 >>> 16, n27[6] = at = v8 & 65535 | S9 << 16, o34[6] = yt = C9 & 65535 | B10 << 16, m17 = st, E11 = gt, C9 = E11 & 65535, B10 = E11 >>> 16, v8 = m17 & 65535, S9 = m17 >>> 16, m17 = n27[7], E11 = o34[7], C9 += E11 & 65535, B10 += E11 >>> 16, v8 += m17 & 65535, S9 += m17 >>> 16, B10 += C9 >>> 16, v8 += B10 >>> 16, S9 += v8 >>> 16, n27[7] = st = v8 & 65535 | S9 << 16, o34[7] = gt = C9 & 65535 | B10 << 16, bt2 += 128, t39 -= 128;
      }
      return t39;
    }
    function Zt(n27, o34, i49) {
      var t39 = new Int32Array(8), a26 = new Int32Array(8), A18 = new Uint8Array(256), y14, U13 = i49;
      for (t39[0] = 1779033703, t39[1] = 3144134277, t39[2] = 1013904242, t39[3] = 2773480762, t39[4] = 1359893119, t39[5] = 2600822924, t39[6] = 528734635, t39[7] = 1541459225, a26[0] = 4089235720, a26[1] = 2227873595, a26[2] = 4271175723, a26[3] = 1595750129, a26[4] = 2917565137, a26[5] = 725511199, a26[6] = 4215389547, a26[7] = 327033209, kr(t39, a26, o34, i49), i49 %= 128, y14 = 0; y14 < i49; y14++) A18[y14] = o34[U13 - i49 + y14];
      for (A18[i49] = 128, i49 = 256 - 128 * (i49 < 112 ? 1 : 0), A18[i49 - 9] = 0, Bt2(A18, i49 - 8, U13 / 536870912 | 0, U13 << 3), kr(t39, a26, A18, i49), y14 = 0; y14 < 8; y14++) Bt2(n27, 8 * y14, t39[y14], a26[y14]);
      return 0;
    }
    function ar(n27, o34) {
      var i49 = h19(), t39 = h19(), a26 = h19(), A18 = h19(), y14 = h19(), U13 = h19(), T13 = h19(), D11 = h19(), F8 = h19();
      Ot2(i49, n27[1], n27[0]), Ot2(F8, o34[1], o34[0]), rt(i49, i49, F8), Lt2(t39, n27[0], n27[1]), Lt2(F8, o34[0], o34[1]), rt(t39, t39, F8), rt(a26, n27[3], o34[3]), rt(a26, a26, ct), rt(A18, n27[2], o34[2]), Lt2(A18, A18, A18), Ot2(y14, t39, i49), Ot2(U13, A18, a26), Lt2(T13, A18, a26), Lt2(D11, t39, i49), rt(n27[0], y14, U13), rt(n27[1], D11, T13), rt(n27[2], T13, U13), rt(n27[3], y14, D11);
    }
    function sr(n27, o34, i49) {
      var t39;
      for (t39 = 0; t39 < 4; t39++)
        Xt(n27[t39], o34[t39], i49);
    }
    function kt(n27, o34) {
      var i49 = h19(), t39 = h19(), a26 = h19();
      Ur(a26, o34[2]), rt(i49, o34[0], a26), rt(t39, o34[1], a26), $t(n27, t39), n27[31] ^= mt(i49) << 7;
    }
    function cr(n27, o34, i49) {
      var t39, a26;
      for (Yt2(n27[0], R7), Yt2(n27[1], l20), Yt2(n27[2], l20), Yt2(n27[3], R7), a26 = 255; a26 >= 0; --a26)
        t39 = i49[a26 / 8 | 0] >> (a26 & 7) & 1, sr(n27, o34, t39), ar(o34, n27), ar(n27, n27), sr(n27, o34, t39);
    }
    function wr(n27, o34) {
      var i49 = [h19(), h19(), h19(), h19()];
      Yt2(i49[0], dt), Yt2(i49[1], vt2), Yt2(i49[2], l20), rt(i49[3], dt, vt2), cr(n27, i49, o34);
    }
    function Qt2(n27, o34, i49) {
      var t39 = new Uint8Array(64), a26 = [h19(), h19(), h19(), h19()], A18;
      for (i49 || x11(o34, 32), Zt(t39, o34, 32), t39[0] &= 248, t39[31] &= 127, t39[31] |= 64, wr(a26, t39), kt(n27, a26), A18 = 0; A18 < 32; A18++) o34[A18 + 32] = n27[A18];
      return 0;
    }
    var yr = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function f19(n27, o34) {
      var i49, t39, a26, A18;
      for (t39 = 63; t39 >= 32; --t39) {
        for (i49 = 0, a26 = t39 - 32, A18 = t39 - 12; a26 < A18; ++a26)
          o34[a26] += i49 - 16 * o34[t39] * yr[a26 - (t39 - 32)], i49 = Math.floor((o34[a26] + 128) / 256), o34[a26] -= i49 * 256;
        o34[a26] += i49, o34[t39] = 0;
      }
      for (i49 = 0, a26 = 0; a26 < 32; a26++)
        o34[a26] += i49 - (o34[31] >> 4) * yr[a26], i49 = o34[a26] >> 8, o34[a26] &= 255;
      for (a26 = 0; a26 < 32; a26++) o34[a26] -= i49 * yr[a26];
      for (t39 = 0; t39 < 32; t39++)
        o34[t39 + 1] += o34[t39] >> 8, n27[t39] = o34[t39] & 255;
    }
    function r30(n27) {
      var o34 = new Float64Array(64), i49;
      for (i49 = 0; i49 < 64; i49++) o34[i49] = n27[i49];
      for (i49 = 0; i49 < 64; i49++) n27[i49] = 0;
      f19(n27, o34);
    }
    function e10(n27, o34, i49, t39) {
      var a26 = new Uint8Array(64), A18 = new Uint8Array(64), y14 = new Uint8Array(64), U13, T13, D11 = new Float64Array(64), F8 = [h19(), h19(), h19(), h19()];
      Zt(a26, t39, 32), a26[0] &= 248, a26[31] &= 127, a26[31] |= 64;
      var ot = i49 + 64;
      for (U13 = 0; U13 < i49; U13++) n27[64 + U13] = o34[U13];
      for (U13 = 0; U13 < 32; U13++) n27[32 + U13] = a26[32 + U13];
      for (Zt(y14, n27.subarray(32), i49 + 32), r30(y14), wr(F8, y14), kt(n27, F8), U13 = 32; U13 < 64; U13++) n27[U13] = t39[U13];
      for (Zt(A18, n27, i49 + 64), r30(A18), U13 = 0; U13 < 64; U13++) D11[U13] = 0;
      for (U13 = 0; U13 < 32; U13++) D11[U13] = y14[U13];
      for (U13 = 0; U13 < 32; U13++)
        for (T13 = 0; T13 < 32; T13++)
          D11[U13 + T13] += A18[U13] * a26[T13];
      return f19(n27.subarray(32), D11), ot;
    }
    function c16(n27, o34) {
      var i49 = h19(), t39 = h19(), a26 = h19(), A18 = h19(), y14 = h19(), U13 = h19(), T13 = h19();
      return Yt2(n27[2], l20), It2(n27[1], o34), Nt2(a26, n27[1]), rt(A18, a26, et2), Ot2(a26, a26, n27[2]), Lt2(A18, n27[2], A18), Nt2(y14, A18), Nt2(U13, y14), rt(T13, U13, y14), rt(i49, T13, a26), rt(i49, i49, A18), Jt(i49, i49), rt(i49, i49, a26), rt(i49, i49, A18), rt(i49, i49, A18), rt(n27[0], i49, A18), Nt2(t39, n27[0]), rt(t39, t39, A18), Lr(t39, a26) && rt(n27[0], n27[0], At), Nt2(t39, n27[0]), rt(t39, t39, A18), Lr(t39, a26) ? -1 : (mt(n27[0]) === o34[31] >> 7 && Ot2(n27[0], R7, n27[0]), rt(n27[3], n27[0], n27[1]), 0);
    }
    function p16(n27, o34, i49, t39) {
      var a26, A18 = new Uint8Array(32), y14 = new Uint8Array(64), U13 = [h19(), h19(), h19(), h19()], T13 = [h19(), h19(), h19(), h19()];
      if (i49 < 64 || c16(T13, t39)) return -1;
      for (a26 = 0; a26 < i49; a26++) n27[a26] = o34[a26];
      for (a26 = 0; a26 < 32; a26++) n27[a26 + 32] = t39[a26];
      if (Zt(y14, n27, i49), r30(y14), cr(U13, T13, y14), wr(T13, o34.subarray(32)), ar(U13, T13), kt(A18, U13), i49 -= 64, Kt2(o34, 0, A18, 0)) {
        for (a26 = 0; a26 < i49; a26++) n27[a26] = 0;
        return -1;
      }
      for (a26 = 0; a26 < i49; a26++) n27[a26] = o34[a26 + 64];
      return i49;
    }
    var g11 = 32, b12 = 24, W11 = 32, ut = 16, ht2 = 32, pt = 32, ft = 32, vr = 32, Yr = 32, $r = b12, pe = W11, de2 = ut, qt2 = 64, hr = 32, gr = 64, Hr = 32, _r = 64;
    s14.lowlevel = {
      crypto_core_hsalsa20: Rt2,
      crypto_stream_xor: br,
      crypto_stream: Nr,
      crypto_stream_salsa20_xor: Ht,
      crypto_stream_salsa20: Mt2,
      crypto_onetimeauth: Br,
      crypto_onetimeauth_verify: Fr,
      crypto_verify_16: er,
      crypto_verify_32: Kt2,
      crypto_secretbox: pr,
      crypto_secretbox_open: dr,
      crypto_scalarmult: tr,
      crypto_scalarmult_base: ir,
      crypto_box_beforenm: fr,
      crypto_box_afternm: Wt,
      crypto_box: zr,
      crypto_box_open: Kr,
      crypto_box_keypair: Or,
      crypto_hash: Zt,
      crypto_sign: e10,
      crypto_sign_keypair: Qt2,
      crypto_sign_open: p16,
      crypto_secretbox_KEYBYTES: g11,
      crypto_secretbox_NONCEBYTES: b12,
      crypto_secretbox_ZEROBYTES: W11,
      crypto_secretbox_BOXZEROBYTES: ut,
      crypto_scalarmult_BYTES: ht2,
      crypto_scalarmult_SCALARBYTES: pt,
      crypto_box_PUBLICKEYBYTES: ft,
      crypto_box_SECRETKEYBYTES: vr,
      crypto_box_BEFORENMBYTES: Yr,
      crypto_box_NONCEBYTES: $r,
      crypto_box_ZEROBYTES: pe,
      crypto_box_BOXZEROBYTES: de2,
      crypto_sign_BYTES: qt2,
      crypto_sign_PUBLICKEYBYTES: hr,
      crypto_sign_SECRETKEYBYTES: gr,
      crypto_sign_SEEDBYTES: Hr,
      crypto_hash_BYTES: _r,
      gf: h19,
      D: et2,
      L: yr,
      pack25519: $t,
      unpack25519: It2,
      M: rt,
      A: Lt2,
      S: Nt2,
      Z: Ot2,
      pow2523: Jt,
      add: ar,
      set25519: Yt2,
      modL: f19,
      scalarmult: cr,
      scalarbase: wr
    };
    function te3(n27, o34) {
      if (n27.length !== g11) throw new Error("bad key size");
      if (o34.length !== b12) throw new Error("bad nonce size");
    }
    function Ae(n27, o34) {
      if (n27.length !== ft) throw new Error("bad public key size");
      if (o34.length !== vr) throw new Error("bad secret key size");
    }
    function Pt2() {
      for (var n27 = 0; n27 < arguments.length; n27++)
        if (!(arguments[n27] instanceof Uint8Array))
          throw new TypeError("unexpected type, use Uint8Array");
    }
    function re2(n27) {
      for (var o34 = 0; o34 < n27.length; o34++) n27[o34] = 0;
    }
    s14.randomBytes = function(n27) {
      var o34 = new Uint8Array(n27);
      return x11(o34, n27), o34;
    }, s14.secretbox = function(n27, o34, i49) {
      Pt2(n27, o34, i49), te3(i49, o34);
      for (var t39 = new Uint8Array(W11 + n27.length), a26 = new Uint8Array(t39.length), A18 = 0; A18 < n27.length; A18++) t39[A18 + W11] = n27[A18];
      return pr(a26, t39, t39.length, o34, i49), a26.subarray(ut);
    }, s14.secretbox.open = function(n27, o34, i49) {
      Pt2(n27, o34, i49), te3(i49, o34);
      for (var t39 = new Uint8Array(ut + n27.length), a26 = new Uint8Array(t39.length), A18 = 0; A18 < n27.length; A18++) t39[A18 + ut] = n27[A18];
      return t39.length < 32 || dr(a26, t39, t39.length, o34, i49) !== 0 ? null : a26.subarray(W11);
    }, s14.secretbox.keyLength = g11, s14.secretbox.nonceLength = b12, s14.secretbox.overheadLength = ut, s14.scalarMult = function(n27, o34) {
      if (Pt2(n27, o34), n27.length !== pt) throw new Error("bad n size");
      if (o34.length !== ht2) throw new Error("bad p size");
      var i49 = new Uint8Array(ht2);
      return tr(i49, n27, o34), i49;
    }, s14.scalarMult.base = function(n27) {
      if (Pt2(n27), n27.length !== pt) throw new Error("bad n size");
      var o34 = new Uint8Array(ht2);
      return ir(o34, n27), o34;
    }, s14.scalarMult.scalarLength = pt, s14.scalarMult.groupElementLength = ht2, s14.box = function(n27, o34, i49, t39) {
      var a26 = s14.box.before(i49, t39);
      return s14.secretbox(n27, o34, a26);
    }, s14.box.before = function(n27, o34) {
      Pt2(n27, o34), Ae(n27, o34);
      var i49 = new Uint8Array(Yr);
      return fr(i49, n27, o34), i49;
    }, s14.box.after = s14.secretbox, s14.box.open = function(n27, o34, i49, t39) {
      var a26 = s14.box.before(i49, t39);
      return s14.secretbox.open(n27, o34, a26);
    }, s14.box.open.after = s14.secretbox.open, s14.box.keyPair = function() {
      var n27 = new Uint8Array(ft), o34 = new Uint8Array(vr);
      return Or(n27, o34), { publicKey: n27, secretKey: o34 };
    }, s14.box.keyPair.fromSecretKey = function(n27) {
      if (Pt2(n27), n27.length !== vr)
        throw new Error("bad secret key size");
      var o34 = new Uint8Array(ft);
      return ir(o34, n27), { publicKey: o34, secretKey: new Uint8Array(n27) };
    }, s14.box.publicKeyLength = ft, s14.box.secretKeyLength = vr, s14.box.sharedKeyLength = Yr, s14.box.nonceLength = $r, s14.box.overheadLength = s14.secretbox.overheadLength, s14.sign = function(n27, o34) {
      if (Pt2(n27, o34), o34.length !== gr)
        throw new Error("bad secret key size");
      var i49 = new Uint8Array(qt2 + n27.length);
      return e10(i49, n27, n27.length, o34), i49;
    }, s14.sign.open = function(n27, o34) {
      if (Pt2(n27, o34), o34.length !== hr)
        throw new Error("bad public key size");
      var i49 = new Uint8Array(n27.length), t39 = p16(i49, n27, n27.length, o34);
      if (t39 < 0) return null;
      for (var a26 = new Uint8Array(t39), A18 = 0; A18 < a26.length; A18++) a26[A18] = i49[A18];
      return a26;
    }, s14.sign.detached = function(n27, o34) {
      for (var i49 = s14.sign(n27, o34), t39 = new Uint8Array(qt2), a26 = 0; a26 < t39.length; a26++) t39[a26] = i49[a26];
      return t39;
    }, s14.sign.detached.verify = function(n27, o34, i49) {
      if (Pt2(n27, o34, i49), o34.length !== qt2)
        throw new Error("bad signature size");
      if (i49.length !== hr)
        throw new Error("bad public key size");
      var t39 = new Uint8Array(qt2 + n27.length), a26 = new Uint8Array(qt2 + n27.length), A18;
      for (A18 = 0; A18 < qt2; A18++) t39[A18] = o34[A18];
      for (A18 = 0; A18 < n27.length; A18++) t39[A18 + qt2] = n27[A18];
      return p16(a26, t39, t39.length, i49) >= 0;
    }, s14.sign.keyPair = function() {
      var n27 = new Uint8Array(hr), o34 = new Uint8Array(gr);
      return Qt2(n27, o34), { publicKey: n27, secretKey: o34 };
    }, s14.sign.keyPair.fromSecretKey = function(n27) {
      if (Pt2(n27), n27.length !== gr)
        throw new Error("bad secret key size");
      for (var o34 = new Uint8Array(hr), i49 = 0; i49 < o34.length; i49++) o34[i49] = n27[32 + i49];
      return { publicKey: o34, secretKey: new Uint8Array(n27) };
    }, s14.sign.keyPair.fromSeed = function(n27) {
      if (Pt2(n27), n27.length !== Hr)
        throw new Error("bad seed size");
      for (var o34 = new Uint8Array(hr), i49 = new Uint8Array(gr), t39 = 0; t39 < 32; t39++) i49[t39] = n27[t39];
      return Qt2(o34, i49, true), { publicKey: o34, secretKey: i49 };
    }, s14.sign.publicKeyLength = hr, s14.sign.secretKeyLength = gr, s14.sign.seedLength = Hr, s14.sign.signatureLength = qt2, s14.hash = function(n27) {
      Pt2(n27);
      var o34 = new Uint8Array(_r);
      return Zt(o34, n27, n27.length), o34;
    }, s14.hash.hashLength = _r, s14.verify = function(n27, o34) {
      return Pt2(n27, o34), n27.length === 0 || o34.length === 0 || n27.length !== o34.length ? false : Dt2(n27, 0, o34, 0, n27.length) === 0;
    }, s14.setPRNG = function(n27) {
      x11 = n27;
    }, function() {
      var n27 = typeof self < "u" ? self.crypto || self.msCrypto : null;
      if (n27 && n27.getRandomValues) {
        var o34 = 65536;
        s14.setPRNG(function(i49, t39) {
          var a26, A18 = new Uint8Array(t39);
          for (a26 = 0; a26 < t39; a26 += o34)
            n27.getRandomValues(A18.subarray(a26, a26 + Math.min(t39 - a26, o34)));
          for (a26 = 0; a26 < t39; a26++) i49[a26] = A18[a26];
          re2(A18);
        });
      } else typeof qe < "u" && (n27 = Xe, n27 && n27.randomBytes && s14.setPRNG(function(i49, t39) {
        var a26, A18 = n27.randomBytes(t39);
        for (a26 = 0; a26 < t39; a26++) i49[a26] = A18[a26];
        re2(A18);
      }));
    }();
  })(w5.exports ? w5.exports : self.nacl = self.nacl || {});
})(xe2);
var $e = xe2.exports;
var Mr = Se2($e);
var tn2 = Object.defineProperty;
var rn2 = (w5, s14, h19) => s14 in w5 ? tn2(w5, s14, { enumerable: true, configurable: true, writable: true, value: h19 }) : w5[s14] = h19;
var Wr = (w5, s14, h19) => rn2(w5, typeof s14 != "symbol" ? s14 + "" : s14, h19);
async function en(w5, s14) {
  const h19 = w5.getReader();
  let x11;
  for (; !(x11 = await h19.read()).done; )
    s14(x11.value);
}
function nn2(w5) {
  let s14, h19, x11, d24 = false;
  return function(I7) {
    s14 === void 0 ? (s14 = I7, h19 = 0, x11 = -1) : s14 = on3(s14, I7);
    const R7 = s14.length;
    let l20 = 0;
    for (; h19 < R7; ) {
      d24 && (s14[h19] === 10 && (l20 = ++h19), d24 = false);
      let j7 = -1;
      for (; h19 < R7 && j7 === -1; ++h19)
        switch (s14[h19]) {
          case 58:
            x11 === -1 && (x11 = h19 - l20);
            break;
          case 13:
            d24 = true;
          case 10:
            j7 = h19;
            break;
        }
      if (j7 === -1)
        break;
      w5(s14.subarray(l20, j7), x11), l20 = h19, x11 = -1;
    }
    l20 === R7 ? s14 = void 0 : l20 !== 0 && (s14 = s14.subarray(l20), h19 -= l20);
  };
}
function fn3(w5, s14, h19) {
  let x11 = ie2();
  const d24 = new TextDecoder();
  return function(I7, R7) {
    if (I7.length === 0)
      h19 == null || h19(x11), x11 = ie2();
    else if (R7 > 0) {
      const l20 = d24.decode(I7.subarray(0, R7)), j7 = R7 + (I7[R7 + 1] === 32 ? 2 : 1), et2 = d24.decode(I7.subarray(j7));
      switch (l20) {
        case "data":
          x11.data = x11.data ? x11.data + `
` + et2 : et2;
          break;
        case "event":
          x11.event = et2;
          break;
        case "id":
          w5(x11.id = et2);
          break;
        case "retry":
          const ct = parseInt(et2, 10);
          isNaN(ct) || s14(x11.retry = ct);
          break;
      }
    }
  };
}
function on3(w5, s14) {
  const h19 = new Uint8Array(w5.length + s14.length);
  return h19.set(w5), h19.set(s14, w5.length), h19;
}
function ie2() {
  return {
    data: "",
    event: "",
    id: "",
    retry: void 0
  };
}
var an = function(w5, s14) {
  var h19 = {};
  for (var x11 in w5) Object.prototype.hasOwnProperty.call(w5, x11) && s14.indexOf(x11) < 0 && (h19[x11] = w5[x11]);
  if (w5 != null && typeof Object.getOwnPropertySymbols == "function")
    for (var d24 = 0, x11 = Object.getOwnPropertySymbols(w5); d24 < x11.length; d24++)
      s14.indexOf(x11[d24]) < 0 && Object.prototype.propertyIsEnumerable.call(w5, x11[d24]) && (h19[x11[d24]] = w5[x11[d24]]);
  return h19;
};
var Gr = "text/event-stream";
var sn2 = 1e3;
var fe2 = "last-event-id";
function cn2(w5, s14) {
  var { signal: h19, headers: x11, onopen: d24, onmessage: I7, onclose: R7, onerror: l20, openWhenHidden: j7, fetch: et2 } = s14, ct = an(s14, ["signal", "headers", "onopen", "onmessage", "onclose", "onerror", "openWhenHidden", "fetch"]);
  return new Promise((dt, vt2) => {
    const At = Object.assign({}, x11);
    At.accept || (At.accept = Gr);
    let Bt2;
    function Dt2() {
      Bt2.abort(), document.hidden || Rt2();
    }
    j7 || document.addEventListener("visibilitychange", Dt2);
    let er = sn2, Kt2 = 0;
    function nr() {
      document.removeEventListener("visibilitychange", Dt2), window.clearTimeout(Kt2), Bt2.abort();
    }
    h19 == null || h19.addEventListener("abort", () => {
      nr(), dt();
    });
    const lr = et2 ?? window.fetch, Vt2 = d24 ?? hn;
    async function Rt2() {
      var Ft2;
      Bt2 = new AbortController();
      try {
        const Ht = await lr(w5, Object.assign(Object.assign({}, ct), { headers: At, signal: Bt2.signal }));
        await Vt2(Ht), await en(Ht.body, nn2(fn3((Mt2) => {
          Mt2 ? At[fe2] = Mt2 : delete At[fe2];
        }, (Mt2) => {
          er = Mt2;
        }, I7))), R7 == null || R7(), nr(), dt();
      } catch (Ht) {
        if (!Bt2.signal.aborted)
          try {
            const Mt2 = (Ft2 = l20 == null ? void 0 : l20(Ht)) !== null && Ft2 !== void 0 ? Ft2 : er;
            window.clearTimeout(Kt2), Kt2 = window.setTimeout(Rt2, Mt2);
          } catch (Mt2) {
            nr(), vt2(Mt2);
          }
      }
    }
    Rt2();
  });
}
function hn(w5) {
  const s14 = w5.headers.get("content-type");
  if (!(s14 != null && s14.startsWith(Gr)))
    throw new Error(`Expected content-type to be ${Gr}, Actual: ${s14}`);
}
function un(w5, s14) {
  const h19 = new Uint8Array(w5.length + s14.length);
  return h19.set(w5), h19.set(s14, w5.length), h19;
}
function ln(w5, s14) {
  if (s14 >= w5.length)
    throw new Error("Index is out of buffer");
  const h19 = w5.slice(0, s14), x11 = w5.slice(s14);
  return [h19, x11];
}
function Zr(w5) {
  let s14 = "";
  return w5.forEach((h19) => {
    s14 += ("0" + (h19 & 255).toString(16)).slice(-2);
  }), s14;
}
function Qr(w5) {
  if (w5.length % 2 !== 0)
    throw new Error(`Cannot convert ${w5} to bytesArray`);
  const s14 = new Uint8Array(w5.length / 2);
  for (let h19 = 0; h19 < w5.length; h19 += 2)
    s14[h19 / 2] = parseInt(w5.slice(h19, h19 + 2), 16);
  return s14;
}
var Tr = class {
  constructor(s14) {
    Wr(this, "nonceLength", 24), Wr(this, "keyPair"), Wr(this, "sessionId"), this.keyPair = s14 ? this.createKeypairFromString(s14) : this.createKeypair(), this.sessionId = Zr(this.keyPair.publicKey);
  }
  createKeypair() {
    return Mr.box.keyPair();
  }
  createKeypairFromString(s14) {
    return {
      publicKey: Qr(s14.publicKey),
      secretKey: Qr(s14.secretKey)
    };
  }
  createNonce() {
    return Mr.randomBytes(this.nonceLength);
  }
  encrypt(s14, h19) {
    const x11 = new TextEncoder().encode(s14), d24 = this.createNonce(), I7 = Mr.box(x11, d24, h19, this.keyPair.secretKey);
    return un(d24, I7);
  }
  decrypt(s14, h19) {
    const [x11, d24] = ln(s14, this.nonceLength), I7 = Mr.box.open(
      d24,
      x11,
      h19,
      this.keyPair.secretKey
    );
    if (!I7)
      throw new Error(
        `Decryption error: 
 message: ${s14.toString()} 
 sender pubkey: ${h19.toString()} 
 keypair pubkey: ${this.keyPair.publicKey.toString()} 
 keypair secretkey: ${this.keyPair.secretKey.toString()}`
      );
    return new TextDecoder().decode(I7);
  }
  stringifyKeypair() {
    return {
      publicKey: Zr(this.keyPair.publicKey),
      secretKey: Zr(this.keyPair.secretKey)
    };
  }
};
new AbortController();
var xn = "https://bridge.mz.xyz";
var oe3 = {
  CONNECT: "[MizuWallet SSE Connect]"
};
var Pr = async (w5) => {
  const s14 = new URLSearchParams();
  return s14.append("client_id", w5.keypair.publicKey.toString()), new Promise(async (h19, x11) => {
    await cn2(`${xn}/bridge/events?${s14.toString()}`, {
      openWhenHidden: false,
      onopen(d24) {
        return d24.status === 200 ? (console.info(`${oe3.CONNECT} Opened`), Promise.resolve()) : (console.error(`${oe3.CONNECT} Failed to open`), Promise.reject());
      },
      onmessage(d24) {
        try {
          if (d24.data && d24.data.startsWith("{")) {
            const I7 = JSON.parse(d24.data);
            if (I7.message) {
              const R7 = new Tr({
                ...w5.keypair
              }), l20 = I7.message, j7 = Qr(l20), et2 = R7.decrypt(
                j7,
                Qr(I7.from.toString())
              ), ct = JSON.parse(et2);
              h19(ct);
            }
          }
        } catch (I7) {
          console.error(I7), x11(I7);
        }
      }
    });
  });
};
var Rr = typeof window < "u" && !!(window != null && window.TelegramWebviewProxy);
var ae2;
var se2;
typeof window < "u" && ((se2 = (ae2 = window == null ? void 0 : window.Telegram) == null ? void 0 : ae2.WebApp) != null && se2.openTelegramLink);
var pn2 = typeof window < "u" && (window == null ? void 0 : window.parent) != null && window != (window == null ? void 0 : window.parent);
function dn(w5, s14, h19) {
  if (s14 || (s14 = function() {
  }), h19 === void 0 && (h19 = ""), console.log("[Telegram.WebView] > postEvent", w5, h19), (window == null ? void 0 : window.TelegramWebviewProxy) !== void 0)
    window == null || window.TelegramWebviewProxy.postEvent(w5, JSON.stringify(h19)), s14();
  else if (pn2)
    try {
      var x11 = "https://web.telegram.org";
      x11 = "*", window == null || window.parent.postMessage(
        JSON.stringify({ eventType: w5, eventData: h19 }),
        x11
      ), s14();
    } catch (d24) {
      s14(d24);
    }
  else
    s14({ notAvailable: true });
}
var Dr = function(w5) {
  var x11, d24, I7, R7;
  if (typeof window < "u" && ((d24 = (x11 = window == null ? void 0 : window.Telegram) == null ? void 0 : x11.WebApp) != null && d24.openTelegramLink)) {
    (R7 = (I7 = window == null ? void 0 : window.Telegram) == null ? void 0 : I7.WebApp) == null || R7.openTelegramLink(w5);
    return;
  }
  let s14 = document.createElement("A");
  if (s14.href = w5, s14.protocol != "http:" && s14.protocol != "https:")
    throw console.error("[Telegram.WebApp] Url protocol is not supported", w5), Error("WebAppTgUrlInvalid");
  if (s14.hostname != "t.me")
    throw console.error("[Telegram.WebApp] Url host is not supported", w5), Error("WebAppTgUrlInvalid");
  var h19 = s14.pathname + s14.search;
  dn("web_app_open_tg_link", false, { path_full: h19 });
};
var Er = class _Er {
  static buildAction(s14) {
    return `${s14.prefix}${s14.action}_${s14.params.map((h19) => _Er.actionParamsEncode(h19)).join("_")}`;
  }
  static actionParamsEncode(s14) {
    return encodeURIComponent(s14).replace(/\./g, "%2E").replace(/%/g, "--");
  }
  static actionParamsDecode(s14) {
    return decodeURIComponent(s14.replace(/--/g, "%"));
  }
};
var rr = "mizuwallet-address";
var Cr = "mizuwallet-publickey";
var An3 = class {
  /**
   *
   * @param args.manifestURL Manifest URL
   */
  constructor(s14) {
    xt2(this, "manifestURL");
    xt2(this, "miniAppURL");
    if (!s14.manifestURL) throw new Error("manifestURL is required");
    this.manifestURL = s14.manifestURL, this.miniAppURL = ze(s14.network);
  }
  /**
   * Connect
   *
   * Open MizuWallet MiniApp to connect
   * Try to get Address info back
   *
   *
   * @returns
   */
  async connect() {
    var d24, I7, R7, l20;
    if (window != null && window.localStorage && ((d24 = window.localStorage) != null && d24.getItem(rr)) && ((I7 = window.localStorage) != null && I7.getItem(Cr)))
      return {
        address: ((R7 = window.localStorage.getItem(rr)) == null ? void 0 : R7.toString()) || "",
        publicKey: ((l20 = window.localStorage.getItem(Cr)) == null ? void 0 : l20.toString()) || ""
      };
    const s14 = new Tr(), h19 = Er.buildAction({
      prefix: "R_",
      action: "miniapp-connect",
      params: [s14.sessionId, this.manifestURL]
    });
    Dr(`${this.miniAppURL}?startapp=${h19}`);
    const x11 = await Pr({
      keypair: s14.stringifyKeypair()
    });
    if (window != null && window.localStorage && d7.isValid({
      input: x11 == null ? void 0 : x11.address,
      strict: true
    }))
      return window.localStorage.setItem(rr, x11 == null ? void 0 : x11.address), window.localStorage.setItem(Cr, x11 == null ? void 0 : x11.publicKey), {
        address: x11 == null ? void 0 : x11.address,
        publicKey: x11 == null ? void 0 : x11.publicKey
      };
    throw new Error(`${Sr.CONNECT} Error`);
  }
  disconnect() {
    window != null && window.localStorage.getItem(rr) && (window == null || window.localStorage.removeItem(rr)), window != null && window.localStorage.getItem(Cr) && (window == null || window.localStorage.removeItem(Cr));
  }
  async signAndSubmitTransaction(s14) {
    if (window != null && window.localStorage.getItem(rr)) {
      const h19 = new Tr(), x11 = Er.buildAction({
        prefix: "R_",
        action: "miniapp-transaction",
        params: [h19.sessionId, this.manifestURL, window == null ? void 0 : window.btoa(JSON.stringify(s14))]
      });
      Dr(`${this.miniAppURL}?startapp=${x11}`);
      const d24 = await Pr({
        keypair: h19.stringifyKeypair()
      });
      if (d24.cancel)
        throw new Error("User Canceled");
      return {
        hash: d24.hash
      };
    } else
      throw new Error(`${Sr.TRANSACTION} No address found`);
  }
  async signTransaction(s14) {
    if (window != null && window.localStorage.getItem(rr)) {
      const h19 = new Tr(), x11 = Er.buildAction({
        prefix: "R_",
        action: "miniapp-signtransaction",
        params: [h19.sessionId, this.manifestURL, s14.bcsToHex().toStringWithoutPrefix()]
      });
      Dr(`${this.miniAppURL}?startapp=${x11}`);
      const d24 = await Pr({
        keypair: h19.stringifyKeypair()
      });
      if (d24.cancel)
        throw new Error("User Canceled");
      return {
        signature: d24
      };
    } else
      throw new Error(`${Sr.TRANSACTION} No address found`);
  }
  async signMessage(s14) {
    if (window != null && window.localStorage.getItem(rr)) {
      const h19 = new Tr(), x11 = Er.buildAction({
        prefix: "R_",
        action: "miniapp-signmessage",
        params: [h19.sessionId, this.manifestURL, window == null ? void 0 : window.btoa(JSON.stringify(s14))]
      });
      Dr(`${this.miniAppURL}?startapp=${x11}`);
      const d24 = await Pr({
        keypair: h19.stringifyKeypair()
      });
      if (d24.cancel)
        throw new Error("User Canceled");
      return {
        data: d24
      };
    } else
      throw new Error(`${Sr.TRANSACTION} No address found`);
  }
};
var ur = "application/x-postmate-v1+json";
var wn = 5;
var yn2 = 0;
var gn3 = function() {
  return ++yn2;
};
var Ut2 = function() {
  var s14;
  return zt.debug ? (s14 = console).log.apply(s14, arguments) : null;
};
var mn2 = function(s14) {
  var h19 = document.createElement("a");
  h19.href = s14;
  var x11 = h19.protocol.length > 4 ? h19.protocol : window.location.protocol, d24 = h19.host.length ? h19.port === "80" || h19.port === "443" ? h19.hostname : h19.host : window.location.host;
  return h19.origin || x11 + "//" + d24;
};
var En = {
  handshake: 1,
  "handshake-reply": 1,
  call: 1,
  emit: 1,
  reply: 1,
  request: 1
  /**
   * Ensures that a message is safe to interpret
   * @param  {Object} message The postmate message being sent
   * @param  {String|Boolean} allowedOrigin The whitelisted origin or false to skip origin check
   * @return {Boolean}
   */
};
var Xr = function(s14, h19) {
  return !(typeof h19 == "string" && s14.origin !== h19 || !s14.data || typeof s14.data == "object" && !("postmate" in s14.data) || s14.data.type !== ur || !En[s14.data.postmate]);
};
var bn = function(s14, h19) {
  var x11 = typeof s14[h19] == "function" ? s14[h19]() : s14[h19];
  return zt.Promise.resolve(x11);
};
var Bn = function() {
  function w5(h19) {
    var x11 = this;
    this.parent = h19.parent, this.frame = h19.frame, this.child = h19.child, this.childOrigin = h19.childOrigin, this.events = {}, Ut2("Parent: Registering API"), Ut2("Parent: Awaiting messages..."), this.listener = function(d24) {
      if (!Xr(d24, x11.childOrigin)) return false;
      var I7 = ((d24 || {}).data || {}).value || {}, R7 = I7.data, l20 = I7.name;
      d24.data.postmate === "emit" && (Ut2("Parent: Received event emission: " + l20), l20 in x11.events && x11.events[l20].call(x11, R7));
    }, this.parent.addEventListener("message", this.listener, false), Ut2("Parent: Awaiting event emissions from Child");
  }
  var s14 = w5.prototype;
  return s14.get = function(x11) {
    var d24 = this;
    return new zt.Promise(function(I7) {
      var R7 = gn3(), l20 = function j7(et2) {
        et2.data.uid === R7 && et2.data.postmate === "reply" && (d24.parent.removeEventListener("message", j7, false), I7(et2.data.value));
      };
      d24.parent.addEventListener("message", l20, false), d24.child.postMessage({
        postmate: "request",
        type: ur,
        property: x11,
        uid: R7
      }, d24.childOrigin);
    });
  }, s14.call = function(x11, d24) {
    this.child.postMessage({
      postmate: "call",
      type: ur,
      property: x11,
      data: d24
    }, this.childOrigin);
  }, s14.on = function(x11, d24) {
    this.events[x11] = d24;
  }, s14.destroy = function() {
    Ut2("Parent: Destroying Postmate instance"), window.removeEventListener("message", this.listener, false), this.frame.parentNode.removeChild(this.frame);
  }, w5;
}();
var In = function() {
  function w5(h19) {
    var x11 = this;
    this.model = h19.model, this.parent = h19.parent, this.parentOrigin = h19.parentOrigin, this.child = h19.child, Ut2("Child: Registering API"), Ut2("Child: Awaiting messages..."), this.child.addEventListener("message", function(d24) {
      if (Xr(d24, x11.parentOrigin)) {
        Ut2("Child: Received request", d24.data);
        var I7 = d24.data, R7 = I7.property, l20 = I7.uid, j7 = I7.data;
        if (d24.data.postmate === "call") {
          R7 in x11.model && typeof x11.model[R7] == "function" && x11.model[R7](j7);
          return;
        }
        bn(x11.model, R7).then(function(et2) {
          return d24.source.postMessage({
            property: R7,
            postmate: "reply",
            type: ur,
            uid: l20,
            value: et2
          }, d24.origin);
        });
      }
    });
  }
  var s14 = w5.prototype;
  return s14.emit = function(x11, d24) {
    Ut2('Child: Emitting Event "' + x11 + '"', d24), this.parent.postMessage({
      postmate: "emit",
      type: ur,
      value: {
        name: x11,
        data: d24
      }
    }, this.parentOrigin);
  }, w5;
}();
var zt = function() {
  function w5(h19) {
    var x11 = h19.container, d24 = x11 === void 0 ? typeof d24 < "u" ? d24 : document.body : x11, I7 = h19.model, R7 = h19.url, l20 = h19.name, j7 = h19.classListArray, et2 = j7 === void 0 ? [] : j7;
    return this.parent = window, this.frame = document.createElement("iframe"), this.frame.name = l20 || "", this.frame.classList.add.apply(this.frame.classList, et2), d24.appendChild(this.frame), this.child = this.frame.contentWindow || this.frame.contentDocument.parentWindow, this.model = I7 || {}, this.sendHandshake(R7);
  }
  var s14 = w5.prototype;
  return s14.sendHandshake = function(x11) {
    var d24 = this, I7 = mn2(x11), R7 = 0, l20;
    return new w5.Promise(function(j7, et2) {
      var ct = function At(Bt2) {
        return Xr(Bt2, I7) ? Bt2.data.postmate === "handshake-reply" ? (clearInterval(l20), Ut2("Parent: Received handshake reply from Child"), d24.parent.removeEventListener("message", At, false), d24.childOrigin = Bt2.origin, Ut2("Parent: Saving Child origin", d24.childOrigin), j7(new Bn(d24))) : (Ut2("Parent: Invalid handshake reply"), et2("Failed handshake")) : false;
      };
      d24.parent.addEventListener("message", ct, false);
      var dt = function() {
        R7++, Ut2("Parent: Sending handshake attempt " + R7, {
          childOrigin: I7
        }), d24.child.postMessage({
          postmate: "handshake",
          type: ur,
          model: d24.model
        }, I7), R7 === wn && clearInterval(l20);
      }, vt2 = function() {
        dt(), l20 = setInterval(dt, 500);
      };
      d24.frame.attachEvent ? d24.frame.attachEvent("onload", vt2) : d24.frame.onload = vt2, Ut2("Parent: Loading frame", {
        url: x11
      }), d24.frame.src = x11;
    });
  }, w5;
}();
zt.debug = false;
zt.Promise = function() {
  try {
    return window ? window.Promise : Promise;
  } catch {
    return null;
  }
}();
zt.Model = function() {
  function w5(h19) {
    return this.child = window, this.model = h19, this.parent = this.child.parent, this.sendHandshakeReply();
  }
  var s14 = w5.prototype;
  return s14.sendHandshakeReply = function() {
    var x11 = this;
    return new zt.Promise(function(d24, I7) {
      var R7 = function l20(j7) {
        if (j7.data.postmate) {
          if (j7.data.postmate === "handshake") {
            Ut2("Child: Received handshake from Parent"), x11.child.removeEventListener("message", l20, false), Ut2("Child: Sending handshake reply to Parent"), j7.source.postMessage({
              postmate: "handshake-reply",
              type: ur
            }, j7.origin), x11.parentOrigin = j7.origin;
            var et2 = j7.data.model;
            return et2 && (Object.keys(et2).forEach(function(ct) {
              x11.model[ct] = et2[ct];
            }), Ut2("Child: Inherited and extended model from Parent")), Ut2("Child: Saving Parent origin", x11.parentOrigin), d24(new In(x11));
          }
          return I7("Handshake Reply Failed");
        }
      };
      x11.child.addEventListener("message", R7, false);
    });
  }, w5;
}();
var Un = "https://mizu.io";
var vn2 = () => {
  const w5 = document.createElement("style");
  w5.innerHTML = `
	  .mizu-wallet-frame {
		position: fixed;
		top: 0;
		left: 0;
		width: 100vw;
		height: 100vh;
		border: none;
		z-index: 999999999;
		inset: 0px;
		color-scheme: light;
	  }
	`, document.head.appendChild(w5);
};
var Rn = class {
  /**
   *
   * @param args.manifestURL Manifest URL
   */
  constructor(s14) {
    xt2(this, "authCode");
    xt2(this, "manifestURL");
    xt2(this, "network");
    xt2(this, "mizuClient");
    xt2(this, "provider");
    xt2(this, "origin");
    if (!s14.manifestURL) throw new Error("manifestURL is required");
    this.authCode = "", this.manifestURL = s14.manifestURL, this.network = s14.network, this.mizuClient = s14.mizuClient, this.origin = Un, vn2();
  }
  async connect() {
    const s14 = await new zt({
      container: document.body,
      // Element to inject frame into
      url: `${this.origin}/wallet/checkLogin?network=${this.network}`,
      name: "mizu-wallet-login",
      classListArray: ["mizu-wallet-frame", "mizu-wallet-login-frame"],
      model: {
        manifestURL: this.manifestURL,
        network: this.network,
        appId: this.mizuClient.appId
      }
    });
    return s14.on("close-frame", () => {
      s14.destroy();
    }), new Promise((h19, x11) => {
      s14.on("login", (d24) => {
        this.authCode = d24.code, h19({
          address: d24.address,
          publicKey: ""
        });
      });
    });
  }
  async disconnect() {
    var h19;
    const s14 = await new zt({
      container: document.body,
      // Element to inject frame into
      url: `${this.origin}/wallet/logout?network=${this.network}`,
      name: "mizu-wallet-logout",
      classListArray: ["mizu-wallet-frame", "mizu-wallet-logout-frame"],
      model: {
        manifestURL: this.manifestURL,
        network: this.network,
        appId: this.mizuClient.appId
      }
    });
    s14.on("close-frame", () => {
      s14.destroy();
    }), await ((h19 = this.mizuClient) == null ? void 0 : h19.logout());
  }
  async signAndSubmitTransaction(s14) {
    var h19;
    try {
      const x11 = await ((h19 = this.mizuClient) == null ? void 0 : h19.createOrderWithCode({
        code: this.authCode,
        payload: s14
      }));
      if (!x11) throw new Error("Transaction creation failed");
      const d24 = await new zt({
        container: document.body,
        // Element to inject frame into
        url: `${this.origin}/wallet/checkLogin?redirect_url=${encodeURIComponent("/wallet/transaction")}&network=${this.network}`,
        name: "mizu-wallet-login",
        classListArray: ["mizu-wallet-frame", "mizu-wallet-sign-frame"],
        model: {
          manifestURL: this.manifestURL,
          network: this.network,
          appId: this.mizuClient.appId,
          transactionInfo: {
            orderId: x11,
            payload: s14
          }
        }
      });
      return d24.on("close-frame", () => {
        d24.destroy();
      }), d24.on("cancel", () => {
        throw new Error("User Canceled");
      }), new Promise((I7, R7) => {
        d24.on("submitted", (l20) => {
          if (l20.error)
            return R7(l20.error);
          I7({
            // hash: data.transactions?.filter((tx: any) => tx.type === 2)?.[0]?.hash || '',
            hash: l20.hash
          });
        });
      });
    } catch (x11) {
      throw console.error(x11), x11;
    }
  }
  async signTransaction(s14) {
    try {
      const h19 = await new zt({
        container: document.body,
        // Element to inject frame into
        url: `${this.origin}/wallet/checkLogin?redirect_url=${encodeURIComponent("/wallet/sign_transaction")}&network=${this.network}`,
        name: "mizu-wallet-login",
        classListArray: ["mizu-wallet-frame", "mizu-wallet-sign-frame"],
        model: {
          manifestURL: this.manifestURL,
          network: this.network,
          appId: this.mizuClient.appId,
          transactionInfo: {
            transaction: s14.bcsToHex().toStringWithoutPrefix()
          }
        }
      });
      return h19.on("close-frame", () => {
        h19.destroy();
      }), h19.on("cancel", () => {
        throw new Error("User Canceled");
      }), new Promise((x11, d24) => {
        h19.on("sign_transaction", (I7) => {
          if (I7.error)
            return d24(I7.error);
          x11({
            ...I7.result
          });
        });
      });
    } catch (h19) {
      throw console.error(h19), h19;
    }
  }
  async signMessage(s14) {
    try {
      const h19 = await new zt({
        container: document.body,
        // Element to inject frame into
        url: `${this.origin}/wallet/checkLogin?redirect_url=${encodeURIComponent("/wallet/sign_message")}&network=${this.network}`,
        name: "mizu-wallet-login",
        classListArray: ["mizu-wallet-frame", "mizu-wallet-sign-frame"],
        model: {
          manifestURL: this.manifestURL,
          network: this.network,
          appId: this.mizuClient.appId,
          messageInfo: {
            message: s14.message,
            nonce: s14.nonce
          }
        }
      });
      return h19.on("close-frame", () => {
        h19.destroy();
      }), h19.on("cancel", () => {
        throw new Error("User Canceled");
      }), new Promise((x11, d24) => {
        h19.on("sign_message", (I7) => {
          if (I7.error)
            return d24(I7.error);
          x11({
            data: I7.result
          });
        });
      });
    } catch (h19) {
      throw console.error(h19), h19;
    }
  }
};
var Fn = class {
  constructor(s14) {
    xt2(this, "url", Je);
    xt2(this, "version", "1.0.0");
    xt2(this, "name", _e);
    xt2(this, "icon", We);
    xt2(this, "chains", Re);
    xt2(this, "accounts", []);
    xt2(this, "provider");
    xt2(this, "mizuClient");
    xt2(this, "telegramMiniAppHelper");
    xt2(this, "websiteHelper");
    xt2(this, "accountInfo");
    xt2(this, "account", async () => this.accountInfo || {
      address: "",
      publicKey: ""
    });
    xt2(this, "connect", async () => {
      var s15;
      try {
        if (Rr)
          if (this.telegramMiniAppHelper)
            this.accountInfo = await this.telegramMiniAppHelper.connect();
          else
            throw new Error(`${Sr.CONNECT} Please pass a valid manifestURL`);
        else
          this.accountInfo = await ((s15 = this.websiteHelper) == null ? void 0 : s15.connect());
        return {
          args: {
            ...this.accountInfo
          },
          status: Gt2.APPROVED
        };
      } catch {
        return {
          status: Gt2.REJECTED
        };
      }
    });
    xt2(this, "network", async () => ({
      name: this.provider.network,
      chainId: this.provider.network === "mainnet" ? 1 : 2
    }));
    xt2(this, "disconnect", async () => {
      var s15, h19;
      try {
        Rr ? await ((s15 = this.telegramMiniAppHelper) == null ? void 0 : s15.disconnect()) : await ((h19 = this.websiteHelper) == null ? void 0 : h19.disconnect());
      } catch (x11) {
        throw x11;
      }
    });
    xt2(this, "signTransaction", async (s15, h19) => {
      var d24, I7;
      console.log(h19);
      let x11 = {};
      if (Rr ? x11 = await ((d24 = this.telegramMiniAppHelper) == null ? void 0 : d24.signTransaction(s15)) : x11 = await ((I7 = this.websiteHelper) == null ? void 0 : I7.signTransaction(s15)), x11.signature) {
        const R7 = new n20(ue2.Buffer.from(x11.signature, "hex"));
        return {
          args: r27.deserialize(R7),
          status: Gt2.APPROVED
        };
      } else
        return {
          status: Gt2.REJECTED
        };
    });
    xt2(this, "signAndSubmitTransaction", async (s15) => {
      var h19, x11;
      try {
        let d24 = {};
        return Rr ? d24 = await ((h19 = this.telegramMiniAppHelper) == null ? void 0 : h19.signAndSubmitTransaction(s15.payload)) : d24 = await ((x11 = this.websiteHelper) == null ? void 0 : x11.signAndSubmitTransaction(s15.payload)), d24 != null && d24.hash ? {
          args: d24,
          status: Gt2.APPROVED
        } : {
          status: Gt2.REJECTED
        };
      } catch (d24) {
        throw console.error(d24.message || d24), new ne3(qr.InternalError);
      }
    });
    xt2(this, "signMessage", async (s15) => {
      var h19, x11;
      try {
        const { message: d24, nonce: I7, ...R7 } = s15;
        let l20 = {};
        return Rr ? l20 = await ((h19 = this.telegramMiniAppHelper) == null ? void 0 : h19.signMessage({
          message: d24,
          nonce: I7
        })) : l20 = await ((x11 = this.websiteHelper) == null ? void 0 : x11.signMessage({
          message: d24,
          nonce: I7
        })), l20 != null && l20.data ? {
          args: {
            ...l20 == null ? void 0 : l20.data,
            ...R7
          },
          status: Gt2.APPROVED
        } : {
          status: Gt2.REJECTED
        };
      } catch (d24) {
        throw console.error(d24.message || d24), new ne3(qr.InternalError);
      }
    });
    xt2(this, "onAccountChange", async () => Promise.resolve());
    xt2(this, "onNetworkChange", async () => Promise.resolve());
    if (!s14.network) throw new Error("MizuWallet: network is required");
    this.mizuClient = new h18({
      appId: s14.appId || He(s14.network),
      network: s14.network
    }), this.provider = {
      network: s14.network,
      address: ""
    }, s14 != null && s14.manifestURL && (this.telegramMiniAppHelper = new An3({
      manifestURL: s14 == null ? void 0 : s14.manifestURL,
      network: s14.network
    })), this.websiteHelper = new Rn({
      manifestURL: s14.manifestURL,
      network: s14.network,
      mizuClient: this.mizuClient
    });
  }
  get features() {
    return {
      "aptos:connect": {
        version: "1.0.0",
        connect: this.connect
      },
      "aptos:network": {
        version: "1.0.0",
        network: this.network
      },
      "aptos:disconnect": {
        version: "1.0.0",
        disconnect: this.disconnect
      },
      "aptos:signTransaction": {
        version: "1.0.0",
        signTransaction: this.signTransaction
      },
      "aptos:signAndSubmitTransaction": {
        version: "1.1.0",
        signAndSubmitTransaction: this.signAndSubmitTransaction
      },
      "aptos:signMessage": {
        version: "1.0.0",
        signMessage: this.signMessage
      },
      "aptos:onAccountChange": {
        version: "1.0.0",
        onAccountChange: this.onAccountChange
      },
      "aptos:onNetworkChange": {
        version: "1.0.0",
        onNetworkChange: this.onNetworkChange
      },
      "aptos:account": {
        version: "1.0.0",
        account: this.account
      }
    };
  }
};

// node_modules/@aptos-labs/wallet-adapter-core/dist/index.mjs
var import_eventemitter35 = __toESM(require_eventemitter3(), 1);
var import_buffer = __toESM(require_buffer(), 1);
var import_tweetnacl3 = __toESM(require_nacl_fast(), 1);
var WALLET_ADAPTER_CORE_VERSION = "4.15.0";
function getSDKWallets(dappConfig) {
  const sdkWallets = [];
  if (typeof window !== "undefined") {
    sdkWallets.push(
      new AptosConnectWallet({
        network: dappConfig == null ? void 0 : dappConfig.network,
        dappId: dappConfig == null ? void 0 : dappConfig.aptosConnectDappId
      })
    );
    if ((dappConfig == null ? void 0 : dappConfig.mizuwallet) && (dappConfig == null ? void 0 : dappConfig.network) && [e.MAINNET, e.TESTNET].includes(dappConfig.network)) {
      sdkWallets.push(
        new Fn({
          network: dappConfig.network,
          manifestURL: dappConfig.mizuwallet.manifestURL,
          appId: dappConfig.mizuwallet.appId
        })
      );
    }
  }
  if ((dappConfig == null ? void 0 : dappConfig.network) === e.MAINNET) {
    sdkWallets.push(new h());
  } else {
    sdkWallets.push(new W());
  }
  return sdkWallets;
}
var WalletReadyState = ((WalletReadyState2) => {
  WalletReadyState2["Installed"] = "Installed";
  WalletReadyState2["NotDetected"] = "NotDetected";
  WalletReadyState2["Loadable"] = "Loadable";
  WalletReadyState2["Unsupported"] = "Unsupported";
  return WalletReadyState2;
})(WalletReadyState || {});
var NetworkName2 = ((NetworkName22) => {
  NetworkName22["Mainnet"] = "mainnet";
  NetworkName22["Testnet"] = "testnet";
  NetworkName22["Devnet"] = "devnet";
  return NetworkName22;
})(NetworkName2 || {});
var ChainIdToAnsSupportedNetworkMap = {
  "1": "mainnet",
  "2": "testnet"
};
var APTOS_CONNECT_BASE_URL = "https://aptosconnect.app";
var APTOS_CONNECT_ACCOUNT_URL = "https://aptosconnect.app/dashboard/main-account";
var WalletError = class extends Error {
  constructor(message, error) {
    super(message);
    this.error = error;
  }
};
var WalletNotSelectedError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotSelectedError";
  }
};
var WalletNotReadyError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotReadyError";
  }
};
var WalletConnectionError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletConnectionError";
  }
};
var WalletDisconnectionError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletDisconnectionError";
  }
};
var WalletAccountError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletAccountError";
  }
};
var WalletGetNetworkError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletGetNetworkError";
  }
};
var WalletAccountChangeError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletAccountChangeError";
  }
};
var WalletNetworkChangeError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNetworkChangeError";
  }
};
var WalletNotConnectedError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotConnectedError";
  }
};
var WalletSignMessageError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSignMessageError";
  }
};
var WalletSignMessageAndVerifyError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSignMessageAndVerifyError";
  }
};
var WalletSignAndSubmitMessageError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSignAndSubmitMessageError";
  }
};
var WalletSignTransactionError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSignTransactionError";
  }
};
var WalletNotSupportedMethod = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotSupportedMethod";
  }
};
var WalletChangeNetworkError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletChangeNetworkError";
  }
};
function convertNetwork(networkInfo) {
  switch (networkInfo == null ? void 0 : networkInfo.name) {
    case "mainnet":
      return e.MAINNET;
    case "testnet":
      return e.TESTNET;
    case "devnet":
      return e.DEVNET;
    case "local":
      return e.LOCAL;
    default:
      throw new Error("Invalid Aptos network name");
  }
}
function convertV2TransactionPayloadToV1BCSPayload(payload) {
  const deserializer = new bcs_exports.Deserializer(payload.bcsToBytes());
  return aptos_types_exports.TransactionPayload.deserialize(deserializer);
}
function convertV2PayloadToV1JSONPayload(payload) {
  var _a, _b;
  if ("bytecode" in payload) {
    throw new Error("script payload not supported");
  } else if ("multisigAddress" in payload) {
    const stringTypeTags = (_a = payload.typeArguments) == null ? void 0 : _a.map(
      (typeTag) => {
        if (typeTag instanceof t) {
          return typeTag.toString();
        }
        return typeTag;
      }
    );
    const newPayload = {
      type: "multisig_payload",
      multisig_address: payload.multisigAddress.toString(),
      function: payload.function,
      type_arguments: stringTypeTags || [],
      arguments: payload.functionArguments
    };
    return newPayload;
  } else {
    const stringTypeTags = (_b = payload.typeArguments) == null ? void 0 : _b.map(
      (typeTag) => {
        if (typeTag instanceof t) {
          return typeTag.toString();
        }
        return typeTag;
      }
    );
    const newPayload = {
      type: "entry_function_payload",
      function: payload.function,
      type_arguments: stringTypeTags || [],
      arguments: payload.functionArguments
    };
    return newPayload;
  }
}
async function generateTransactionPayloadFromV1Input(aptosConfig, inputV1) {
  if ("function" in inputV1) {
    const inputV2 = {
      function: inputV1.function,
      functionArguments: inputV1.arguments,
      typeArguments: inputV1.type_arguments
    };
    return Vn({ ...inputV2, aptosConfig });
  }
  throw new Error("Payload type not supported");
}
function isMobile() {
  return /Mobile|iP(hone|od|ad)|Android|BlackBerry|IEMobile|Kindle|NetFront|Silk-Accelerated|(hpw|web)OS|Fennec|Minimo|Opera M(obi|ini)|Blazer|Dolfin|Dolphin|Skyfire|Zune/i.test(
    navigator.userAgent
  );
}
function isInAppBrowser() {
  const isIphone = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(
    navigator.userAgent
  );
  const isAndroid = /(Android).*Version\/[\d.]+.*Chrome\/[^\s]+ Mobile/i.test(
    navigator.userAgent
  );
  return isIphone || isAndroid;
}
function isRedirectable() {
  if (typeof navigator === "undefined" || !navigator)
    return false;
  return isMobile() && !isInAppBrowser();
}
function generalizedErrorMessage(error) {
  return typeof error === "object" && "message" in error ? error.message : error;
}
var areBCSArguments = (args) => {
  if (args.length === 0)
    return false;
  return args.every(
    (arg) => arg instanceof B
  );
};
var getAptosConfig = (networkInfo) => {
  if (!networkInfo) {
    throw new Error("Undefined network");
  }
  if (isAptosNetwork(networkInfo)) {
    return new l({
      network: convertNetwork(networkInfo)
    });
  }
  return new l({
    network: e.CUSTOM,
    fullnode: networkInfo.url
  });
};
var isAptosNetwork = (networkInfo) => {
  if (!networkInfo) {
    throw new Error("Undefined network");
  }
  return o3[networkInfo.name] !== void 0;
};
var fetchDevnetChainId = async () => {
  const aptos = new t4();
  return await aptos.getChainId();
};
var LOCAL_STORAGE_ITEM_KEY = "AptosWalletName";
function setLocalStorage(walletName2) {
  localStorage.setItem(LOCAL_STORAGE_ITEM_KEY, walletName2);
}
function removeLocalStorage() {
  localStorage.removeItem(LOCAL_STORAGE_ITEM_KEY);
}
function getLocalStorage() {
  localStorage.getItem(LOCAL_STORAGE_ITEM_KEY);
}
function scopePollingDetectionStrategy(detect) {
  if (typeof window === "undefined" || typeof document === "undefined")
    return;
  const disposers = [];
  function detectAndDispose() {
    const detected = detect();
    if (detected) {
      for (const dispose of disposers) {
        dispose();
      }
    }
  }
  const interval = setInterval(detectAndDispose, 1e3);
  disposers.push(() => clearInterval(interval));
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", detectAndDispose, {
      once: true
    });
    disposers.push(
      () => document.removeEventListener("DOMContentLoaded", detectAndDispose)
    );
  }
  if (document.readyState !== "complete") {
    window.addEventListener("load", detectAndDispose, { once: true });
    disposers.push(() => window.removeEventListener("load", detectAndDispose));
  }
  detectAndDispose();
}
function partitionWallets(wallets, partitionFunction = isInstalledOrLoadable) {
  const defaultWallets = [];
  const moreWallets = [];
  for (const wallet of wallets) {
    if (partitionFunction(wallet))
      defaultWallets.push(wallet);
    else
      moreWallets.push(wallet);
  }
  return { defaultWallets, moreWallets };
}
function isInstalledOrLoadable(wallet) {
  return wallet.readyState === "Installed" || wallet.readyState === "Loadable";
}
function isInstallRequired(wallet) {
  const isWalletReady = isInstalledOrLoadable(wallet);
  const isMobile2 = !isWalletReady && isRedirectable();
  return !isMobile2 && !isWalletReady;
}
function truncateAddress(address) {
  if (!address)
    return;
  return `${address.slice(0, 6)}...${address.slice(-5)}`;
}
function isAptosConnectWallet(wallet) {
  if (!wallet.url)
    return false;
  return wallet.url.startsWith(APTOS_CONNECT_BASE_URL);
}
function getAptosConnectWallets(wallets) {
  const { defaultWallets, moreWallets } = partitionWallets(
    wallets,
    isAptosConnectWallet
  );
  return { aptosConnectWallets: defaultWallets, otherWallets: moreWallets };
}
function groupAndSortWallets(wallets, options) {
  const { aptosConnectWallets, otherWallets } = getAptosConnectWallets(wallets);
  const { defaultWallets, moreWallets } = partitionWallets(otherWallets);
  if (options == null ? void 0 : options.sortAptosConnectWallets) {
    aptosConnectWallets.sort(options.sortAptosConnectWallets);
  }
  if (options == null ? void 0 : options.sortAvailableWallets) {
    defaultWallets.sort(options.sortAvailableWallets);
  }
  if (options == null ? void 0 : options.sortInstallableWallets) {
    moreWallets.sort(options.sortInstallableWallets);
  }
  return {
    aptosConnectWallets,
    availableWallets: defaultWallets,
    installableWallets: moreWallets
  };
}
var WalletCoreV1 = class extends import_eventemitter35.default {
  async connect(wallet) {
    const account = await wallet.connect();
    return account;
  }
  async resolveSignAndSubmitTransaction(payloadData, network, wallet, transactionInput) {
    var _a, _b, _c, _d, _e2, _f, _g, _h;
    if (areBCSArguments(payloadData.functionArguments)) {
      const aptosConfig = getAptosConfig(network);
      const newPayload = await Vn({
        ...payloadData,
        aptosConfig
      });
      const oldTransactionPayload2 = convertV2TransactionPayloadToV1BCSPayload(newPayload);
      return await this.signAndSubmitBCSTransaction(
        oldTransactionPayload2,
        wallet,
        {
          max_gas_amount: ((_a = transactionInput.options) == null ? void 0 : _a.maxGasAmount) ? BigInt((_b = transactionInput.options) == null ? void 0 : _b.maxGasAmount) : void 0,
          gas_unit_price: ((_c = transactionInput.options) == null ? void 0 : _c.gasUnitPrice) ? BigInt((_d = transactionInput.options) == null ? void 0 : _d.gasUnitPrice) : void 0
        }
      );
    }
    const oldTransactionPayload = convertV2PayloadToV1JSONPayload(payloadData);
    return await this.signAndSubmitTransaction(oldTransactionPayload, wallet, {
      max_gas_amount: ((_e2 = transactionInput.options) == null ? void 0 : _e2.maxGasAmount) ? BigInt((_f = transactionInput.options) == null ? void 0 : _f.maxGasAmount) : void 0,
      gas_unit_price: ((_g = transactionInput.options) == null ? void 0 : _g.gasUnitPrice) ? BigInt((_h = transactionInput.options) == null ? void 0 : _h.gasUnitPrice) : void 0
    });
  }
  async signAndSubmitTransaction(transaction, wallet, options) {
    try {
      const response = await wallet.signAndSubmitTransaction(
        transaction,
        options
      );
      return response;
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletSignAndSubmitMessageError(errMsg).message;
    }
  }
  async signAndSubmitBCSTransaction(transaction, wallet, options) {
    if (!("signAndSubmitBCSTransaction" in wallet)) {
      throw new WalletNotSupportedMethod(
        `Submit a BCS Transaction is not supported by ${wallet.name}`
      ).message;
    }
    try {
      const response = await wallet.signAndSubmitBCSTransaction(
        transaction,
        options
      );
      return response;
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletSignAndSubmitMessageError(errMsg).message;
    }
  }
  async signTransaction(transaction, wallet, options) {
    try {
      const response = await wallet.signTransaction(
        transaction,
        options
      );
      return response;
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletSignTransactionError(errMsg).message;
    }
  }
  async signMessageAndVerify(message, wallet, account) {
    try {
      const response = await wallet.signMessage(message);
      if (!response)
        throw new WalletSignMessageAndVerifyError("Failed to sign a message").message;
      console.log("signMessageAndVerify signMessage response", response);
      let verified = false;
      if (Array.isArray(response.signature)) {
        const { fullMessage, signature, bitmap } = response;
        if (bitmap) {
          const minKeysRequired = account.minKeysRequired;
          if (signature.length < minKeysRequired) {
            verified = false;
          } else {
            const bits = Array.from(bitmap).flatMap(
              (n27) => Array.from({ length: 8 }).map((_8, i49) => n27 >> i49 & 1)
            );
            const index = bits.map((_8, i49) => i49).filter((i49) => bits[i49]);
            const publicKeys = account.publicKey;
            const matchedPublicKeys = publicKeys.filter(
              (_8, i49) => index.includes(i49)
            );
            verified = true;
            for (let i49 = 0; i49 < signature.length; i49++) {
              const isSigVerified = import_tweetnacl3.default.sign.detached.verify(
                import_buffer.Buffer.from(fullMessage),
                import_buffer.Buffer.from(signature[i49], "hex"),
                import_buffer.Buffer.from(matchedPublicKeys[i49], "hex")
              );
              if (!isSigVerified) {
                verified = false;
                break;
              }
            }
          }
        } else {
          throw new WalletSignMessageAndVerifyError("Failed to get a bitmap").message;
        }
      } else {
        const currentAccountPublicKey = new HexString(
          account.publicKey
        );
        const signature = new HexString(
          response.signature
        );
        verified = import_tweetnacl3.default.sign.detached.verify(
          import_buffer.Buffer.from(response.fullMessage),
          import_buffer.Buffer.from(signature.noPrefix(), "hex"),
          import_buffer.Buffer.from(currentAccountPublicKey.noPrefix(), "hex")
        );
      }
      return verified;
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignMessageAndVerifyError(errMsg).message;
    }
  }
};
var WalletStandardCore = class {
  async connect(wallet) {
    const response = await wallet.connect();
    if (response.status === r4.REJECTED) {
      throw new WalletConnectionError("User has rejected the request").message;
    }
    return response.args;
  }
  async signAndSubmitTransaction(transactionInput, aptos, account, wallet, standardWallets) {
    var _a, _b, _c;
    try {
      const standardWallet = standardWallets.find(
        (standardWallet2) => wallet.name === standardWallet2.name
      );
      if (((_a = standardWallet == null ? void 0 : standardWallet.features["aptos:signAndSubmitTransaction"]) == null ? void 0 : _a.version) !== "1.1.0") {
        const transaction2 = await aptos.transaction.build.simple({
          sender: account.address.toString(),
          data: transactionInput.data,
          options: transactionInput.options
        });
        const response2 = await wallet.signAndSubmitTransaction(
          transaction2
        );
        if (response2.status === r4.REJECTED) {
          throw new WalletConnectionError("User has rejected the request").message;
        }
        return response2.args;
      }
      const transaction = {
        gasUnitPrice: (_b = transactionInput.options) == null ? void 0 : _b.gasUnitPrice,
        maxGasAmount: (_c = transactionInput.options) == null ? void 0 : _c.maxGasAmount,
        payload: transactionInput.data
      };
      const response = await wallet.signAndSubmitTransaction(
        transaction
      );
      if (response.status === r4.REJECTED) {
        throw new WalletConnectionError("User has rejected the request").message;
      }
      return response.args;
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignAndSubmitMessageError(errMsg).message;
    }
  }
  async signTransaction(transaction, wallet, asFeePayer) {
    const response = await wallet.signTransaction(
      transaction,
      asFeePayer
    );
    if (response.status === r4.REJECTED) {
      throw new WalletConnectionError("User has rejected the request").message;
    }
    return response.args;
  }
  async signMessage(message, wallet) {
    try {
      const response = await wallet.signMessage(
        message
      );
      if (response.status === r4.REJECTED) {
        throw new WalletConnectionError("User has rejected the request").message;
      }
      return response.args;
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignMessageError(errMsg).message;
    }
  }
  async signMessageAndVerify(message, wallet) {
    try {
      const response = await wallet.signMessage(
        message
      );
      const account = await wallet.account();
      if (response.status === r4.REJECTED) {
        throw new WalletConnectionError("Failed to sign a message").message;
      }
      if (account.publicKey instanceof f && account.publicKey.variant === x.Keyless) {
        return true;
      }
      let verified = false;
      if (response.args.signature instanceof y) {
        if (!(account.publicKey instanceof d)) {
          throw new WalletSignMessageAndVerifyError(
            "Public key and Signature type mismatch"
          ).message;
        }
        const { fullMessage, signature } = response.args;
        const bitmap = signature.bitmap;
        if (bitmap) {
          const minKeysRequired = account.publicKey.threshold;
          if (signature.signatures.length < minKeysRequired) {
            verified = false;
          } else {
            verified = account.publicKey.verifySignature({
              message: new TextEncoder().encode(fullMessage),
              signature
            });
          }
        }
      } else {
        verified = account.publicKey.verifySignature({
          message: new TextEncoder().encode(response.args.fullMessage),
          signature: response.args.signature
        });
      }
      return verified;
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignMessageAndVerifyError(errMsg).message;
    }
  }
};
var GA4 = class {
  constructor() {
    this.aptosGAID = true;
    this.injectGA(this.aptosGAID);
  }
  gtag(a26, b12, c16) {
    let dataLayer = window.dataLayer || [];
    dataLayer.push(arguments);
  }
  injectGA(gaID) {
    if (typeof window === "undefined")
      return;
    if (!gaID)
      return;
    const head = document.getElementsByTagName("head")[0];
    var myScript = document.createElement("script");
    myScript.setAttribute(
      "src",
      `https://www.googletagmanager.com/gtag/js?id=${gaID}`
    );
    const that = this;
    myScript.onload = function() {
      that.gtag("js", /* @__PURE__ */ new Date());
      that.gtag("config", `${gaID}`, {
        send_page_view: false
      });
    };
    head.insertBefore(myScript, head.children[1]);
  }
};
var aptosStandardSupportedWalletList = [
  {
    name: "Nightly",
    url: "https://chromewebstore.google.com/detail/nightly/fiikommddbeccaoicoejoniammnalkfa?hl=en",
    icon: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyOC4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iV2Fyc3R3YV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCINCgkgdmlld0JveD0iMCAwIDg1MS41IDg1MS41IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA4NTEuNSA4NTEuNTsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4NCgkuc3Qwe2ZpbGw6IzYwNjdGOTt9DQoJLnN0MXtmaWxsOiNGN0Y3Rjc7fQ0KPC9zdHlsZT4NCjxnPg0KCTxnIGlkPSJXYXJzdHdhXzJfMDAwMDAwMTQ2MDk2NTQyNTMxODA5NDY0NjAwMDAwMDg2NDc4NTIwMDIxMTY5MTg2ODhfIj4NCgkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTEyNCwwaDYwMy42YzY4LjUsMCwxMjQsNTUuNSwxMjQsMTI0djYwMy42YzAsNjguNS01NS41LDEyNC0xMjQsMTI0SDEyNGMtNjguNSwwLTEyNC01NS41LTEyNC0xMjRWMTI0DQoJCQlDMCw1NS41LDU1LjUsMCwxMjQsMHoiLz4NCgk8L2c+DQoJPGcgaWQ9IldhcnN0d2FfMyI+DQoJCTxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik02MjMuNSwxNzAuM2MtMzcuNCw1Mi4yLTg0LjIsODguNC0xMzkuNSwxMTIuNmMtMTkuMi01LjMtMzguOS04LTU4LjMtNy44Yy0xOS40LTAuMi0zOS4xLDIuNi01OC4zLDcuOA0KCQkJYy01NS4zLTI0LjMtMTAyLjEtNjAuMy0xMzkuNS0xMTIuNmMtMTEuMywyOC40LTU0LjgsMTI2LjQtMi42LDI2My40YzAsMC0xNi43LDcxLjUsMTQsMTMyLjljMCwwLDQ0LjQtMjAuMSw3OS43LDguMg0KCQkJYzM2LjksMjkuOSwyNS4xLDU4LjcsNTEuMSw4My41YzIyLjQsMjIuOSw1NS43LDIyLjksNTUuNywyMi45czMzLjMsMCw1NS43LTIyLjhjMjYtMjQuNywxNC4zLTUzLjUsNTEuMS04My41DQoJCQljMzUuMi0yOC4zLDc5LjctOC4yLDc5LjctOC4yYzMwLjYtNjEuNCwxNC0xMzIuOSwxNC0xMzIuOUM2NzguMywyOTYuNyw2MzQuOSwxOTguNyw2MjMuNSwxNzAuM3ogTTI1My4xLDQxNC44DQoJCQljLTI4LjQtNTguMy0zNi4yLTEzOC4zLTE4LjMtMjAxLjVjMjMuNyw2MCw1NS45LDg2LjksOTQuMiwxMTUuM0MzMTIuOCwzNjIuMywyODIuMywzOTQuMSwyNTMuMSw0MTQuOHogTTMzNC44LDUxNy41DQoJCQljLTIyLjQtOS45LTI3LjEtMjkuNC0yNy4xLTI5LjRjMzAuNS0xOS4yLDc1LjQtNC41LDc2LjgsNDAuOUMzNjAuOSw1MTQuNywzNTMsNTI1LjQsMzM0LjgsNTE3LjV6IE00MjUuNyw2NzguNw0KCQkJYy0xNiwwLTI5LTExLjUtMjktMjUuNnMxMy0yNS42LDI5LTI1LjZzMjksMTEuNSwyOSwyNS42QzQ1NC43LDY2Ny4zLDQ0MS43LDY3OC43LDQyNS43LDY3OC43eiBNNTE2LjcsNTE3LjUNCgkJCWMtMTguMiw4LTI2LTIuOC00OS43LDExLjVjMS41LTQ1LjQsNDYuMi02MC4xLDc2LjgtNDAuOUM1NDMuOCw0ODgsNTM5LDUwNy42LDUxNi43LDUxNy41eiBNNTk4LjMsNDE0LjgNCgkJCWMtMjkuMS0yMC43LTU5LjctNTIuNC03Ni04Ni4yYzM4LjMtMjguNCw3MC42LTU1LjQsOTQuMi0xMTUuM0M2MzQuNiwyNzYuNSw2MjYuOCwzNTYuNiw1OTguMyw0MTQuOHoiLz4NCgk8L2c+DQo8L2c+DQo8L3N2Zz4NCg==",
    readyState: "NotDetected",
    isAIP62Standard: true
  },
  {
    name: "Petra",
    url: "https://chromewebstore.google.com/detail/petra-aptos-wallet/ejjladinnckdgjemekebdpeokbikhfci?hl=en",
    icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAWbSURBVHgB7Z09c9NYFIaPlFSpUqQNK6rQhbSkWJghLZP9BesxfwAqytg1xe7+AY+3go5ACzObBkpwSqrVQkuRCiqkva8UZW1je22wpHPveZ8ZRU6wwwznueee+6FLJCuSdzrb7nZTNjaOJc9/ctdNiaJESPPkeeq+phLH5/L162k0HJ7JikTLvtEFPnFBf+D+0l/dt9tCNJK6xnjmZOg7GdJlPvC/AhQtPo5P3MsHQvwhiobLiLBQABf82y74z4Qt3ldSybKHToLTeW+I5/1B3u2euOD/JQy+zyRowEUs5zAzA1x+oCckJHrRYNCf/uE3AjD4QfONBBMC5PfvY2j3TEi4ZNmd8eHilQDFMK/s8xMhIXPhJLjuJLjAN/8VgRsbPWHwLbAtm5tXRWGRAS5b/99C7FBmgbTMAGXrJ5aIomJir8wA3S5afyLEEkUtEBezfQy+RYpFvdilgmMhNnGxRw2wL8QqScy1fMNE0T4yQCLEKkksxDQUwDj2BNjbK69pdndn/zxwNsUCCOyNGyJ374psbYkMBiLv30++59o1kW5X5NMnkdFI5OXL8nXghCsAAn10NL/Fz2NnpxQFFyR5/bq8BypDWAIg6AcHIoeH60nn4/K8e1deECIgwhAAQULQEXxIUAf43bju3ZvMDJ7jrwDT/XpToIvABeECqBf8EuB7+/W6CKBe0C/Auvv1uvC0XtArQBP9el14VC/oEqCtfr0uPKgX2hdAW79eF0rrhfYFQPCRKi1RyY4ZyZYF4GKQcSiAcSiAcSiAcSiAcSiAcSiAcSiAcSiAcSiAcSiAcSiAcSiAcShAm3z+LG1DAdqEAhjn40dpGwrQFtgIwgxgGAWtH1CAtsC2cQVQgLZQsk2cArSBoqeHKEAbKHpiiAI0DVq+kv4fUICmQetXMPyroABNgtb/5o1oggI0icJzBChAUyDwr16JNihAUzx+LBqhAE3w5InaU0MoQN08f64y9VdQgDrBkO/FC9EMBagLBB/P/yvHxlGxTYPh3tOn4gMUYN2g4FPc509DAdYFqvxZh1ArhwKsg6rSVzTHvywU4EeoqnyPTxKnAKuCVo4iD4s6ARwhTwGWoTrk8e3bIE4IH4cCVCDI1U6dL1/K73Eh4B727ctCASoQ6MBa9zJwJtA4FMA4FMA4FMA4FMA4FMA4FMA4FMA47Qtg4P/n1Uz7AgQ8zeoD7Qug5KQMq+joApgFWkNHEWhwEUYLFMA4OgRQdGCCNXQIUG28II2jZyKIWaAV9Aig7OgUK+gRAMH36ImaUNC1FoDt1swCjaJLAAQfT9mQxtC3GohugCOCxtC5HIyHLNkVNIJOATAv4Mnz9b6jd0MIhoWsB2pH944gPHmLkQGpDf1bwtAVUILa8GNPICRgd1AL/mwKRXfA0cHa8WtXMArDfp8bSdeIf9vCEfxHj8psQBF+GH/PB0A2wIzhrVsih4ciOztCVsfvAyKQAVAbYPr44EDk6Ehkd1fI8oRxQggKQ2QEXMgEe3ulELhvbQmZT3hHxFRn+1Tn/UAAZAWIUXUTHz4IKQn/jCBkB6Pn/ywDHw41DgUwDgRIhVgljSWKzoXYJM+dAFmWCrHKeewsOBViExd71AAjd10IsUYaDYdnsfty4Uz4U4g1zvClHAbm+e9CbJFlfdwKAVwWSJ0EfwixwrCIuYxPBOV5T1gLWCCtWj+4EqCoBbLsFyFhk2UPq9YPJqaCURW6W19IqPRdjCeG/dGsd+Xdbs/dToSERD8aDHrTP4zmvZsSBMXM4INo0afyTudY4vg39zIR4iNFXXfZtc9k4XJw0V9k2R1OFHkIhvVZdn1R8MHCDDDx+zqdxK0c9tz1szAjaKWc1XUTe+OV/iKWFmAcJ8NtJ8Kxe7kvkCGKEiHN45Zz3b/9yN3/uVzUGxXD+RX4F56985hsqA6SAAAAAElFTkSuQmCC",
    readyState: "NotDetected",
    isAIP62Standard: true
  },
  {
    name: "Pontem Wallet",
    url: "https://pontem.network/pontem-wallet",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzYiIGhlaWdodD0iMzYiIHZpZXdCb3g9IjAgMCAzNiAzNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTE4IDBDOC4wNzMwNCAwIDAgOC4wNzEzOSAwIDE3Ljk5NjNDMCAyNS4xMjk4IDQuMTczMTYgMzEuMzEwOCAxMC4yMDc2IDM0LjIyMDNWMzQuMjM1MUgxMC4yMzcyQzEyLjU4NiAzNS4zNjQ5IDE1LjIyMjggMzYgMTggMzZDMjcuOTI3IDM2IDM2IDI3LjkyODYgMzYgMTguMDAzN0MzNiA4LjA3MTM4IDI3LjkyNyAwIDE4IDBaTTE4IDEuNDc2OTJDMjcuMTA3MSAxLjQ3NjkyIDM0LjUyMjggOC44OTEwOCAzNC41MjI4IDE3Ljk5NjNDMzQuNTIyOCAyMC42MTA1IDMzLjkwOTcgMjMuMDkxNyAzMi44MjQgMjUuMjkyM0MzMC40NDU2IDI0LjE0MDMgMjguMDMwNCAyMy4yODM3IDI1LjU5MjkgMjIuNzAwM1Y4LjkyMDYyQzI1LjU5MjkgOC40NDA2MiAyNS4yMTYyIDguMDU2NjIgMjQuNzQzNSA4LjA1NjYySDIxLjcxNTJIMTQuMDg1NEgxMS4wNTdDMTAuNTkxNyA4LjA1NjYyIDEwLjIwNzYgOC40NDA2MiAxMC4yMDc2IDguOTIwNjJWMjIuNzY2OEM3Ljg0NDA3IDIzLjM1MDIgNS40OTUyOCAyNC4xOTIgMy4xODM0MiAyNS4yOTk3QzIuMDkwMjcgMjMuMDkxNyAxLjQ3NzIzIDIwLjYxNzggMS40NzcyMyAxNy45OTYzQzEuNDc3MjMgOC44OTEwOCA4Ljg5MjkgMS40NzY5MiAxOCAxLjQ3NjkyWk00LjEzNjIzIDI2Ljk2MTJDNi4wOTM1NiAyNS45OTM4IDguMTI0NzQgMjUuMjQ4IDEwLjIxNSAyNC43MzExVjMyLjU1ODhDNy43NDA2NiAzMS4yMzY5IDUuNjUwMzkgMjkuMzAyMiA0LjEzNjIzIDI2Ljk2MTJaTTE0LjA4NTQgMzQuMDQzMVYxNS42MDM3QzE0LjA4NTQgMTMuNDY5NSAxNS44MzU5IDExLjcwNDYgMTcuOTI2MSAxMS43MDQ2QzIwLjAxNjQgMTEuNzA0NiAyMS43MTUyIDEzLjQzMjYgMjEuNzE1MiAxNS41NTk0QzIxLjcxNTIgMTUuNTc0MiAyMS43MDc4IDE1LjU4ODkgMjEuNzA3OCAxNS42MDM3SDIxLjcxNTJWMjIuMDIwOUMxOS45MzUyIDIxLjgxNDIgMTguMTQ3NyAyMS43NDc3IDE2LjM2MDMgMjEuODQzN0wxNC44OTA0IDIzLjk3NzhDMTcuMTgwMSAyMy43ODU4IDE5LjQxMDcgMjMuODAwNiAyMS42MTE4IDI0LjA1MTdDMjEuNjM0IDI0LjA1MTcgMjEuNjQ4NyAyNC4wNTE3IDIxLjY3MDkgMjQuMDU5MUMyMS42ODU3IDI0LjA1OTEgMjEuNzAwNSAyNC4wNTkxIDIxLjcyMjYgMjQuMDY2NUMyMi4xMDY3IDI0LjExMDggMjMuNTAyNyAyNC4yODggMjQuNzgwNSAyNC42MDU1TDIxLjcyMjYgMjUuNjQ2OFYzNC4xMDIyQzIwLjUyNjEgMzQuMzc1NCAxOS4yODUyIDM0LjUzMDUgMTguMDE0OCAzNC41MzA1QzE2LjY0ODMgMzQuNTE1NyAxNS4zNDEgMzQuMzQ1OCAxNC4wODU0IDM0LjA0MzFaTTI1LjU4NTYgMzIuNjYyMlYyNC43NjhDMjcuNjY4NCAyNS4yOTIzIDI5LjcyOTIgMjYuMDYwMyAzMS43OTczIDI3LjA2NDZDMzAuMjQ2MiAyOS40MjAzIDI4LjEwNDIgMzEuMzU1MSAyNS41ODU2IDMyLjY2MjJaIiBmaWxsPSJ1cmwoI3BhaW50MF9saW5lYXJfMjIyXzE2NzApIi8+CjxkZWZzPgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfMjIyXzE2NzAiIHgxPSIxNy45OTk3IiB5MT0iMzYuNzc4OSIgeDI9IjE3Ljk5OTciIHkyPSItNS41MTk3OCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBvZmZzZXQ9IjAuMDg1OCIgc3RvcC1jb2xvcj0iIzhEMjlDMSIvPgo8c3RvcCBvZmZzZXQ9IjAuMjM4MyIgc3RvcC1jb2xvcj0iIzk0MkJCQiIvPgo8c3RvcCBvZmZzZXQ9IjAuNDY2NyIgc3RvcC1jb2xvcj0iI0E5MkZBQyIvPgo8c3RvcCBvZmZzZXQ9IjAuNzQxMyIgc3RvcC1jb2xvcj0iI0NBMzc5MyIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGMDNGNzciLz4KPC9saW5lYXJHcmFkaWVudD4KPC9kZWZzPgo8L3N2Zz4K",
    readyState: "NotDetected",
    isAIP62Standard: true
  }
];
var WalletCore = class extends import_eventemitter34.default {
  constructor(plugins, optInWallets, dappConfig, disableTelemetry) {
    super();
    this._wallets = [];
    this._optInWallets = [];
    this._standard_wallets = [];
    this._all_wallets = [];
    this._wallet = null;
    this._account = null;
    this._network = null;
    this.walletCoreV1 = new WalletCoreV1();
    this.walletStandardCore = new WalletStandardCore();
    this._connecting = false;
    this._connected = false;
    this.ga4 = null;
    this._disableTelemetry = false;
    this.standardizeStandardWalletToPluginWalletType = (standardWallet) => {
      var _a, _b, _c;
      let standardWalletConvertedToWallet = {
        name: standardWallet.name,
        url: standardWallet.url,
        icon: standardWallet.icon,
        provider: standardWallet,
        connect: standardWallet.features["aptos:connect"].connect,
        disconnect: standardWallet.features["aptos:disconnect"].disconnect,
        network: standardWallet.features["aptos:network"].network,
        account: standardWallet.features["aptos:account"].account,
        signAndSubmitTransaction: (_a = standardWallet.features["aptos:signAndSubmitTransaction"]) == null ? void 0 : _a.signAndSubmitTransaction,
        signMessage: standardWallet.features["aptos:signMessage"].signMessage,
        onAccountChange: standardWallet.features["aptos:onAccountChange"].onAccountChange,
        onNetworkChange: standardWallet.features["aptos:onNetworkChange"].onNetworkChange,
        signTransaction: standardWallet.features["aptos:signTransaction"].signTransaction,
        openInMobileApp: (_b = standardWallet.features["aptos:openInMobileApp"]) == null ? void 0 : _b.openInMobileApp,
        changeNetwork: (_c = standardWallet.features["aptos:changeNetwork"]) == null ? void 0 : _c.changeNetwork,
        readyState: "Installed",
        isAIP62Standard: true
      };
      this._all_wallets = this._all_wallets.filter(
        (item) => item.name !== standardWalletConvertedToWallet.name
      );
      this._all_wallets.push(standardWalletConvertedToWallet);
      this.emit("standardWalletsAdded", standardWalletConvertedToWallet);
    };
    this._wallets = plugins;
    this._optInWallets = optInWallets;
    this._dappConfig = dappConfig;
    this._disableTelemetry = disableTelemetry;
    this._sdkWallets = getSDKWallets(this._dappConfig);
    if (!this._disableTelemetry) {
      this.ga4 = new GA4();
    }
    this.fetchExtensionAIP62AptosWallets();
    this.fetchSDKAIP62AptosWallets();
    this.scopePollingDetectionStrategy();
    this.appendNotDetectedStandardSupportedWallets();
  }
  scopePollingDetectionStrategy() {
    var _a;
    (_a = this._wallets) == null ? void 0 : _a.forEach((wallet) => {
      const existingStandardPontemWallet = this._standard_wallets.find(
        (wallet2) => wallet2.name == "Pontem Wallet"
      );
      if (wallet.name === "Pontem" && existingStandardPontemWallet) {
        return;
      }
      const existingWalletIndex = this._standard_wallets.findIndex(
        (standardWallet) => standardWallet.name == wallet.name
      );
      if (existingWalletIndex !== -1)
        return;
      this._all_wallets.push(wallet);
      if (!wallet.readyState) {
        wallet.readyState = typeof window === "undefined" || typeof document === "undefined" ? "Unsupported" : "NotDetected";
      }
      if (typeof window !== "undefined") {
        scopePollingDetectionStrategy(() => {
          const providerName = wallet.providerName || wallet.name.toLowerCase();
          if (Object.keys(window).includes(providerName)) {
            wallet.readyState = "Installed";
            wallet.provider = window[providerName];
            this.emit("readyStateChange", wallet);
            return true;
          }
          return false;
        });
      }
    });
  }
  fetchExtensionAIP62AptosWallets() {
    let { aptosWallets, on: on4 } = d3();
    this.setExtensionAIP62Wallets(aptosWallets);
    if (typeof window === "undefined")
      return;
    const that = this;
    const removeRegisterListener = on4("register", function() {
      let { aptosWallets: aptosWallets2 } = d3();
      that.setExtensionAIP62Wallets(aptosWallets2);
    });
    const removeUnregisterListener = on4("unregister", function() {
      let { aptosWallets: aptosWallets2 } = d3();
      that.setExtensionAIP62Wallets(aptosWallets2);
    });
  }
  appendNotDetectedStandardSupportedWallets() {
    aptosStandardSupportedWalletList.map((supportedWallet) => {
      const existingPluginWalletIndex = this.wallets.findIndex(
        (wallet) => wallet.name === supportedWallet.name
      );
      if (existingPluginWalletIndex !== -1)
        return;
      const existingStandardPontemWallet = this.wallets.find(
        (wallet) => wallet.name == "Pontem"
      );
      if (supportedWallet.name === "Pontem Wallet" && existingStandardPontemWallet) {
        return;
      }
      const existingStandardWallet = this._standard_wallets.find(
        (wallet) => wallet.name == supportedWallet.name
      );
      if (existingStandardWallet && this.excludeWallet(existingStandardWallet)) {
        return;
      }
      if (!existingStandardWallet) {
        this._all_wallets.push(supportedWallet);
        this.emit("standardWalletsAdded", supportedWallet);
      }
    });
  }
  fetchSDKAIP62AptosWallets() {
    this._sdkWallets.map((wallet) => {
      this.standardizeAIP62WalletType(wallet);
    });
  }
  setExtensionAIP62Wallets(extensionwWallets) {
    const wallets = extensionwWallets.filter(
      (wallet) => wallet.name !== "Dev T wallet" && wallet.name !== "T wallet"
    );
    wallets.map((wallet) => {
      this.standardizeAIP62WalletType(wallet);
      this._standard_wallets.push(wallet);
    });
  }
  excludeWallet(wallet) {
    if (this._optInWallets.length > 0 && !this._optInWallets.includes(wallet.name)) {
      return true;
    }
    return false;
  }
  standardizeAIP62WalletType(wallet) {
    if (this.excludeWallet(wallet)) {
      return;
    }
    const isValid = i2(wallet);
    if (isValid) {
      wallet.readyState = "Installed";
      this.standardizeStandardWalletToPluginWalletType(wallet);
      this._standard_wallets.push(wallet);
    }
  }
  recordEvent(eventName, additionalInfo) {
    var _a, _b, _c, _d;
    (_d = this.ga4) == null ? void 0 : _d.gtag("event", `wallet_adapter_${eventName}`, {
      wallet: (_a = this._wallet) == null ? void 0 : _a.name,
      network: (_b = this._network) == null ? void 0 : _b.name,
      network_url: (_c = this._network) == null ? void 0 : _c.url,
      adapter_core_version: WALLET_ADAPTER_CORE_VERSION,
      send_to: true,
      ...additionalInfo
    });
  }
  ensureWalletExists(wallet) {
    if (!wallet) {
      throw new WalletNotConnectedError().name;
    }
    if (!(wallet.readyState === "Loadable" || wallet.readyState === "Installed"))
      throw new WalletNotReadyError("Wallet is not set").name;
  }
  ensureAccountExists(account) {
    if (!account) {
      throw new WalletAccountError("Account is not set").name;
    }
  }
  doesWalletExist() {
    if (!this._connected || this._connecting || !this._wallet)
      throw new WalletNotConnectedError().name;
    if (!(this._wallet.readyState === "Loadable" || this._wallet.readyState === "Installed"))
      throw new WalletNotReadyError().name;
    return true;
  }
  clearData() {
    this._connected = false;
    this.setWallet(null);
    this.setAccount(null);
    this.setNetwork(null);
    removeLocalStorage();
  }
  async setAnsName() {
    var _a;
    if (((_a = this._network) == null ? void 0 : _a.chainId) && this._account) {
      if (!ChainIdToAnsSupportedNetworkMap[this._network.chainId] || !isAptosNetwork(this._network)) {
        this._account.ansName = void 0;
        return;
      }
      const aptosConfig = new l({
        network: convertNetwork(this._network)
      });
      const aptos = new t4(aptosConfig);
      const name = await aptos.ans.getPrimaryName({
        address: this._account.address.toString()
      });
      this._account.ansName = name;
    }
  }
  setWallet(wallet) {
    this._wallet = wallet;
  }
  setAccount(account) {
    var _a;
    if (account === null) {
      this._account = null;
      return;
    }
    if ((_a = this._wallet) == null ? void 0 : _a.isAIP62Standard) {
      if ("status" in account) {
        const connectStandardAccount = account;
        if (connectStandardAccount.status === r4.REJECTED) {
          this._connecting = false;
          throw new WalletConnectionError("User has rejected the request").message;
        }
        this._account = {
          address: connectStandardAccount.args.address.toString(),
          publicKey: connectStandardAccount.args.publicKey.toString(),
          ansName: connectStandardAccount.args.ansName
        };
        return;
      } else {
        const standardAccount = account;
        this._account = {
          address: standardAccount.address.toString(),
          publicKey: standardAccount.publicKey.toString(),
          ansName: standardAccount.ansName
        };
        return;
      }
    }
    this._account = { ...account };
    return;
  }
  setNetwork(network) {
    var _a, _b, _c;
    if (network === null) {
      this._network = null;
      return;
    }
    if ((_a = this._wallet) == null ? void 0 : _a.isAIP62Standard) {
      const standardizeNetwork = network;
      this.recordEvent("network_change", {
        from: (_b = this._network) == null ? void 0 : _b.name,
        to: standardizeNetwork.name
      });
      this._network = {
        name: standardizeNetwork.name.toLowerCase(),
        chainId: standardizeNetwork.chainId.toString(),
        url: standardizeNetwork.url
      };
      return;
    }
    this.recordEvent("network_change", {
      from: (_c = this._network) == null ? void 0 : _c.name,
      to: network.name
    });
    this._network = {
      ...network,
      name: network.name.toLowerCase()
    };
  }
  isConnected() {
    return this._connected;
  }
  get wallets() {
    return this._all_wallets;
  }
  get pluginWallets() {
    return this._wallets;
  }
  get standardWallets() {
    return this._standard_wallets;
  }
  get wallet() {
    try {
      if (!this._wallet)
        return null;
      return {
        name: this._wallet.name,
        icon: this._wallet.icon,
        url: this._wallet.url
      };
    } catch (error) {
      throw new WalletNotSelectedError(error).message;
    }
  }
  get account() {
    try {
      return this._account;
    } catch (error) {
      throw new WalletAccountError(error).message;
    }
  }
  get network() {
    try {
      return this._network;
    } catch (error) {
      throw new WalletGetNetworkError(error).message;
    }
  }
  async connect(walletName2) {
    var _a;
    const allDetectedWallets = this._all_wallets;
    const selectedWallet = allDetectedWallets.find(
      (wallet) => wallet.name === walletName2
    );
    if (!selectedWallet)
      return;
    if (this._connected) {
      if (((_a = this._wallet) == null ? void 0 : _a.name) === walletName2)
        throw new WalletConnectionError(
          `${walletName2} wallet is already connected`
        ).message;
    }
    if (isRedirectable() && selectedWallet.readyState !== "Installed") {
      if (selectedWallet.isAIP62Standard && selectedWallet.openInMobileApp) {
        selectedWallet.openInMobileApp();
        return;
      }
      if (selectedWallet.deeplinkProvider) {
        const url = encodeURIComponent(window.location.href);
        const location = selectedWallet.deeplinkProvider({ url });
        window.location.href = location;
      }
      return;
    }
    if (selectedWallet.readyState !== "Installed" && selectedWallet.readyState !== "Loadable") {
      return;
    }
    await this.connectWallet(selectedWallet);
  }
  async connectWallet(selectedWallet) {
    try {
      this._connecting = true;
      this.setWallet(selectedWallet);
      let account;
      if (selectedWallet.isAIP62Standard) {
        account = await this.walletStandardCore.connect(selectedWallet);
      } else {
        account = await this.walletCoreV1.connect(selectedWallet);
      }
      this.setAccount(account);
      const network = await selectedWallet.network();
      this.setNetwork(network);
      await this.setAnsName();
      setLocalStorage(selectedWallet.name);
      this._connected = true;
      this.recordEvent("wallet_connect");
      this.emit("connect", account);
    } catch (error) {
      this.clearData();
      const errMsg = generalizedErrorMessage(error);
      throw new WalletConnectionError(errMsg).message;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    try {
      this.ensureWalletExists(this._wallet);
      await this._wallet.disconnect();
      this.clearData();
      this.recordEvent("wallet_disconnect");
      this.emit("disconnect");
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletDisconnectionError(errMsg).message;
    }
  }
  async signAndSubmitTransaction(transactionInput) {
    try {
      if ("function" in transactionInput.data) {
        if (transactionInput.data.function === "0x1::account::rotate_authentication_key_call") {
          throw new WalletSignAndSubmitMessageError("SCAM SITE DETECTED").message;
        }
      }
      this.ensureWalletExists(this._wallet);
      this.ensureAccountExists(this._account);
      this.recordEvent("sign_and_submit_transaction");
      const payloadData = transactionInput.data;
      const aptosConfig = getAptosConfig(this._network);
      const aptos = new t4(aptosConfig);
      if (this._wallet.signAndSubmitTransaction) {
        if (this._wallet.isAIP62Standard) {
          const { hash, ...output } = await this.walletStandardCore.signAndSubmitTransaction(
            transactionInput,
            aptos,
            this._account,
            this._wallet,
            this._standard_wallets
          );
          return { hash, output };
        } else {
          const { hash, ...output } = await this.walletCoreV1.resolveSignAndSubmitTransaction(
            payloadData,
            this._network,
            this._wallet,
            transactionInput
          );
          return { hash, output };
        }
      }
      const transaction = await aptos.transaction.build.simple({
        sender: this._account.address,
        data: transactionInput.data,
        options: transactionInput.options
      });
      const senderAuthenticator = await this.signTransaction(transaction);
      const response = await this.submitTransaction({
        transaction,
        senderAuthenticator
      });
      return response;
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignAndSubmitMessageError(errMsg).message;
    }
  }
  async signTransaction(transactionOrPayload, asFeePayer, options) {
    var _a, _b, _c, _d;
    try {
      this.ensureWalletExists(this._wallet);
      this.recordEvent("sign_transaction");
      if (this._wallet.signTransaction) {
        if (this._wallet.isAIP62Standard) {
          if ("rawTransaction" in transactionOrPayload) {
            return await this.walletStandardCore.signTransaction(
              transactionOrPayload,
              this._wallet,
              asFeePayer
            );
          } else {
            const aptosConfig = getAptosConfig(this._network);
            this.ensureAccountExists(this._account);
            const sender = this._account.address;
            const payload = await generateTransactionPayloadFromV1Input(
              aptosConfig,
              transactionOrPayload
            );
            const optionsV1 = options;
            const optionsV2 = {
              accountSequenceNumber: optionsV1 == null ? void 0 : optionsV1.sequenceNumber,
              expireTimestamp: (_a = optionsV1 == null ? void 0 : optionsV1.expireTimestamp) != null ? _a : optionsV1 == null ? void 0 : optionsV1.expirationTimestamp,
              gasUnitPrice: (_b = optionsV1 == null ? void 0 : optionsV1.gasUnitPrice) != null ? _b : optionsV1 == null ? void 0 : optionsV1.gas_unit_price,
              maxGasAmount: (_c = optionsV1 == null ? void 0 : optionsV1.maxGasAmount) != null ? _c : optionsV1 == null ? void 0 : optionsV1.max_gas_amount
            };
            const rawTransaction = await gn({
              aptosConfig,
              payload,
              sender,
              options: optionsV2
            });
            return await this.walletStandardCore.signTransaction(
              new o2(rawTransaction),
              this._wallet,
              false
            );
          }
        }
        if ("rawTransaction" in transactionOrPayload) {
          const accountAuthenticator = await this._wallet.signTransaction(
            transactionOrPayload,
            asFeePayer
          );
          return accountAuthenticator;
        } else {
          const response = await this.walletCoreV1.signTransaction(
            transactionOrPayload,
            this._wallet,
            {
              max_gas_amount: (options == null ? void 0 : options.maxGasAmount) ? BigInt(options == null ? void 0 : options.maxGasAmount) : void 0,
              gas_unit_price: (options == null ? void 0 : options.gasUnitPrice) ? BigInt(options == null ? void 0 : options.gasUnitPrice) : void 0
            }
          );
          if (!response) {
            throw new Error("error");
          }
          const deserializer1 = new bcs_exports.Deserializer(response);
          const deserializedSignature = aptos_types_exports.SignedTransaction.deserialize(deserializer1);
          const transactionAuthenticator = deserializedSignature.authenticator;
          const publicKey = transactionAuthenticator.public_key.value;
          const signature = transactionAuthenticator.signature.value;
          const accountAuthenticator = new u2(
            new m(publicKey),
            new c2(signature)
          );
          return accountAuthenticator;
        }
      }
      throw new WalletNotSupportedMethod(
        `Sign Transaction is not supported by ${(_d = this.wallet) == null ? void 0 : _d.name}`
      ).message;
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignTransactionError(errMsg).message;
    }
  }
  async signMessage(message) {
    try {
      this.ensureWalletExists(this._wallet);
      this.recordEvent("sign_message");
      if (this._wallet.isAIP62Standard) {
        return await this.walletStandardCore.signMessage(message, this._wallet);
      }
      const response = await this._wallet.signMessage(message);
      return response;
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignMessageError(errMsg).message;
    }
  }
  async submitTransaction(transaction) {
    try {
      this.ensureWalletExists(this._wallet);
      const { additionalSignersAuthenticators } = transaction;
      const transactionType = additionalSignersAuthenticators !== void 0 ? "multi-agent" : "simple";
      this.recordEvent("submit_transaction", {
        transaction_type: transactionType
      });
      if (this._wallet.submitTransaction) {
        const pendingTransaction = await this._wallet.submitTransaction(transaction);
        return pendingTransaction;
      }
      const aptosConfig = new l({
        network: convertNetwork(this.network)
      });
      const aptos = new t4(aptosConfig);
      if (additionalSignersAuthenticators !== void 0) {
        const multiAgentTxn = {
          ...transaction,
          additionalSignersAuthenticators
        };
        return aptos.transaction.submit.multiAgent(multiAgentTxn);
      } else {
        return aptos.transaction.submit.simple(transaction);
      }
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignTransactionError(errMsg).message;
    }
  }
  async onAccountChange() {
    try {
      this.ensureWalletExists(this._wallet);
      await this._wallet.onAccountChange(
        async (data) => {
          this.setAccount(data);
          await this.setAnsName();
          this.recordEvent("account_change");
          this.emit("accountChange", this._account);
        }
      );
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletAccountChangeError(errMsg).message;
    }
  }
  async onNetworkChange() {
    try {
      this.ensureWalletExists(this._wallet);
      await this._wallet.onNetworkChange(
        async (data) => {
          this.setNetwork(data);
          await this.setAnsName();
          this.emit("networkChange", this._network);
        }
      );
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletNetworkChangeError(errMsg).message;
    }
  }
  async changeNetwork(network) {
    var _a;
    try {
      this.ensureWalletExists(this._wallet);
      this.recordEvent("change_network_request", {
        from: (_a = this._network) == null ? void 0 : _a.name,
        to: network
      });
      const chainId = network === e.DEVNET ? await fetchDevnetChainId() : r2[network];
      if (this._wallet.changeNetwork) {
        const networkInfo = {
          name: network,
          chainId
        };
        const response = await this._wallet.changeNetwork(networkInfo);
        if (response.status === r4.REJECTED) {
          throw new WalletConnectionError("User has rejected the request").message;
        }
        return response.args;
      }
      throw new WalletChangeNetworkError(
        `${this._wallet.name} does not support changing network request`
      ).message;
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletChangeNetworkError(errMsg).message;
    }
  }
  async signMessageAndVerify(message) {
    try {
      this.ensureWalletExists(this._wallet);
      this.ensureAccountExists(this._account);
      this.recordEvent("sign_message_and_verify");
      if (this._wallet.isAIP62Standard) {
        return this.walletStandardCore.signMessageAndVerify(
          message,
          this._wallet
        );
      }
      return await this.walletCoreV1.signMessageAndVerify(
        message,
        this._wallet,
        this._account
      );
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignMessageAndVerifyError(errMsg).message;
    }
  }
};
if (typeof window !== "undefined") {
  window.WALLET_ADAPTER_CORE_VERSION = WALLET_ADAPTER_CORE_VERSION;
}

// node_modules/@aptos-labs/wallet-adapter-react/dist/index.mjs
var import_react = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react3 = __toESM(require_react(), 1);
var import_react4 = __toESM(require_react(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react5 = __toESM(require_react(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react6 = __toESM(require_react(), 1);
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);

// node_modules/@radix-ui/react-slot/dist/index.mjs
var React2 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-compose-refs/dist/index.mjs
var React = __toESM(require_react(), 1);
function setRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => refs.forEach((ref) => setRef(ref, node));
}

// node_modules/@radix-ui/react-slot/dist/index.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var Slot = React2.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  const childrenArray = React2.Children.toArray(children);
  const slottable = childrenArray.find(isSlottable);
  if (slottable) {
    const newElement = slottable.props.children;
    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        if (React2.Children.count(newElement) > 1) return React2.Children.only(null);
        return React2.isValidElement(newElement) ? newElement.props.children : null;
      } else {
        return child;
      }
    });
    return (0, import_jsx_runtime.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: React2.isValidElement(newElement) ? React2.cloneElement(newElement, void 0, newChildren) : null });
  }
  return (0, import_jsx_runtime.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children });
});
Slot.displayName = "Slot";
var SlotClone = React2.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  if (React2.isValidElement(children)) {
    const childrenRef = getElementRef(children);
    return React2.cloneElement(children, {
      ...mergeProps(slotProps, children.props),
      // @ts-ignore
      ref: forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef
    });
  }
  return React2.Children.count(children) > 1 ? React2.Children.only(null) : null;
});
SlotClone.displayName = "SlotClone";
var Slottable = ({ children }) => {
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children });
};
function isSlottable(child) {
  return React2.isValidElement(child) && child.type === Slottable;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          childPropValue(...args);
          slotPropValue(...args);
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef(element) {
  var _a, _b;
  let getter = (_a = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// node_modules/@aptos-labs/wallet-adapter-react/dist/index.mjs
var import_react7 = __toESM(require_react(), 1);
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_react8 = __toESM(require_react(), 1);
var import_react9 = __toESM(require_react(), 1);
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var import_react10 = __toESM(require_react(), 1);
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var DEFAULT_CONTEXT = {
  connected: false
};
var WalletContext = (0, import_react2.createContext)(
  DEFAULT_CONTEXT
);
function useWallet() {
  const context = (0, import_react2.useContext)(WalletContext);
  if (!context) {
    throw new Error("useWallet must be used within a WalletContextState");
  }
  return context;
}
var initialState = {
  connected: false,
  account: null,
  network: null,
  wallet: null
};
var AptosWalletAdapterProvider = ({
  children,
  plugins,
  optInWallets,
  autoConnect = false,
  dappConfig,
  disableTelemetry = false,
  onError
}) => {
  const [{ connected, account, network, wallet }, setState2] = (0, import_react.useState)(initialState);
  const [isLoading, setIsLoading] = (0, import_react.useState)(true);
  const [walletCore, setWalletCore] = (0, import_react.useState)();
  const [wallets, setWallets] = (0, import_react.useState)(plugins != null ? plugins : []);
  (0, import_react.useEffect)(() => {
    const walletCore2 = new WalletCore(
      plugins != null ? plugins : [],
      optInWallets != null ? optInWallets : [],
      dappConfig,
      disableTelemetry
    );
    setWalletCore(walletCore2);
  }, []);
  (0, import_react.useEffect)(() => {
    var _a;
    setWallets((_a = walletCore == null ? void 0 : walletCore.wallets) != null ? _a : []);
  }, [walletCore]);
  const connect = async (walletName2) => {
    try {
      setIsLoading(true);
      await (walletCore == null ? void 0 : walletCore.connect(walletName2));
    } catch (error) {
      if (onError)
        onError(error);
      return Promise.reject(error);
    } finally {
      setIsLoading(false);
    }
  };
  const disconnect = async () => {
    try {
      await (walletCore == null ? void 0 : walletCore.disconnect());
    } catch (error) {
      if (onError)
        onError(error);
      return Promise.reject(error);
    }
  };
  const signTransaction = async (transaction, asFeePayer, options) => {
    if (!walletCore) {
      throw new Error("WalletCore is not initialized");
    }
    try {
      return await (walletCore == null ? void 0 : walletCore.signTransaction(
        transaction,
        asFeePayer,
        options
      ));
    } catch (error) {
      if (onError)
        onError(error);
      return Promise.reject(error);
    }
  };
  const signMessage = async (message) => {
    if (!walletCore) {
      throw new Error("WalletCore is not initialized");
    }
    try {
      return await (walletCore == null ? void 0 : walletCore.signMessage(message));
    } catch (error) {
      if (onError)
        onError(error);
      return Promise.reject(error);
    }
  };
  const signMessageAndVerify = async (message) => {
    if (!walletCore) {
      throw new Error("WalletCore is not initialized");
    }
    try {
      return await (walletCore == null ? void 0 : walletCore.signMessageAndVerify(message));
    } catch (error) {
      if (onError)
        onError(error);
      return Promise.reject(error);
    }
  };
  const submitTransaction = async (transaction) => {
    if (!walletCore) {
      throw new Error("WalletCore is not initialized");
    }
    try {
      return await (walletCore == null ? void 0 : walletCore.submitTransaction(transaction));
    } catch (error) {
      if (onError)
        onError(error);
      return Promise.reject(error);
    }
  };
  const signAndSubmitTransaction = async (transaction) => {
    try {
      return await (walletCore == null ? void 0 : walletCore.signAndSubmitTransaction(transaction));
    } catch (error) {
      if (onError)
        onError(error);
      return Promise.reject(error);
    }
  };
  const changeNetwork = async (network2) => {
    if (!walletCore) {
      throw new Error("WalletCore is not initialized");
    }
    try {
      return await (walletCore == null ? void 0 : walletCore.changeNetwork(network2));
    } catch (error) {
      if (onError)
        onError(error);
      return Promise.reject(error);
    }
  };
  (0, import_react.useEffect)(() => {
    if (autoConnect) {
      if (localStorage.getItem("AptosWalletName") && !connected) {
        connect(localStorage.getItem("AptosWalletName"));
      } else {
        setIsLoading(false);
      }
    }
  }, [autoConnect, wallets]);
  (0, import_react.useEffect)(() => {
    if (connected) {
      walletCore == null ? void 0 : walletCore.onAccountChange();
      walletCore == null ? void 0 : walletCore.onNetworkChange();
    }
  }, [connected]);
  const handleConnect = () => {
    setState2((state) => {
      return {
        ...state,
        connected: true,
        account: (walletCore == null ? void 0 : walletCore.account) || null,
        network: (walletCore == null ? void 0 : walletCore.network) || null,
        wallet: (walletCore == null ? void 0 : walletCore.wallet) || null
      };
    });
  };
  const handleDisconnect = () => {
    if (!connected)
      return;
    setState2((state) => {
      return {
        ...state,
        connected: false,
        account: (walletCore == null ? void 0 : walletCore.account) || null,
        network: (walletCore == null ? void 0 : walletCore.network) || null,
        wallet: null
      };
    });
  };
  const handleAccountChange = (0, import_react.useCallback)(() => {
    if (!connected)
      return;
    if (!(walletCore == null ? void 0 : walletCore.wallet))
      return;
    setState2((state) => {
      return {
        ...state,
        account: (walletCore == null ? void 0 : walletCore.account) || null
      };
    });
  }, [connected]);
  const handleNetworkChange = (0, import_react.useCallback)(() => {
    if (!connected)
      return;
    if (!(walletCore == null ? void 0 : walletCore.wallet))
      return;
    setState2((state) => {
      return {
        ...state,
        network: (walletCore == null ? void 0 : walletCore.network) || null
      };
    });
  }, [connected]);
  const handleReadyStateChange = (updatedWallet) => {
    const updatedWallets = wallets == null ? void 0 : wallets.map((wallet2) => {
      if (wallet2.name === updatedWallet.name) {
        return { ...wallet2, readyState: updatedWallet.readyState };
      }
      return wallet2;
    });
    setWallets(updatedWallets);
  };
  const handleStandardWalletsAdded = (standardWallet) => {
    const existingWalletIndex = wallets.findIndex(
      (wallet2) => wallet2.name == standardWallet.name
    );
    if (existingWalletIndex !== -1) {
      setWallets((wallets2) => [
        ...wallets2.slice(0, existingWalletIndex),
        standardWallet,
        ...wallets2.slice(existingWalletIndex + 1)
      ]);
    } else {
      setWallets((wallets2) => [...wallets2, standardWallet]);
    }
  };
  (0, import_react.useEffect)(() => {
    walletCore == null ? void 0 : walletCore.on("connect", handleConnect);
    walletCore == null ? void 0 : walletCore.on("disconnect", handleDisconnect);
    walletCore == null ? void 0 : walletCore.on("accountChange", handleAccountChange);
    walletCore == null ? void 0 : walletCore.on("networkChange", handleNetworkChange);
    walletCore == null ? void 0 : walletCore.on("readyStateChange", handleReadyStateChange);
    walletCore == null ? void 0 : walletCore.on("standardWalletsAdded", handleStandardWalletsAdded);
    return () => {
      walletCore == null ? void 0 : walletCore.off("connect", handleConnect);
      walletCore == null ? void 0 : walletCore.off("disconnect", handleDisconnect);
      walletCore == null ? void 0 : walletCore.off("accountChange", handleAccountChange);
      walletCore == null ? void 0 : walletCore.off("networkChange", handleNetworkChange);
      walletCore == null ? void 0 : walletCore.off("readyStateChange", handleReadyStateChange);
      walletCore == null ? void 0 : walletCore.off("standardWalletsAdded", handleStandardWalletsAdded);
    };
  }, [wallets, account]);
  return (0, import_jsx_runtime2.jsx)(WalletContext.Provider, {
    value: {
      connect,
      account,
      network,
      connected,
      disconnect,
      wallet,
      wallets,
      signAndSubmitTransaction,
      signTransaction,
      signMessage,
      signMessageAndVerify,
      isLoading,
      submitTransaction,
      changeNetwork
    },
    children
  });
};
var LinkGraphic = (0, import_react4.forwardRef)(
  (props, ref) => {
    return (0, import_jsx_runtime3.jsx)("svg", {
      ref,
      width: "102",
      height: "132",
      viewBox: "0 0 102 132",
      fill: "none",
      ...props,
      children: (0, import_jsx_runtime3.jsxs)("g", {
        stroke: "currentColor",
        strokeMiterlimit: "10",
        children: [
          (0, import_jsx_runtime3.jsx)("path", {
            d: "M59.633 80.66c11.742-2.814 17.48-7.018 20.925-13.254l17.518-31.69c6.257-11.317 2.142-25.55-9.189-31.798C82.737.53 75.723.188 69.593 2.398M60.7 69.565a14.09 14.09 0 0 1-6.907-1.767l-.228-.108"
          }),
          (0, import_jsx_runtime3.jsx)("path", {
            d: "m52.365 41.075 12.507-22.627a14.146 14.146 0 0 1 4.727-5.062M32.407 118.619a14.139 14.139 0 0 1-7.034-1.768c-6.857-3.78-9.353-12.402-5.561-19.25l16.634-30.1a14.097 14.097 0 0 1 4.518-4.923"
          }),
          (0, import_jsx_runtime3.jsx)("path", {
            d: "M41.211 78.85c11.332 6.248 25.583 2.14 31.84-9.177l17.518-31.691c6.256-11.317 2.142-25.55-9.19-31.798-6.085-3.357-13.018-3.724-19.104-1.59A23.31 23.31 0 0 0 49.541 15.36L36.863 38.298l7.989 5.036 12.506-22.627c3.786-6.848 12.419-9.34 19.276-5.554 6.856 3.78 9.353 12.402 5.561 19.25l-16.634 30.1c-3.785 6.848-12.418 9.341-19.275 5.555l-5.075 8.791ZM29.5 130.447c12.361-1.37 19.2-6.994 22.966-13.804l12.678-22.936-8.305-5.239"
          }),
          (0, import_jsx_runtime3.jsx)("path", {
            d: "m55.72 61.947-.442.764 5.511-9.55c-6.901-3.806-18.65-3.124-27.105.814M44.85 43.523l7.635-2.486m-4.221 23.264 7.217-1.723m-9.316 7.517 7.59-2.405m-.562-12.156 7.508-2.221m10.136-51.32L62.761 4.43M49.642 90.778l7.514-2.26m.474 7.448 7.514-2.26m-50.306-60.13c7.135 0 12.918-5.776 12.918-12.9 0-7.126-5.783-12.902-12.918-12.902-7.134 0-12.917 5.776-12.917 12.901s5.783 12.901 12.918 12.901Z"
          }),
          (0, import_jsx_runtime3.jsx)("path", {
            d: "M15.724 7.774h3.197c7.135 0 12.918 5.776 12.918 12.901 0 7.126-5.783 12.901-12.918 12.901h-3.425m65.112 66.935h3.198c7.135 0 12.918 5.775 12.918 12.901 0 7.125-5.783 12.9-12.918 12.9h-3.425"
          }),
          (0, import_jsx_runtime3.jsx)("path", {
            d: "M79.717 126.312c7.135 0 12.918-5.775 12.918-12.9s-5.783-12.901-12.918-12.901c-7.134 0-12.917 5.776-12.917 12.901s5.783 12.9 12.917 12.9ZM53.281 55.414c-11.33-6.248-25.582-2.14-31.839 9.177L3.924 96.281c-6.257 11.318-2.142 25.55 9.189 31.799 11.331 6.248 25.582 2.139 31.839-9.177l12.677-22.937-7.988-5.036-12.507 22.627c-3.785 6.848-12.418 9.341-19.275 5.554-6.857-3.781-9.353-12.402-5.561-19.25l16.633-30.1c3.786-6.848 12.419-9.341 19.276-5.555l5.074-8.792Z"
          })
        ]
      })
    });
  }
);
LinkGraphic.displayName = "LinkGraphic";
var WalletGraphic = (0, import_react5.forwardRef)(
  (props, ref) => {
    return (0, import_jsx_runtime4.jsxs)("svg", {
      ref,
      width: "128",
      height: "102",
      viewBox: "0 0 128 102",
      fill: "none",
      ...props,
      children: [
        (0, import_jsx_runtime4.jsx)("path", {
          fill: "currentColor",
          d: "m.96 25.93-.36-.35.36.85v-.5Zm7.79-7.81v-.5h-.21l-.15.15.36.35ZM1.3 26.28l7.79-7.8-.7-.71-7.8 7.8.7.71Zm7.44-7.66H10v-1H8.75v1Zm29.22 6.8h-37v1h37.01v-1Z"
        }),
        (0, import_jsx_runtime4.jsx)("path", {
          stroke: "currentColor",
          strokeMiterlimit: "10",
          d: "M82.25 26.08c0 12.25-9.92 22.2-22.14 22.2a22.17 22.17 0 0 1-22.14-22.2H1.1v74.82h118.02V26.08H82.25Zm44.33 67.02h.33V18.27h-5.7"
        }),
        (0, import_jsx_runtime4.jsx)("path", {
          stroke: "currentColor",
          strokeMiterlimit: "10",
          d: "M74.52 42.92a22.4 22.4 0 0 1-11.43 3.3 22.5 22.5 0 0 1-22.46-22.53H9.52M119.22 101l7.78-7.82m-7.88-67.1 7.79-7.81m-44.78 7.72 2.73-2.3m-46.89 2.39 2.39-2.4"
        }),
        (0, import_jsx_runtime4.jsx)("path", {
          stroke: "currentColor",
          strokeMiterlimit: "10",
          d: "M9.86 23.69V5.72h107.97v18.04H84.65"
        }),
        (0, import_jsx_runtime4.jsx)("path", {
          stroke: "currentColor",
          strokeMiterlimit: "10",
          d: "M117.83 20.46h3.39V1H13.25v4.72M9.36 23.69h31.78"
        })
      ]
    });
  }
);
WalletGraphic.displayName = "WalletGraphic";
var Web3Graphic = (0, import_react6.forwardRef)(
  (props, ref) => {
    return (0, import_jsx_runtime5.jsx)("svg", {
      ref,
      width: "142",
      height: "108",
      viewBox: "0 0 142 108",
      fill: "none",
      ...props,
      children: (0, import_jsx_runtime5.jsxs)("g", {
        stroke: "currentColor",
        strokeLinejoin: "round",
        children: [
          (0, import_jsx_runtime5.jsx)("path", {
            d: "m91.26 35.8.06-10.46L71.3 1v10.53L87 30.5m-36.11 5.24-.06-10.45L71.3 1v10.53L55 30.5"
          }),
          (0, import_jsx_runtime5.jsx)("path", {
            d: "M71 59.55V49.17L50.83 25.3l.06 10.45L57 42.5m14 17.05V49.18l20.33-23.84-.07 10.45L86 42M1 59.68l.22-9.07 35.33-19.8-.1 9L9 55"
          }),
          (0, import_jsx_runtime5.jsx)("path", {
            d: "M36.55 30.8s-.08 5.92-.1 9l.1-9ZM71 59.51v-9.07L36.55 30.8l-.1 9L63.5 55"
          }),
          (0, import_jsx_runtime5.jsx)("path", {
            d: "M71 59.51v-9.07L36.44 70.78l-.1 9.14L55.5 68.5"
          }),
          (0, import_jsx_runtime5.jsx)("path", {
            d: "M1.22 50.6a77387.2 77387.2 0 0 0 35.22 20.18l-.1 9.14L1 59.68l.23-9.07h-.01ZM141 59.68l-.23-9.07-35.33-19.8.11 9L133 55"
          }),
          (0, import_jsx_runtime5.jsx)("path", {
            d: "m105.44 30.8.11 9-.1-9Z"
          }),
          (0, import_jsx_runtime5.jsx)("path", {
            d: "M71 59.51v-9.07l34.44-19.64.11 9L78.5 55"
          }),
          (0, import_jsx_runtime5.jsx)("path", {
            d: "M71 59.51v-9.07l34.56 20.34.1 9.14L87 69"
          }),
          (0, import_jsx_runtime5.jsx)("path", {
            d: "M140.78 50.6a78487.3 78487.3 0 0 1-35.23 20.18l.11 9.14L141 59.68l-.23-9.07ZM50.83 80.15l.06-6.33 20.1-23.38H71v9.26L55 79"
          }),
          (0, import_jsx_runtime5.jsx)("path", {
            d: "M71.3 97.6 50.89 73.81l-.06 9.33L71.3 107v-9.4Zm20.03-14.5-.07-9.33L71 50.44v9.26l16 18.8"
          }),
          (0, import_jsx_runtime5.jsx)("path", {
            d: "m71.3 97.6 19.96-23.83.06 9.33L71.3 107v-9.4Z"
          })
        ]
      })
    });
  }
);
Web3Graphic.displayName = "Web3Graphic";
function createHeadlessComponent(displayName, elementType, props) {
  const component = (0, import_react7.forwardRef)(({ className, asChild, children }, ref) => {
    const Component = asChild ? Slot : elementType;
    const { children: defaultChildren, ...resolvedProps } = typeof props === "function" ? props(displayName) : props != null ? props : {};
    return (0, import_jsx_runtime6.jsx)(Component, {
      ref,
      className,
      children: children != null ? children : defaultChildren,
      ...resolvedProps
    });
  });
  component.displayName = displayName;
  return component;
}
var EXPLORE_ECOSYSTEM_URL = "https://aptosfoundation.org/ecosystem/projects/all";
var AboutAptosConnectContext = (0, import_react3.createContext)(null);
function useAboutAptosConnectContext(displayName) {
  const context = (0, import_react3.useContext)(AboutAptosConnectContext);
  if (!context) {
    throw new Error(
      `\`${displayName}\` must be used within \`AboutAptosConnect\``
    );
  }
  return context;
}
var educationScreens = [
  {
    Graphic: LinkGraphic,
    Title: createHeadlessComponent("EducationScreen.Title", "h3", {
      children: "A better way to login."
    }),
    Description: createHeadlessComponent("EducationScreen.Description", "p", {
      children: "Aptos Connect is a web3 wallet that uses a Social Login to create accounts on the Aptos blockchain."
    })
  },
  {
    Graphic: WalletGraphic,
    Title: createHeadlessComponent("EducationScreen.Title", "h2", {
      children: "What is a wallet?"
    }),
    Description: createHeadlessComponent("EducationScreen.Description", "p", {
      children: "Wallets are a secure way to send, receive, and interact with digital assets like cryptocurrencies & NFTs."
    })
  },
  {
    Graphic: Web3Graphic,
    Title: createHeadlessComponent("EducationScreen.Title", "h2", {
      children: "Explore more of web3."
    }),
    Description: createHeadlessComponent("EducationScreen.Description", "p", {
      children: (0, import_jsx_runtime7.jsxs)(import_jsx_runtime7.Fragment, {
        children: [
          "Aptos Connect lets you take one account across any application built on Aptos.",
          " ",
          (0, import_jsx_runtime7.jsx)("a", {
            href: EXPLORE_ECOSYSTEM_URL,
            target: "_blank",
            rel: "noopener noreferrer",
            children: "Explore the ecosystem"
          }),
          "."
        ]
      })
    })
  }
];
var educationScreenIndicators = Array(educationScreens.length).fill(null).map(
  (_8, index) => createHeadlessComponent(
    "AboutAptosConnect.ScreenIndicator",
    "button",
    (displayName) => {
      const context = useAboutAptosConnectContext(displayName);
      const isActive = context.screenIndex - 1 === index;
      return {
        "aria-label": `Go to screen ${index + 1}`,
        "aria-current": isActive ? "step" : void 0,
        "data-active": isActive || void 0,
        onClick: () => {
          context.setScreenIndex(index + 1);
        }
      };
    }
  )
);
var Root = ({ renderEducationScreen, children }) => {
  const [screenIndex, setScreenIndex] = (0, import_react3.useState)(0);
  const currentEducationScreen = (0, import_react3.useMemo)(
    () => educationScreens.map((screen, i49) => ({
      ...screen,
      screenIndex: i49,
      totalScreens: educationScreens.length,
      screenIndicators: educationScreenIndicators,
      back: () => {
        setScreenIndex(screenIndex - 1);
      },
      next: () => {
        setScreenIndex(
          screenIndex === educationScreens.length ? 0 : screenIndex + 1
        );
      },
      cancel: () => {
        setScreenIndex(0);
      }
    }))[screenIndex - 1],
    [screenIndex]
  );
  return (0, import_jsx_runtime7.jsx)(AboutAptosConnectContext.Provider, {
    value: { screenIndex, setScreenIndex },
    children: screenIndex === 0 ? children : renderEducationScreen(currentEducationScreen)
  });
};
Root.displayName = "AboutAptosConnect";
var Trigger = createHeadlessComponent(
  "AboutAptosConnect.Trigger",
  "button",
  (displayName) => {
    const context = useAboutAptosConnectContext(displayName);
    return {
      onClick: () => {
        context.setScreenIndex(1);
      }
    };
  }
);
var AboutAptosConnect = Object.assign(Root, {
  Trigger
});
var SmallAptosLogo = (0, import_react9.forwardRef)((props, ref) => {
  return (0, import_jsx_runtime8.jsx)("svg", {
    ref,
    width: "12",
    height: "12",
    viewBox: "0 0 12 12",
    fill: "none",
    ...props,
    children: (0, import_jsx_runtime8.jsx)("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M6 12C9.31371 12 12 9.31371 12 6C12 2.68629 9.31371 0 6 0C2.68629 0 0 2.68629 0 6C0 9.31371 2.68629 12 6 12ZM7.17547 3.67976C7.13401 3.72309 7.07649 3.74757 7.01648 3.74757H3.00775C3.69185 2.83824 4.77995 2.25 6.00569 2.25C7.23142 2.25 8.31953 2.83824 9.00362 3.74757H8.28524C8.20824 3.74757 8.13498 3.71468 8.08401 3.65701L7.81608 3.35416C7.77618 3.30896 7.71882 3.28308 7.6585 3.28308H7.6454C7.58805 3.28308 7.53318 3.30646 7.49343 3.34792L7.17547 3.67976ZM8.05656 4.75897H7.39569C7.31869 4.75897 7.24543 4.72593 7.19447 4.66842L6.92638 4.36557C6.88647 4.32036 6.82896 4.29465 6.7688 4.29465C6.70863 4.29465 6.65112 4.32052 6.61121 4.36557L6.38131 4.6254C6.30603 4.71034 6.19801 4.75913 6.08454 4.75913H2.46703C2.36401 5.05278 2.29683 5.36296 2.27002 5.68467H5.68505C5.74506 5.68467 5.80258 5.66019 5.84404 5.61686L6.16201 5.28502C6.20175 5.24356 6.25662 5.22018 6.31398 5.22018H6.32707C6.38739 5.22018 6.44475 5.24606 6.48465 5.29126L6.75258 5.59411C6.80355 5.65178 6.87681 5.68467 6.95381 5.68467H9.74133C9.71452 5.3628 9.64734 5.05263 9.54431 4.75913H8.05641L8.05656 4.75897ZM4.33651 7.63095C4.39652 7.63095 4.45404 7.60648 4.4955 7.56315L4.81347 7.23131C4.85321 7.18985 4.90808 7.16647 4.96544 7.16647H4.97853C5.03885 7.16647 5.09621 7.19234 5.13611 7.23739L5.40404 7.54024C5.45501 7.59791 5.52827 7.6308 5.60527 7.6308H9.38285C9.52438 7.33839 9.62803 7.02463 9.68975 6.69591H6.06383C5.98683 6.69591 5.91357 6.66287 5.8626 6.60535L5.59467 6.3025C5.55477 6.2573 5.49725 6.23158 5.43709 6.23158C5.37692 6.23158 5.31941 6.25746 5.27951 6.3025L5.0496 6.56233C4.97432 6.64728 4.86631 6.69606 4.75268 6.69606H2.32147C2.3832 7.02479 2.487 7.33855 2.62837 7.63095H4.33651ZM5.57359 8.55745H4.59116C4.51417 8.55745 4.44091 8.52441 4.38994 8.46689L4.12201 8.16404C4.0821 8.11884 4.02459 8.09312 3.96442 8.09312C3.90426 8.09312 3.84675 8.119 3.80684 8.16404L3.57694 8.42387C3.50166 8.50882 3.39364 8.55761 3.28001 8.55761H3.26474C3.94915 9.29096 4.92378 9.74998 6.00596 9.74998C7.08815 9.74998 8.06262 9.29096 8.74719 8.55761H5.57359V8.55745Z",
      fill: "currentColor"
    })
  });
});
SmallAptosLogo.displayName = "SmallAptosLogo";
var APTOS_PRIVACY_POLICY_URL = "https://aptoslabs.com/privacy";
var Root2 = createHeadlessComponent("AptosPrivacyPolicy.Root", "div");
var Disclaimer = createHeadlessComponent(
  "AptosPrivacyPolicy.Disclaimer",
  "span",
  { children: "By continuing, you agree to Aptos Labs'" }
);
var Link = createHeadlessComponent("AptosPrivacyPolicy.Disclaimer", "a", {
  href: APTOS_PRIVACY_POLICY_URL,
  target: "_blank",
  rel: "noopener noreferrer",
  children: "Privacy Policy"
});
var PoweredBy = (0, import_react8.forwardRef)(({ className }, ref) => {
  return (0, import_jsx_runtime9.jsxs)("div", {
    ref,
    className,
    children: [
      (0, import_jsx_runtime9.jsx)("span", {
        children: "Powered by"
      }),
      (0, import_jsx_runtime9.jsx)(SmallAptosLogo, {}),
      (0, import_jsx_runtime9.jsx)("span", {
        children: "Aptos Labs"
      })
    ]
  });
});
PoweredBy.displayName = "AptosPrivacyPolicy.PoweredBy";
var AptosPrivacyPolicy = Object.assign(Root2, {
  Disclaimer,
  Link,
  PoweredBy
});
function useWalletItemContext(displayName) {
  const context = (0, import_react10.useContext)(WalletItemContext);
  if (!context) {
    throw new Error(`\`${displayName}\` must be used within \`WalletItem\``);
  }
  return context;
}
var WalletItemContext = (0, import_react10.createContext)(null);
var Root3 = (0, import_react10.forwardRef)(
  ({ wallet, onConnect, className, asChild, children }, ref) => {
    const { connect } = useWallet();
    const connectWallet = (0, import_react10.useCallback)(() => {
      connect(wallet.name);
      onConnect == null ? void 0 : onConnect();
    }, [connect, wallet.name, onConnect]);
    const isWalletReady = wallet.readyState === WalletReadyState.Installed || wallet.readyState === WalletReadyState.Loadable;
    const mobileSupport = "deeplinkProvider" in wallet && wallet.deeplinkProvider;
    if (!isWalletReady && isRedirectable() && !mobileSupport)
      return null;
    const Component = asChild ? Slot : "div";
    return (0, import_jsx_runtime10.jsx)(WalletItemContext.Provider, {
      value: { wallet, connectWallet },
      children: (0, import_jsx_runtime10.jsx)(Component, {
        ref,
        className,
        children
      })
    });
  }
);
Root3.displayName = "WalletItem";
var Icon = createHeadlessComponent(
  "WalletItem.Icon",
  "img",
  (displayName) => {
    const context = useWalletItemContext(displayName);
    return {
      src: context.wallet.icon,
      alt: `${context.wallet.name} icon`
    };
  }
);
var Name = createHeadlessComponent(
  "WalletItem.Name",
  "div",
  (displayName) => {
    const context = useWalletItemContext(displayName);
    return {
      children: context.wallet.name
    };
  }
);
var ConnectButton = createHeadlessComponent(
  "WalletItem.ConnectButton",
  "button",
  (displayName) => {
    const context = useWalletItemContext(displayName);
    return {
      onClick: context.connectWallet,
      children: "Connect"
    };
  }
);
var InstallLink = createHeadlessComponent(
  "WalletItem.InstallLink",
  "a",
  (displayName) => {
    const context = useWalletItemContext(displayName);
    return {
      href: context.wallet.url,
      target: "_blank",
      rel: "noopener noreferrer",
      children: "Install"
    };
  }
);
var WalletItem = Object.assign(Root3, {
  Icon,
  Name,
  ConnectButton,
  InstallLink
});

export {
  WalletReadyState,
  NetworkName2 as NetworkName,
  ChainIdToAnsSupportedNetworkMap,
  APTOS_CONNECT_BASE_URL,
  APTOS_CONNECT_ACCOUNT_URL,
  convertNetwork,
  convertV2TransactionPayloadToV1BCSPayload,
  convertV2PayloadToV1JSONPayload,
  generateTransactionPayloadFromV1Input,
  isMobile,
  isInAppBrowser,
  isRedirectable,
  generalizedErrorMessage,
  areBCSArguments,
  getAptosConfig,
  isAptosNetwork,
  fetchDevnetChainId,
  setLocalStorage,
  removeLocalStorage,
  getLocalStorage,
  scopePollingDetectionStrategy,
  partitionWallets,
  isInstalledOrLoadable,
  isInstallRequired,
  truncateAddress,
  isAptosConnectWallet,
  getAptosConnectWallets,
  groupAndSortWallets,
  WalletCoreV1,
  WalletStandardCore,
  WalletCore,
  WalletContext,
  useWallet,
  AptosWalletAdapterProvider,
  EXPLORE_ECOSYSTEM_URL,
  AboutAptosConnect,
  APTOS_PRIVACY_POLICY_URL,
  AptosPrivacyPolicy,
  WalletItem
};
/*! Bundled license information:

@mizuwallet-sdk/aptos-wallet-adapter/dist/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
  (**
    postmate - A powerful, simple, promise-based postMessage library
    @version v1.5.2
    @link https://github.com/dollarshaveclub/postmate
    @author Jacob Kelley <jakie8@gmail.com>
    @license MIT
  **)
*/
//# sourceMappingURL=chunk-YZDSGNEA.js.map
